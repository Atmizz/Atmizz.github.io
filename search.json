[{"title":"CF 1537D - Deleting Divisors题解","url":"/post/2328484107.html","content":"<center> CF 1537D - Deleting Divisors题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1537/problem/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201537D.png)\n\n#### Sample Input\n\n```\n4\n1\n4\n12\n69\n```\n\n#### Sample Output\n\n```\nBob\nAlice\nAlice\nBob\n```\n\n#### 解析：\n\n博弈论\n\n我们进行分类讨论，按照三种情况：1）$n$ 为奇数 ，2） $n$ 为偶数但不是 $2$ 的幂，3） $n$ 为偶数并且是 $2$ 的幂。\n\n1. $n$ 为奇数\n\n   a. $n$ 为质数，则当前玩家败。\n\n   b. $n$ 不为质数，那么 $n$ 的因子一定全为奇数，那么减去任意一个奇数， $n$ 就会变成一个偶数，且该偶数一定不是 $2$ 的幂。\n\n2. $n$ 为偶数但不是 $2$ 的幂\n\n因为 $n$ 不为 $2$ 的幂，所以 $n$ 一定存在一个非 $1$ 的奇数因子 $d$ ，那么对于当前情况来说，一定可以减去 $d$ ，从而 $n$ 变成一个奇数（情况 $1$ ）\n\n下一步又会变成情况 $2$ \n\n...\n\n最后直至变成一个质数奇数\n\n显然，当前状态是必胜的。\n\n3. $n$ 为偶数且是 $2$ 的幂\n\n对于当前玩家来说，最优的方案就是将 $n$ 减半，又变成一个 $2$ 的幂。\n\n因为你减去其他因子，会变成情况 $2$ ，那么就会是必败态。\n\n那么， $n$ 一直减半，直到 $2$ 失败。\n\n显然，当 $n$ 为 $2$ 的奇次幂是必败态，偶次幂是必胜态。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int n; std :: cin >> n;\n    int cnt = 0;\n    while(n % 2 == 0) cnt ++, n /= 2;\n    if(n == 1 && cnt & 1) {\n        std :: cout << \"Bob\\n\";\n        return ;\n    }\n    if(cnt > 0) std :: cout << \"Alice\\n\";\n    else std :: cout << \"Bob\\n\";\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["博弈论"],"categories":["题解","CF"]},{"title":"CF 165C - Another Problem on Strings题解","url":"/post/2520344268.html","content":"<center> CF 165C - Another Problem on Strings题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/165/C)\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20165C.png)\n\n#### Sample Input\n\n```\n2\n01010\n```\n\n#### Sample Output\n\n```\n4\n```\n\n#### 解析：\n\n数学题。\n\n注意到 $k$ 的范围，所以我们分类讨论。\n\n1. $0 < k \\leq 10^6$\n\n那么子串中必须有 $1$ ，所以我们可以把 $1$ 的位置都记录下来，然后从第一个 $1$ 开始枚举，看这 $k$ 个 $1$ 左右两边 $0$ 的个数，答案即为乘积累加和。\n\n2. $k = 0$\n\n那么子串中不能有 $1$ ，我们仍然可以利用存 $1$ 的数组，计算相邻的 $1$ 之间的 $0$ 串的子串和，再把答案累加即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nint k;\nstd :: string s;\nvoid solve() {\n    std :: cin >> k >> s;\n    int n = s.length();\n    std :: vector <int> v;\n    v.push_back(0);\n    for(int i = 0; i < n; ++ i)\n        if(s[i] == '1')\n            v.push_back(i + 1);\n    v.push_back(n + 1);\n    int m = v.size() - 2;\n    i64 ans = 0;\n    if(k > 0) {\n        for(int i = 1; i <= m; ++ i)\n            if(i + k - 1 <= m)\n                ans += (i64)(v[i] - v[i-1]) * (v[i+k] - v[i+k-1]);\n    } else {\n        for(int i = 1; i <= m + 1; ++ i)\n            if(v[i] > v[i-1] + 1)\n                ans += i64(v[i] - v[i-1]) * (v[i] - v[i-1] - 1) / 2;\n    }\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["数学"],"categories":["题解","CF"]},{"title":"CF 1567C - Carrying Conundrum题解","url":"/post/1573286431.html","content":"<center> CF 1567C - Carrying Conundrum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1567/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201567C.png)\n\n#### Sample Input\n\n```\n5\n100\n12\n8\n2021\n10000\n```\n\n#### Sample Output\n\n```\n9\n4\n7\n44\n99\n```\n\n#### 解析：\n\n与正常的加法相比，隔位进 $1$ 。\n\n也就是说相邻的两位之间无任何关系。\n\n那么我们可以把奇数位置的数单独拿出来当作一个数，偶数位置的数单独拿出来当作一个数，可以按照正常加法来算方案数。\n\n设奇数位置的数为 $a$ ，偶数位置的数为 $b$ ，那么方案数就是 $(a + 1) \\times (b + 1)$\n\n题目中又说是正整数，那么再减去 $2$ 就好了（一个情况是 $a$ 为 $0$ ，另一个情况是 $b$ 为 $0$）。\n\n答案即 $(a+1) \\times (b+1) - 2$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 20;\nvoid solve() {\n    std :: string s; std :: cin >> s;\n    int n = s.length();\n    int a = 0, b = 0;\n    for(int i = 0; i < n; ++ i)\n        if(i % 2 == 0) a = a * 10 + (s[i] - '0');\n        else b = b * 10 + (s[i] - '0');\n    std :: cout << (a + 1) * (b + 1) - 2 << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["组合数学"],"categories":["题解","CF"]},{"title":"CF 1455D - Sequence and Swaps题解","url":"/post/1117243170.html","content":"<center> CF 1455D - Sequence and Swaps题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1455/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201455D.png)\n#### Sample Input\n\n```\n6\n4 1\n2 3 5 4\n5 6\n1 1 3 4 4\n1 10\n2\n2 10\n11 9\n2 10\n12 11\n5 18\n81 324 218 413 324\n```\n\n#### Sample Output\n\n```\n3\n0\n0\n-1\n1\n3\n```\n\n#### 解析：\n\n贪心。\n\n观察题目，我们得知，每一次交换 $x$ 的值是在变大的，所以我们一定是从前向后交换值。\n\n所以我们从开始一直到结束不断交换，直到最后一个乱序的位置即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\nvoid solve() {\n    int n, x, ans = 0, k = 0; std :: cin >> n >> x;\n    std :: vector <int> a(n + 1);\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= n; ++ i)\n        if(a[i] < a[i-1]) k = i;\n    for(int i = 1; i <= k; ++ i)\n        if(a[i] > x) std :: swap(a[i], x), ans ++;\n    for(int i = 1; i <= n; ++ i)\n        if(a[i] < a[i-1]) {\n            std :: cout << -1 << endl;\n            return ;\n        }\n    std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1537E1 - Erase and Extend (Easy Version)题解","url":"/post/3670149279.html","content":"<center> CF 1537E1 - Erase and Extend (Easy Version)题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1537/problem/E1)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201537E1.png)\n\n#### Sample Input\n\n```\n8 16\ndbcadabc\n```\n\n#### Sample Output\n\n```\ndbcadabcdbcadabc\n```\n\n#### 解析：\n\n暴力。\n\n考虑只会不断复制给定字符串的前缀，长度大于等于 $k$ ，删除多余的即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5050;\nvoid solve() {\n    int n, k;\n    std :: string str, ans = \"\";\n    std :: cin >> n >> k >> str;\n    for(int i = 1; i <= k; ++ i)\n        ans += 'z';\n    for(int i = 0; i < n; ++ i) {\n        int l = 0;\n        while((i + 1) * (1 << l) < k) l ++;\n        std :: string s = str.substr(0, i + 1);\n        for(int j = 1; j <= l; ++ j)\n            s = s + s;\n        // deb(l); deb(s);\n        ans = std :: min(ans, s.substr(0, k));\n    }\n    std :: cout << ans << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["暴力"],"categories":["题解","CF"]},{"title":"CF 1890E1 - Doremy's Drying Plan (Easy Version)题解","url":"/post/2531427535.html","content":"<center> CF 1890E1 - Doremy's Drying Plan (Easy Version)题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1890/E1)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201890E1.png)\n\n#### Sample Input\n\n```\n6\n2 3 2\n1 2\n1 2\n1 1\n5 3 2\n1 3\n2 4\n3 5\n10 6 2\n1 5\n6 10\n2 2\n3 7\n5 8\n1 4\n100 6 2\n1 100\n1 100\n1 100\n1 100\n1 100\n1 100\n1000 2 2\n1 1\n1 1\n20 5 2\n9 20\n3 3\n10 11\n11 13\n6 18\n```\n\n#### Sample Output\n\n```\n1\n2\n3\n0\n1000\n15\n```\n\n#### 解析：\n\n简单版本只需要考虑去除两条线段，完全可以暴力。\n\n去除两条线段，就只有两种情况：第一，两线段互不相交；第二，两个线段有一部分交集。\n\n对于第一种情况，我们只需要统计对于每一条线段所覆盖的 $1$ 的数量即可，然后取前两大加起来。\n\n对于第二种情况，我们只需要找到只被两条线段覆盖的点，然后找到那两个线段，统计覆盖的点为 $1$ 或 $2$ 的个数即可，\n\n对于如何找那两个线段，我们可以这么做：\n\n当遍历到只被两条线段覆盖的点，我们把前面所有左端点小于等于当前点的线段加到一个集合里。\n\n然后删除掉右端点大于当前点的线段，那么集合中一定只剩下那两个线段。\n\n对于某个点被一个线段覆盖还是被两个线段覆盖，我们可以利用差分和前缀和：\n\n把每个线段差分一下，然后计算出每个点的情况。\n\n然后对于 $1$ 和 $2$ 分别进行前缀和。\n\n最后一定不要忘了在加上 $0$ 的点。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, m, k, d[N], s1[N], s2[N];\nstruct Line {\n    int l, r;\n    friend bool operator < (Line a, Line b) {\n        return a.l == b.l ? a.r < b.r : a.l < b.l;\n    }\n}line[N];\nint solution1() {\n    std :: priority_queue <int> q;\n    for(int i = 1; i <= m; ++ i)\n        q.push(s1[line[i].r] - s1[line[i].l-1]);\n    int maxx = q.top(); q.pop();\n    return q.top() + maxx;\n}\nint solution2() {\n    std :: sort(line + 1, line + 1 + m);\n    std :: multiset <pi> s;\n    int j = 1, maxx = 0;\n    for(int i = 1; i <= n; ++ i) {\n        if(d[i] == 2) {\n            while(j <= m && line[j].l <= i) s.insert({line[j].r, line[j].l}), ++ j;\n            while(s.size() && s.begin()->first < i) s.erase(s.begin());\n            int l = std :: min(s.begin()->second, s.rbegin()->second);\n            int r = std :: max(s.begin()->first, s.rbegin()->first);\n            int res = s1[r] - s1[l-1];\n            l = std :: max(s.begin()->second, s.rbegin()->second);\n            r = std :: min(s.begin()->first, s.rbegin()->first);\n            res += s2[r] - s2[l-1];\n            maxx = std :: max(maxx, res);\n        }\n    }\n    return maxx;\n}\nvoid init() {\n    for(int i = 1; i <= n; ++ i)\n        d[i] = 0;\n}\nvoid solve() {\n    std :: cin >> n >> m >> k;\n    init(); int cnt = 0;\n    for(int i = 1; i <= m; ++ i)\n        std :: cin >> line[i].l >> line[i].r;\n    for(int i = 1; i <= m; ++ i)\n        d[line[i].l] ++, d[line[i].r+1] --;\n    for(int i = 1; i <= n; ++ i)\n        d[i] += d[i-1];\n    for(int i = 1; i <= n; ++ i)\n        cnt += (d[i] == 0);\n    for(int i = 1; i <= n; ++ i)\n        s1[i] = s1[i-1] + (d[i] == 1);\n    for(int i = 1; i <= n; ++ i)\n        s2[i] = s2[i-1] + (d[i] == 2);\n    std :: cout << std :: max(solution1(), solution2()) + cnt << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["前缀和","差分","multiset"],"categories":["题解","CF"]},{"title":"CF 1615C - Menorah题解","url":"/post/224910530.html","content":"<center> CF 1615C - Menorah题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1615/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201615C.png)\n\n#### Sample Input\n\n```\n5\n5\n11010\n11010\n2\n01\n11\n3\n000\n101\n9\n100010111\n101101100\n9\n001011011\n011010101\n```\n\n#### Sample Output\n\n```\n0\n1\n-1\n3\n4\n```\n\n#### 解析：\n\n我们肯定能知道，所作次数与蜡烛的位置是没有关系的。\n\n我们手玩几个样例会发现一种偶数次操作次数的方案。\n\n当然，这个偶数次操作方案必须有一个条件，在对应位置上，$s1[i]$ 为 $1$ 且 $s2[i]$ 为 $0$ 的个数与 $s1[j]$ 为 $0$ 且 $s2[j]$ 为 $1$ 的个数相同。\n\n第一步选择 $s1[i] = 1 , s2[i] = 0$ 的位置，操作一次。\n\n第二步选择 $s1[j]=0 , s2[j]=1$ 的位置，操作一次。\n\n你会发现，$s1[i] = 0,s1[j] = 1$。\n\n不断重复上述过程即可，这就是偶数次操作。\n\n然后我们就会想，如何奇数次操作呢？\n\n如果奇数次操作，那么不动那些不一样的即可，奇数次后会将他们变得一样，那我们就只能动一样的。\n\n对于一样的来说也是如此，奇数次就会变得不一样，我们一样的我们都要选中一次操作，那么对于选其他位置的数操作来说，当前这个数就相当于操作了偶数次，即不变。\n\n手玩几个样例，会发现，操作次序一定是，选择 $s[i]=1$ ，选择 $s[j]0$ ，选择 $s[k]=1$ ，...，$s[h]=1$。\n\n即一定是$1010...1$，所以保证相同的位置是 $1$ 的个数比相同位置为 $0$ 的个数多一个即可。\n\n遮这样的话，只记录个数即可，复杂度为 $O(N)$.\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nvoid solve() {\n    std :: string s1, s2;\n    int n;\n    std :: cin >> n;\n    std :: cin >> s1 >> s2;\n    if(s1 == s2) {\n        std :: cout << 0 << endl;\n        return ;\n    }\n    // solution1\n    int cnt0 = 0, cnt1 = 0;\n    for(int i = 0; i < n; ++ i)\n        if(s1[i] == '0' && s2[i] == '0') cnt0 ++;\n        else if(s1[i] == '1' && s2[i] == '1') cnt1 ++;\n    int ans = INF;\n    if(cnt1 == cnt0 + 1) ans = cnt0 * 2 + 1;\n    // solution2\n    cnt0 = 0; cnt1 = 0;\n    for(int i = 0; i < n; ++ i)\n        if(s1[i] == '1' && s2[i] == '0') cnt1 ++;\n        else if(s1[i] == '0' && s2[i] == '1') cnt0 ++;\n    if(cnt0 == cnt1 && cnt0 != 0) ans = std :: min(ans, cnt0 + cnt1);\n    if(ans == INF) std :: cout << -1 << endl;\n    else std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["暴力"],"categories":["题解","CF"]},{"title":"CF 1890D - Doremy's Connecting Plan题解","url":"/post/1511877259.html","content":"<center> CF 1890D - Doremy's Connecting Plan题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1890/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201890D.png)\n\n#### Sample Input\n\n```\n7\n4 10\n0 20 15 10\n2 1\n1 1\n5 1\n0 1 0 4 199\n5 2\n1 1 3 1 1\n5 5\n5 6 1 10 2\n5 1000000\n1000000000000 1000000000000 1000000000000 1000000000000 1000000000000\n3 1\n0 0 2\n```\n\n#### Sample Output\n\n```\nYes\nYes\nYes\nNo\nNo\nYes\nNo\n```\n\n#### 解析：\n\n贪心。\n\n观察式子 $\\sum \\limits _{k \\in S} {a_k \\ge i \\cdot j \\cdot c}$ ，\n\n显然，为了让这个不等式成立，我们要尽量让 $i$ 或 $j$ 取最小值，\n\n设 $s[i]$ 为 $i$ 代表的连通块的和， $s[j]$ 也是如此，\n\n则有 $s[i] + s[j] \\ge i \\cdot j \\cdot c$ ，\n\n不妨让 $i = 1$ ，\n\n则 $s[1] + s[j] \\ge j \\cdot c$ 。\n\n我们可以反证一下，证明上式的正确性。\n\n设存在 $i \\ge 2,j \\ge 2$  满足 $\\begin{cases} i \\neq j \\\\ s[i] + s[j] \\ge i \\cdot j \\cdot c \\\\ s[1] + s[j] < j \\cdot c \\\\ s[1] + s[i] < i \\cdot c\\end{cases}$\n\n合并后两个式子，\n\n$$s[i] + s[j] < (i + j) \\cdot c - 2s[1] $$\n\n$$s[i] + s[j] < (i + j) \\cdot c $$\n\n$$s[i] + s[j] < i \\cdot j \\cdot c $$\n\n与假设矛盾，则假设不成立，即原式正确。\n\n所以我们转化一下 $s[1] + s[j] \\ge j \\cdot c$ ，有 $s[1] \\ge j \\cdot c - s[j]$。\n\n为了尽量合并更多联通块，我们可以按照 $j \\cdot c - s[j]$ 排序，从最小值开始合并。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\ni64 n, c;\nstruct Node {\n    i64 val, id;\n    friend bool operator < (Node a, Node b) {\n        return c * a.id - a.val < c * b.id - b.val;\n    }\n}a[N];\nvoid solve() {\n    std :: cin >> n >> c;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i].val, a[i].id = i;\n    std :: sort(a + 2, a + 1 + n);\n    i64 s = a[1].val;\n    for(int i = 2; i <= n; ++ i) {\n        if(s + a[i].val >= a[i].id * c) s += a[i].val;\n        else {\n            std :: cout << \"No\\n\";\n            return ;\n        }\n    }\n    std :: cout << \"Yes\\n\";\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1303C - Perfect Keyboard题解","url":"/post/1834842648.html","content":"<center> CF 1303C - Perfect Keyboard题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1303/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201303C.png)\n\n#### Sample Input\n\n```\n5\nababa\ncodedoca\nabcda\nzxzytyz\nabcdefghijklmnopqrstuvwxyza\n```\n\n#### Sample Output\n\n```\nYES\nbacdefghijklmnopqrstuvwxyz\nYES\nedocabfghijklmnpqrstuvwxyz\nNO\nYES\nxzytabcdefghijklmnopqrsuvw\nNO\n```\n\n#### 解析：\n\n构造题。\n\n首先，我们要确定什么条件下才能构造出来一个序列。\n\n我们把相邻的字母都连一条边，然后需要满足以下条件：\n\n1. 没有一个字母的度大于 $2$。\n2. 没有环。\n\n第一个条件很好判断，在此不讲。\n\n第二个条件的话，有两种判断方法。\n\n1. 先判断是否有度等于 $1$ ，如果没有那就说明一定有环，则可以输出`NO`。\n2. 如果有，那么也有可能有环，可以从度为 $1$ 的进入，遇到环就判否。\n\n两个条件都满足，则一定会有一条链，按顺序输出，然后把剩下的随便输出即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 220;\nstd :: string str;\nint s[N];\nvoid solve() {\n    std :: cin >> str;\n    int n = str.length();\n    for(int i = 0; i < n; ++ i)\n        s[i+1] = str[i] - 'a' + 1;\n    if(n == 1) {\n        std :: cout << \"YES\\n\";\n        for(int i = 1; i <= 26; ++ i)\n            std :: cout << char(i+'a'-1);\n        std :: cout << endl;\n        return ;\n    }\n    std :: set <int> adj[N];\n    std :: vector <int> vis(30);\n    adj[s[1]].insert(s[2]);\n    adj[s[n]].insert(s[n-1]);\n    for(int i = 2; i < n; ++ i) {\n        adj[s[i]].insert(s[i-1]);\n        adj[s[i]].insert(s[i+1]);\n    }\n    for(int i = 1; i <= 26; ++ i)\n        if(adj[i].size() > 2) {\n            std :: cout << \"NO\\n\";\n            return ;\n        }\n    std :: vector <int> ans;\n    int cnt_1 = 0;\n    for(int i = 1; i <= 26; ++ i)\n        if(adj[i].size() == 1) {\n            int x = i; cnt_1 ++;\n            while(1) {\n                if(vis[x]) {\n                    std :: cout << \"NO\\n\";\n                    return ;\n                }\n                vis[x] = 1;\n                ans.push_back(x);\n                if(adj[x].size() == 0) break;\n                for(auto y : adj[x])\n                    if(y != x) {\n                        adj[x].erase(y);\n                        adj[y].erase(x);\n                        x = y;\n                        break;\n                    }\n            }\n        }\n    if(cnt_1 == 0) {\n        std :: cout << \"NO\\n\";\n        return ;\n    }\n    std :: cout << \"YES\\n\";\n    for(auto x : ans)\n        std :: cout << char(x+'a'-1);\n    for(int i = 1; i <= 26; ++ i)\n        if(!vis[i])\n            std :: cout << char(i+'a'-1);\n    std :: cout << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["构造题"],"categories":["题解","CF"]},{"title":"CF 1622C - Set or Decrease题解","url":"/post/248256200.html","content":"<center> CF 1622C - Set or Decrease题解题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1622/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201622C.png)\n\n#### Sample Input\n\n```\n4\n1 10\n20\n2 69\n6 9\n7 8\n1 2 1 3 1 2 1\n10 1\n1 2 3 1 2 6 1 6 8 10\n```\n\n#### Sample Output\n\n```\n10\n0\n2\n7\n```\n\n#### 解析：\n\n首先要确定一点，当最大值和最小值的差大于 $1$ 时，赋值远比减一划算。\n\n所以我们尽量减小最小值，并且把最小值赋给较大的值是最优的。\n\n这个题我想了两种思路，但是第一种没有成功实现，两种方法都说一下。\n\n设 $a[]$ 为原数组，$sum$ 为前缀和数组， $k$ 为不等式右边的值， $m$ 为要被 $a[1]$ 赋值的个数。\n\n##### 方法一：\n\n枚举不被赋值的数的个数，求 $a[1]$ 减后的值，继而求出答案。\n\n设不被赋值的数的个数为 $i(1 \\leq i \\leq n - 2)$ ，$a[1]$ 减后的值为 $b$ 。\n\n则有 $(m + 1) \\times b + sum[n-m] - sum[1] \\leq k$ ，\n\n变形，有 $m \\times b \\leq k - (sum[n-m] - sum[1])$ ，\n\n设 $\\Delta$ 为 $sum[n-m] - sum[1]$ ，\n\n有 $m \\times b \\leq k - \\Delta$ ，\n\n1. 当 $k - \\Delta \\ge 0$ ，则 $b \\leq \\frac{k - \\Delta}{m}$\n   1. $a[1] \\leq \\frac{k - \\Delta}{m}$ ，则答案为 $m$\n   2. $a[1] > \\frac{k - \\Delta}{m}$，则答案为 $a[1] - b + m$\n2. 当 $k - \\Delta < 0$ ，则 $-b > \\frac{\\Delta - k}{m}$ ，答案为 $\\frac{\\Delta - k}{m} + a[1] + m$\n\n##### 方法二：\n\n二分一下操作次数，然后枚举被 $a[1]$ 赋值的数的个数，$mid$ 减去上述的数即为 $a[1]$ 要减去的数。\n\n仅贴一下方法二的代码。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\ni64 n, k, a[N], sum[N];\nbool check(i64 mid) {\n    if(mid >= n - 1)\n        if(n * (a[1] - (mid - n + 1)) <= k) return true;\n    for(i64 i = 0; i < n - 1; ++ i)\n        if(mid >= i)\n            if((i + 1) * (a[1] - (mid - i)) + sum[n-i] - sum[1] <= k)\n                return true;\n    return false;\n}\nvoid solve() {\n    std :: cin >> n >> k;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    if(n == 1) {\n        std :: cout << (a[1] <= k ? 0 : a[1] - k) << endl;\n        return ; \n    }\n    std :: sort(a + 1, a + 1 + n);\n    for(int i = 1; i <= n; ++ i)\n        sum[i] = sum[i-1] + a[i];\n    i64 l = 0, r = 1e15, ans;\n    while(l <= r) {\n        i64 mid = (l + r) >> 1;\n        if(check(mid)) r = mid - 1, ans = mid;\n        else l = mid + 1;\n    }\n    std :: cout << std :: min(ans, (sum[n] - k) >= 0 ? (sum[n] - k) : 0) << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["前缀和","二分"],"categories":["题解","CF"]},{"title":"CF 1474C - Array Destruction题解","url":"/post/3694985655.html","content":"<center> CF 1474C - Array Destruction题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1474/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201474C.png)\n\n#### Sample Input\n\n```\n4\n2\n3 5 1 2\n3\n1 1 8 8 64 64\n2\n1 1 2 4\n5\n1 2 3 4 5 6 7 14 3 11\n```\n\n#### Sample Output\n\n```\nYES\n6\n1 5\n2 3\nNO\nNO\nYES\n21\n14 7\n3 11\n5 6\n2 4\n3 1\n```\n\n#### 解析：\n\n容易发现，最大的数只能第一次删除，第二大的数只能第二次删除，第三大的数只能第三次删除，...，第 $k$ 大的数只能第三次删除。\n\n所以我们奠定一个基础，删除的时候从大的遍历到小的。\n\n那么我们如何确定第一个最大的数和哪个数组合呢？\n\n我们发现 $n \\leq 1,000$\n\n我们可以枚举这个数，复杂度为 $O(n^2)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nvoid solve() {\n    int n; std :: cin >> n;\n    std :: vector <int> a(n<<1);\n    for(int i = 0; i < n << 1; ++ i)\n        std :: cin >> a[i];\n    std :: sort(a.begin(), a.end());\n    for(int i = 0; i < (n << 1) - 1; ++ i) {\n        std :: map <int, int> cnt;\n        for(int j = 0; j < (n << 1); ++ j)\n            cnt[a[j]] ++;\n        int x = a[i] + a[(n<<1)-1];\n        std :: vector <pi> ans;\n\n        for(int j = (n << 1) - 1; j >= 0; -- j) {\n            if(cnt[a[j]] == 0) continue;\n            if(cnt[x-a[j]] == 0) break;\n            if(a[j] << 1 == x && cnt[a[j]] == 1) break;\n            ans.push_back({x-a[j], a[j]});\n            cnt[x-a[j]] --; cnt[a[j]] --; x = a[j];\n        }\n        // deb(ans.size());\n        if(ans.size() == n) {\n            std :: cout << \"YES\\n\" << a[i] + a[(n<<1)-1] << endl;\n            for(auto [s, t] : ans)\n                std :: cout << s << ' ' << t << endl;\n             return ;\n        }\n    }\n    std :: cout << \"NO\" << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["枚举","暴力"],"categories":["题解","CF"]},{"title":"CF 1632C - Strange Test题解","url":"/post/2327128442.html","content":"\n<center> CF 1632C - Strange Test题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1632/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201632C.png)\n\n#### Sample Input\n\n```\n5\n1 3\n5 8\n2 5\n3 19\n56678 164422\n```\n\n#### Sample Output\n\n```\n1\n3\n2\n1\n23329\n```\n\n#### 解析：\n\n首先要确定一个性质： $a \\mid b \\geq b$\n\n所以我们就会有三种方案：\n\n1. $a$ 一直自加到 $b$\n2. $a$ 一直自加，然后 $a \\mid b = b$\n3. $b$ 一直自加，然后 $a \\mid b = b$\n\n我们观察到 $\\sum \\limits{b} \\leq 10^6$\n\n所以是可以暴力枚举的。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nint solution1(int a, int b) {\n    return b - a;\n}\nint solution2(int a, int b) {\n    int ans = 1;\n    while(1) {\n        if((a | b) == b) return ans;\n        ans ++; a ++;\n    }\n}\nint solution3(int a, int b) {\n    int ans = 1;\n    while(1) {\n        if((a | b) == b) {\n            return ans;\n        }\n        b ++; ans ++;\n    }\n}\nvoid solve() {\n    int a, b;\n    std :: cin >> a >> b;\n    std :: cout << std :: min(solution1(a, b), \n        std :: min(solution2(a, b), solution3(a, b))) << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["暴力","位运算"],"categories":["题解","CF"]},{"title":"洛谷 P3567 POI2014 KUR-Couriers题解","url":"/post/469529373.html","content":"<center> 洛谷 P3567 POI2014 KUR-Couriers题解 </center>\n<!--more-->\n\n[原题链接](https://www.luogu.com.cn/problem/P3567)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/Luogu%20P3567.png)\n#### Sample Input\n\n```\n7 5\n1 1 3 2 3 4 3\n1 3\n1 4\n3 7\n1 7\n6 6\n```\n\n#### Sample Output\n\n```\n1\n0\n3\n0\n4\n```\n\n#### 解析：\n\n求区间内严格超过一半的数。\n\n一个性质（废话）：区间内严格超过一半的数一定在区间内严格超过一半。\n\n我们可以使用主席树，我们只需要在权值线段树内找个数大于当前区间一半的那一半子树。\n\n一直找下去，分为两种情况：\n\n1. 有答案，那就会一直找到叶子节点，返回答案即可。\n2. 无答案，则在当前树中，左右两颗子树的数个数一定都不会大于区间一半。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5e5 + 20;\nint n, m, a[N], rt[N*40], tot;\nstruct Node {\n    int l, r, cnt;\n}t[N*40];\nvoid insert(int &k, int bk, int l, int r, int val) {\n    if(!k) k = ++ tot;\n    t[k].cnt = t[bk].cnt + 1;\n    if(l == r) return ;\n    int mid = (l + r) >> 1;\n    if(val <= mid) {\n        t[k].r = t[bk].r;\n        insert(t[k].l, t[bk].l, l, mid, val);\n    } else {\n        t[k].l = t[bk].l;\n        insert(t[k].r, t[bk].r, mid+1, r, val);\n    }\n}\nint query(int k1, int k2, int l, int r, int len) {\n    // std :: cout << l << ' ' << r << endl;\n    if(l == r && t[k1].cnt - t[k2].cnt > len) return l;\n    if(t[t[k1].l].cnt - t[t[k2].l].cnt <= len && t[t[k1].r].cnt - t[t[k2].r].cnt <= len)\n        return 0;\n    int mid = (l + r) >> 1;\n    if(t[t[k1].l].cnt - t[t[k2].l].cnt > len) return query(t[k1].l, t[k2].l, l, mid, len);\n    return query(t[k1].r, t[k2].r, mid+1, r, len);\n}\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= n; ++ i)\n        insert(rt[i], rt[i-1], 1, n, a[i]);\n    for(int i = 1; i <= m; ++ i) {\n        int l, r; std :: cin >> l >> r;\n        std :: cout << query(rt[r], rt[l-1], 1, n, (r - l + 1) >> 1) << endl;\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["主席树"],"categories":["题解","Luogu"]},{"title":"洛谷 P3963 TJOI2013 奖学金题解","url":"/post/1445769701.html","content":"<center> 洛谷 P3963 TJOI2013 奖学金题解 </center>\n<!--more-->\n\n[原题链接](https://www.luogu.com.cn/problem/P3963)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/Luogu%20P3963.png)\n#### Sample Input\n\n```\n3 5 70\n30 25\n50 21\n20 20\n5 18\n35 30\n```\n\n#### Sample Output\n\n```\n35\n```\n\n#### 解析：\n\n求最大中位数。\n\n按照题意，我们只需要找到一个最大的中位数，且满足该中位数前面的前 $\\frac{n}{2}$ 小值的和该中位数后面的前 $\\frac{n}{2}$ 值的和不超过 $f$ 即可。\n\n很容易想到可以二分，但是二分并不满足单调性，所以不能用二分。\n\n观察数据范围， $0 \\leq c \\leq 2e5$ ，可以用 $O(nlogn)$ 的方法通过。\n\n我们可以枚举每一个数作为中位数，然后在 $O(logn)$ 的时间内查询该数前面前 $\\frac{n}{2}$ 小值的和该数后面的前 $\\frac{n}{2}$ 值的和。\n\n可以用优先队列和主席树维护。\n\n我这里用的主席树。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define int long long\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e5;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint c, n, f, rt[N*40], tot;\nstruct stu {\n    i64 a, b;\n    friend bool operator < (stu a, stu b) {\n        return a.a < b.a;\n    }\n}s[N];\nstruct Node {\n    int l, r, cnt;\n    i64 sum;\n}t[N*40];\nvoid pushUp(int k) {\n    t[k].sum = t[t[k].l].sum + t[t[k].r].sum;\n    t[k].cnt = t[t[k].l].cnt + t[t[k].r].cnt;\n}\nvoid modify(int &k, int bk, int l, int r, int val) {\n    if(!k) k = ++ tot;\n    if(l == r) {\n        t[k].sum = t[bk].sum + val;\n        t[k].cnt = t[bk].cnt + 1;\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    if(val <= mid) {\n        t[k].r = t[bk].r;\n        modify(t[k].l, t[bk].l, l, mid, val);\n    } else {\n        t[k].l = t[bk].l;\n        modify(t[k].r, t[bk].r, mid+1, r, val);\n    }\n    pushUp(k);\n}\ni64 query(int k1, int k2, int l, int r, int x) {\n    // std :: cout << l << ' ' << r << endl;\n    if(l == r) return l * x;\n    if(t[k1].cnt - t[k2].cnt <= x)\n        return t[k1].sum - t[k2].sum;\n    int mid = (l + r) >> 1;\n    int res = t[t[k1].l].cnt - t[t[k2].l].cnt;\n    if(res >= x)\n        return query(t[k1].l, t[k2].l, l, mid, x);\n    return query(t[k1].l, t[k2].l, l, mid, res) + \n        query(t[k1].r, t[k2].r, mid+1, r, x-res);\n}\nvoid solve() {\n    std :: cin >> n >> c >> f;\n    for(int i = 1; i <= c; ++ i)\n        std :: cin >> s[i].a >> s[i].b;\n    std :: sort(s + 1, s + 1 + c);\n\n    for(int i = 1; i <= c; ++ i)\n        modify(rt[i], rt[i-1], 0, Range, s[i].b);\n    // for(int i = 1; i <= c; ++ i) {\n    //     std :: cout << query(rt[i], rt[0], 0, Range, 1) << endl;\n    // }\n    n >>= 1;\n    for(int i = c - n; i >= n + 1; -- i) {\n        i64 sum = query(rt[c], rt[i], 0, Range, n) + \n            query(rt[i-1], rt[0], 0, Range, n) + s[i].b;\n        if(sum > f) continue;\n        std :: cout << s[i].a;\n        return ;\n    }\n    std :: cout << -1;\n}\nsigned main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["主席树"],"categories":["题解","Luogu"]},{"title":"洛谷 P3939 数颜色题解","url":"/post/1580322897.html","content":"<center> 洛谷 P3939 数颜色题解 </center>\n<!--more-->\n\n[原题链接](https://www.luogu.com.cn/problem/P3939)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/Luogu%20P3939.png)\n#### Sample Input\n\n```\n6 5 \n1 2 3 2 3 3  \n1 1 3 2 \n1 4 6 3  \n2 3 \n1 1 3 2  \n1 4 6 3\n```\n\n#### Sample Output\n\n```\n1 \n2 \n2 \n3\n```\n\n#### 解析：\n\n主席树裸题。\n\n查询时，只需要 $r$ 这个版本的颜色总数减去 $l-1$ 这个版本的颜色总数。\n\n修改时，只需要修改一下 $l$ 版本的线段树，减去 $col[l]$ ，加上 $col[l+1]$ 即可。\n\n$l + 1$ 这个版本是不用动的，因为主席树维护的就是前缀和的信息，$col[l]$ 和 $col[l+1]$ 交换不会影响 $l+1$ 版本。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int Range = 3e5;\nconst int N = 3e5 + 20;\nint n, m, col[N], rt[N<<7], tot;\nstruct Node {\n    int l, r, sum;\n}t[N<<7];\nvoid modify(int &k, int bk, int l, int r, int val, int x) {\n    k = ++ tot; t[k] = t[bk]; t[k].sum += x;\n    if(l == r) return ;\n    int mid = (l + r) >> 1;\n    if(val <= mid) modify(t[k].l, t[bk].l, l, mid, val, x);\n    else modify(t[k].r, t[bk].r, mid+1, r, val, x);\n}\nint query(int k1, int k2, int l, int r, int val) {\n    if(l == r) return t[k1].sum - t[k2].sum;\n    int mid = (l + r) >> 1;\n    if(val <= mid) return query(t[k1].l, t[k2].l, l, mid, val);\n    else return query(t[k1].r, t[k2].r, mid+1, r, val);\n}\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> col[i];\n    for(int i = 1; i <= n; ++ i)\n        modify(rt[i], rt[i-1], 1, Range, col[i], 1);\n    for(int i = 1; i <= m; ++ i) {\n        int opt, l, r, c;\n        std :: cin >> opt >> l;\n        if(opt == 1) {\n            std :: cin >> r >> c;\n            std :: cout << query(rt[r], rt[l-1], 1, Range, c) << endl;\n        } else {\n            modify(rt[l], rt[l], 1, Range, col[l], -1);\n            modify(rt[l], rt[l], 1, Range, col[l+1], 1);\n            std :: swap(col[l], col[l+1]);\n        }\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["主席树"],"categories":["题解","Luogu"]},{"title":"CF 1324E - Sleeping Schedule题解","url":"/post/3247311213.html","content":"<center> CF 1324E - Sleeping Schedule题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1324/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201324E.png)\n\n#### Sample Input\n\n```\n7 24 21 23\n16 17 14 20 20 11 22\n```\n\n#### Sample Output\n\n```\n3\n```\n\n#### 解析：\n\n线性 $DP$ 题。\n\n设 $dp[i][j]$ 为第 $i$ 天时刻为 $j$ 时的最大答案。\n\n转移方程为 $f[i][j] = max(f[i-1][j-a[i]],f[i-1][j-a[i]+1]) + (l \\leq j \\And\\And j \\leq r)$\n\n答案即 ​​​$\\max \\limits _{i=0} ^{h-1} {dp[n][i]}$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2023;\nint n, h, l, r, dp[N][N];\nvoid solve() {\n\tstd :: cin >> n >> h >> l >> r;\n\tstd :: vector <int> a(n);\n\tmemset(dp, -0x3f, sizeof dp); dp[0][0] = 0;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> a[i];\n\tfor(int i = 1; i <= n; ++ i)\n\t\tfor(int j = 0; j < h; ++ j)\n\t\t\tdp[i][j] = std :: max(dp[i-1][(j-a[i]+h)%h], dp[i-1][(j-a[i]+1+h)%h]) + (l <= j && j <= r);\n\tint ans = 0;\n\tfor(int i = 0; i < h; ++ i)\n\t\tans = std :: max(ans, dp[n][i]);\n\tstd :: cout << ans;\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["DP","线性dp"],"categories":["题解","CF"]},{"title":"CF 1288C - Two Arrays题解","url":"/post/2333156433.html","content":"<center> CF 1288C - Two Arrays题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1288/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201288C.png)\n#### Sample Input\n\n```\n723 9\n```\n\n#### Sample Output\n\n```\n157557417\n```\n\n#### 解析：\n\n一道线性 $DP$ 题目。\n\n记 $f[0/1][i][j]$ 为不降 $/$ 不减序列在第 $i$ 位上为 $j$ 的方案数。\n\n转移方程为\n\n$$f[0][i][j] = \\sum \\limits _{h=1} ^{j} {f[0][i-1][h]}$$\n\n$$f[1][i][j] = \\sum \\limits _{h=j} ^{n} {f[1][i-1][h]}$$\n\n最后的答案即为 $\\sum \\limits _{i=1} ^{n} \\sum \\limits _{j=i} ^{n} {f[0][n][i] * f[1][n][j]}$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nint n, m;\ni64 f[2][15][N];\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        f[0][1][i] = f[1][1][i] = 1;\n    for(int i = 2; i <= m; ++ i) {\n        i64 res = 0;\n        for(int j = 1; j <= n; ++ j) {\n            res = (res + f[0][i-1][j]) % Mod;\n            f[0][i][j] = res;\n        }\n    }\n    for(int i = 2; i <= m; ++ i) {\n        i64 res = 0;\n        for(int j = n; j >= 1; -- j) {\n            res = (res + f[1][i-1][j]) % Mod;\n            f[1][i][j] = res;\n        }\n    }\n    i64 ans = 0;\n    for(int i = 1; i <= n; ++ i)\n        for(int j = i; j <= n; ++ j)\n            ans = (ans + f[0][m][i] * f[1][m][j] % Mod) % Mod;\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n","tags":["DP","线性dp"],"categories":["题解","CF"]},{"title":"CF 1398D - Colored Rectangles题解","url":"/post/3804056477.html","content":"<center> CF 1398D - Colored Rectangles题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1398/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201398D.png)\n\n#### Sample Input\n\n```\n10 1 1\n11 7 20 15 19 14 2 4 13 14\n8\n11\n```\n\n#### Sample Output\n\n```\n372\n```\n\n#### 解析：\n\n容易发现， $R,G,B$ 不超过 $200$ ，可以使用 $O(RGB)$ 的复杂度通过这个题，可以考虑 $dp$ 。\n\n设 $dp[i][j][k]$ 为 $R,G,B$ 三种颜色分别选择前 $i,j,k$ 个所产生的最大面积。\n\n当每一次选择时就有三种情况：\n\n1. 选择 $R,G$ ， $dp[i][j][k] = dp[i-1][j-1][k] + R[i] \\times G[j]$ 。\n2. 选择 $R, B$ ， $dp[i][j][k] = dp[i-1][j][k-1] + R[i] \\times B[k]$ 。\n3. 选择 $G,B$ ， $dp[i][j][k] = dp[i][j-1][k-1] + G[j] \\times B[k]$ 。\n\n总的方程就是\n\n$$dp[i][j][k] = max(dp[i-1][j-1][k] + R[i] \\times G[j], dp[i-1][j][k-1]) + R[i] \\times B[k], dp[i][j-1][k-1] + G[j] \\times B[k])$$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2020;\nint r, g, b, R[N], G[N], B[N];\ni64 dp[220][220][220];\ni64 dfs(int a, int b, int c) {\n    if(dp[a][b][c]) return dp[a][b][c];\n    if(a && b) dp[a][b][c] = std :: max(dp[a][b][c],\n        dfs(a-1, b-1, c) + R[a] * G[b]);\n    if(a && c) dp[a][b][c] = std :: max(dp[a][b][c],\n        dfs(a-1, b, c-1) + R[a] * B[c]);\n    if(b && c) dp[a][b][c] = std :: max(dp[a][b][c],\n        dfs(a, b-1, c-1) + G[b] * B[c]);\n    return dp[a][b][c];\n}\nvoid solve() {\n    std :: cin >> r >> g >> b;\n    for(int i = 1; i <= r; ++ i)\n        std :: cin >> R[i];\n    for(int i = 1; i <= g; ++ i)\n        std :: cin >> G[i];\n    for(int i = 1; i <= b; ++ i)\n        std :: cin >> B[i];\n    std :: sort(R + 1, R + 1 + r);\n    std :: sort(G + 1, G + 1 + g);\n    std :: sort(B + 1, B + 1 + b);\n    std :: cout << dfs(r, g, b);\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["DP","记忆化搜索"],"categories":["题解","CF"]},{"title":"CF 577B - Modulo Sum题解","url":"/post/708848240.html","content":"<center> CF 577B - Modulo Sum题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/577/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20577B.png)\n#### Sample Input\n\n```\n6 6\n5 5 5 5 5 5\n```\n\n#### Sample Output\n\n```\nYES\n```\n\n#### 解析：\n\n取子序列的和为某一个值，容易联想到 $01$ 背包，但是 $n$ 有 $10^6$ 且 $a_i$ 的范围为 $[0,10^9]$ ，显然是不可行的。\n\n由于子序列的和是 $m$ 的倍数即可，不妨先将 $a_i$ 均模上 $m$ ，这样 $a$ 数组的范围就缩小到了 $10^3$ 级别。\n\n当 $n$ 大于 $m$ 时，我们可以想到，将 $a$ 数组求一个前缀和，那么就会有 $n$ 个前缀和，再加上对 $m$ 取模，相当于将 $n$ 个数对应 $m$ 个数。\n\n我们就会想到抽屉原理，抽屉原理指的是`将n+1个物体，划分为n组，那么有至少一组有两个（或以上）的物体。`\n\n则就是说，一定存在两个前缀和值相等，则该两个数的位置之间的子数组的和为 $m$ 的倍数。\n\n即，当 $n$ 大于 $m$ 时，一定存在子序列的和等于 $m$ 的倍数。\n\n当 $n$ 小于等于 $m$ 时，由于 $n,m \\leq 10^3$，则可以进行 $01$ 背包。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nconst int M = 1e3 + 20;\nint a[N], f[M][M], n, m;\nvoid solve() {\n\tstd :: cin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> a[i], a[i] %= m;\n\tif(n > m) {\n\t\tstd :: cout << \"YES\";\n\t\treturn ;\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tf[i][a[i]] = 1;\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tf[i][j] |= f[i-1][j];\n\t\t\tf[i][(j+a[i])%m] |= f[i-1][j];\n\t\t}\n\t\tif(f[i][0] == 1) {\n\t\t\tstd :: cout << \"YES\";\n\t\t\treturn ;\n\t\t}\n\t}\n\tstd :: cout << \"NO\";\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["前缀和","01背包","抽屉原理"],"categories":["题解","CF"]},{"title":"CF 600E-Lomsat gelral题解","url":"/post/1680840527.html","content":"<center> CF 600E - Lomsat gelral题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/600/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20600E.png)\n\n#### Sample Input\n\n```\n15\n1 2 3 1 2 3 3 1 1 3 2 2 1 2 3\n1 2\n1 3\n1 4\n1 14\n1 15\n2 5\n2 6\n2 7\n3 8\n3 9\n3 10\n4 11\n4 12\n4 13\n```\n\n#### Sample Output\n\n```\n6 5 4 3 2 3 3 1 1 3 2 2 1 2 3\n```\n\n#### 解析：\n\n解析见[树上启发式合并（dsu on tree）小结](https://atmizz.github.io/post/4180854850.html)\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint son[N], head[N], cnt, num[N], col[N], n, sz[N];\ni64 ans[N], sum, maxx;\nstruct Edge {\n\tint to, net;\n}e[N<<1];\nvoid Insert(int u, int v) {\n\te[++cnt] = {v, head[u]};\n\thead[u] = cnt;\n}\nvoid dfsSon(int u, int fa) {\n\tsz[u] = 1;\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa) continue;\n\t\tdfsSon(v, u); sz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\nvoid count(int u, int fa, int pson, int val) {\n\tint c = col[u];\n\tnum[c] += val;\n\tif(num[c] > maxx) maxx = num[c], sum = c;\n\telse if(num[c] == maxx) sum += c;\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == pson) continue;\n\t\tcount(v, u, pson, val);\n\t}\n}\nvoid dfs(int u, int fa, bool keep) {\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == son[u]) continue;\n\t\tdfs(v, u, 0);\n\t}\n\tif(son[u]) dfs(son[u], u, 1);\n\tcount(u, fa, son[u], 1);\n\tans[u] = sum;\n\tif(!keep) {\n\t\tcount(u, fa, 0, -1);\n\t\tsum = maxx = 0;\n\t}\n}\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> col[i];\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint u, v; std :: cin >> u >> v;\n\t\tInsert(u, v); Insert(v, u);\n\t}\n\tdfsSon(1, 1); dfs(1, 1, 1);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cout << ans[i] << ' ';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["树上启发式合并"],"categories":["题解","CF"]},{"title":"树上启发式合并（dsu on tree）小结","url":"/post/3958277707.html","content":"<center> 树上启发式合并（dsu on tree）小结 </center>\n<!--more-->\n\n## 算法介绍\n\n树上启发式合并英文名叫 `dsu on tree` ，其中 $dsu$ 就是并查集的意思，但是这个算法并用不到并查集，应该是受并查集的启发式合并的启发应用到树上的。\n\n其中**启发式合并**的意思就是，两个集合需要合并，将元素少的集合合并到元素多的集合。\n\n树上启发式合并的意思就是，轻子树的贡献并入重子树。\n\n树上启发式合并优点在于，对于某些树上离线问题可以速度大于等于大部分算法且更易于理解和实现的算法。\n\n树上启发式合并合并所能解决的问题有以下特性：\n1. 只有对子树的查询。\n2. 没有修改操作。\n\n由一道题目进行引入，[CF 600E-Lomsat gelral](https://codeforces.com/problemset/problem/600/E)\n\n题目大意：给定一棵树，每个节点上都有一种颜色，从节点 $1$ 到节点 $n$ ，输出以当前节点为根的子树内出现的最多的颜色的编号和。\n\n首先，我们肯定能想到暴力，复杂度是 $O(N^2)$ ，显然是不优秀的。\n\n当然了，我们也能想到可以将树上问题转化为序列问题，然后莫队一下，那样的话，复杂度就来到了 $O(N \\sqrt{N})$ ，但是还不是太优秀。\n\n我们考虑优化暴力，有一种优化策略是这样的：\n\n记**答案**为最终的输出结果，**贡献**为记录各种颜色个数的数组。\n\n对于当前节点来说，\n1. 我们将每个儿子按照树链剖分一样分轻、重儿子，\n2. 优先遍历轻儿子，轻儿子的子树优先计算**答案**，但是不保留轻儿子的子树对当前节点的**贡献**。\n3. 然后遍历重儿子，计算重儿子子树的**答案**，并且保留其对当前节点的**贡献**。\n4. 再次遍历轻儿子，计算轻儿子的子树的**贡献**，与重儿子子树的**贡献**合并为当前节点的**答案**。\n5. 如果当前节点是轻儿子，当前节点的子树的**贡献**。\n\n上述优化策略即为树上启发式合并，时间复杂度为 $O(NlogN)$ ，这是非常优秀的。\n\n简单小证明：对于某一点来说，最坏情况下是一直处在轻链中，一直会被删除，而轻链最多有 $logN$ 个（我道听途说的），即该点最多会被各计算和删除 $logN$ 次，则总体复杂度为 $O(NlogN)$ 。\n\n## 代码详解\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint son[N], head[N], cnt, num[N], col[N], n, sz[N];\ni64 ans[N], sum, maxx;\nstruct Edge {\n\tint to, net;\n}e[N<<1];\nvoid Insert(int u, int v) {\n\te[++cnt] = {v, head[u]};\n\thead[u] = cnt;\n}\nvoid dfsSon(int u, int fa) { // 找出每个节点的轻重儿子\n\tsz[u] = 1;\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa) continue;\n\t\tdfsSon(v, u); sz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v; // 当前儿子节点数多，那就是重儿子\n\t}\n}\nvoid count(int u, int fa, int pson, int val) { \n// pson 指的是dfs函数中当前节点的重儿子，我们只保留重儿子的贡献，而不会保留轻儿子的重儿子的贡献。\n// val 指的是计算/删除贡献。\n\tint c = col[u];\n\tnum[c] += val;\n\tif(num[c] > maxx) maxx = num[c], sum = c;\n\telse if(num[c] == maxx) sum += c;\n\tfor(int i = head[u]; i; i = e[i].net) { // 计算/删除dfs中u的轻子树的贡献\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == pson) continue; // 注意是pson，非son[u]。因为只保留dfs中u的重子树的贡献，而不是每一个轻儿子的重儿子。\n\t\tcount(v, u, pson, val);\n\t}\n}\nvoid dfs(int u, int fa, bool keep) { // keep表示是否为重儿子\n\tfor(int i = head[u]; i; i = e[i].net) { // 优先遍历轻儿子\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == son[u]) continue;\n\t\tdfs(v, u, 0);\n\t}\n\tif(son[u]) dfs(son[u], u, 1); // 最后遍历重儿子\n\tcount(u, fa, son[u], 1); // 计算以 u 为根的子树答案\n\tans[u] = sum; // 离线记录答案\n\tif(!keep) { // 轻儿子要删除其子树的贡献\n\t\tcount(u, fa, 0, -1); // 注意pson为-1，即当前轻儿子的子树全部删除贡献\n\t\tsum = maxx = 0; // 不对下一次答案统计造成影响。\n\t}\n}\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> col[i];\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint u, v; std :: cin >> u >> v;\n\t\tInsert(u, v); Insert(v, u);\n\t}\n\tdfsSon(1, 1);\n\tdfs(1, 1, 1);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cout << ans[i] << ' ';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n- 参考文献\n[C语言网 树上启发式合并](https://www.dotcpp.com/course/1054)\n[AgOHの算法胡扯 树上启发式合并（dsu on tree）](https://www.bilibili.com/video/BV1JE411d7tD?p=1&vd_source=f1b67e1f6e1304f6b7fc4bb2ddcc67ab)\n","tags":["树上启发式合并"],"categories":["笔记","树上操作","树上启发式合并"]},{"title":"CF 86D - Powerful array题解","url":"/post/1166923456.html","content":"<center> CF 86D - Powerful array题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/86/problem/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%2086D.png)\n\n#### Sample Input\n\n```\n3 2\n1 2 1\n1 2\n1 3\n```\n\n#### Sample Output\n\n```\n3\n6\n```\n\n#### 解析：\n\n这个题是普通莫队的模板题。\n\n普通莫队就是离线处理区间问题的算法。\n\n其精髓在于`将询问区间排序，然后把当前询问结果当作下一个询问区间的基础`。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e6 + 20;\nint a[N], cnt[N], n, m, l[N], r[N], block, blk[N];\ni64 ans[N], sum;\nstruct Node {\n    int l, r, id;\n    friend bool operator < (Node a, Node b) {\n        return (blk[a.l] ^ blk[b.l]) ? blk[a.l] < blk[b.l] : (blk[a.l] & 1 ?\n         a.r < b.r : a.r > b.r);\n    }\n}q[N];\nvoid add(int x) {\n    sum -= (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n    cnt[a[x]] ++;\n    sum += (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n}\nvoid del(int x) {\n    sum -= (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n    cnt[a[x]] --;\n    sum += (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n}\nvoid solve() {\n    std :: cin >> n >> m; block = pow(n, 2.0 / 3);\n    for(int i = 1; i <= n; ++ i)\n        blk[i] = (i - 1) / block + 1;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= m; ++ i)\n        std :: cin >> q[i].l >> q[i].r, q[i].id = i;\n    std :: sort(q + 1, q + 1 + m);\n    int l = 0, r = 0;\n    for(int i = 1; i <= m; ++ i) {\n        while(l < q[i].l) del(l ++);\n        while(l > q[i].l) add(-- l);\n        while(r < q[i].r) add(++ r);\n        while(r > q[i].r) del(r --);\n        ans[q[i].id] = sum;\n    }\n    for(int i = 1; i <= m; ++ i)\n        std :: cout << ans[i] << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n","tags":["普通莫队"],"categories":["题解","CF"]},{"title":"CF 372A - Counting Kangaroos is Fun题解","url":"/post/1114312715.html","content":"<center> CF 372A - Counting Kangaroos is Fun题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/372/A)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20372A.png)\n\n#### Sample Input\n\n```\n8\n2\n5\n7\n6\n9\n8\n4\n2\n```\n\n#### Sample Output\n\n```\n5\n```\n\n#### 解析：\n\n二分可以被收纳的袋鼠的数量，答案就是 $n - ans$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5e5 + 20;\nint n, a[N];\nbool check(int x) {\n\tint y = n;\n\tfor(int i = x; i >= 1; -- i)\n\t\tif(a[y] >= 2 * a[i]) y --;\n\t\telse return false;\n\treturn true;\n}\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> a[i];\n\tstd :: sort(a + 1, a + 1 + n);\n\tint l = 0, r = n / 2, ans;\n\twhile(l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\tstd :: cout << n - ans;\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 1437D - Minimal Height Tree题解","url":"/post/512996338.html","content":"<center> CF Constant Palindrome Sum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1437/D)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%201437D.png?raw=true)\n\n#### Sample Input\n\n```\n3\n4\n1 4 3 2\n2\n1 2\n3\n1 2 3\n```\n\n#### Sample Output\n\n```\n3\n1\n1\n```\n\n#### 解析：\n\n按照题意模拟即可，有从小到大的连续的数字就放到一个节点当儿子，遇到大的就退出。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, a[N], dep[N];\nvoid solve() {\n    std :: cin >> n; int k = 2;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    std :: queue <int> q;\n    q.push(a[1]);\n    while(q.size()) {\n        int u = q.front(); q.pop();\n        if(k <= n) {\n            dep[a[k]] = dep[u] + 1;\n            q.push(a[k]);\n            k ++;\n        }\n        for(; k <= n; ++ k) {\n            if(a[k] > a[k-1]) dep[a[k]] = dep[u] + 1, q.push(a[k]);\n            else break;\n        }\n    }\n    std :: cout << dep[a[n]] << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n","tags":["队列"],"categories":["题解","CF"]},{"title":"CF 295B - Greg and Graph题解","url":"/post/1845811931.html","content":"<center> CF 295B - Greg and Graph题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/295/B)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%20295B.png?raw=true)\n\n#### Sample Input\n\n```\n4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n4 1 2 3\n```\n\n#### Sample Output\n\n```\n17 23 404 0\n```\n\n#### 解析：\n\n乍一眼看，感觉是 $Floyd$ 板子，其实确实是。\n\n正着删点跑 $Floyd$ 的复杂度是 $O(n^4)$ ，显然要寄。\n\n我们可以发现，可以正难则反。\n\n一个一个加入点，然后用这个点去松弛其他边，然后记录答案即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\ni64 d[N][N], n, ans[N], arr[N];\nbool vis[N];\nvoid solve() {\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i)\n        for(int j = 1; j <= n; ++ j)\n            std :: cin >> d[i][j];\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> arr[i];\n    for(int h = n; h >= 1; -- h) {\n        int k = arr[h]; vis[k] = 1;\n        for(int i = 1; i <= n; ++ i)\n            for(int j = 1; j <= n; ++ j)\n                d[i][j] = std :: min(d[i][j], d[i][k] + d[k][j]);\n\n        for(int i = 1; i <= n; ++ i)\n            for(int j = 1; j <= n; ++ j)\n                if(vis[i] == 1 && vis[j] == 1)\n                    ans[h] += d[i][j];\n\n    }\n    for(int i = 1; i <= n; ++ i)\n        std :: cout << ans[i] << ' ';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["Floyd"],"categories":["题解","CF"]},{"title":"CF 343B - Alternating Current题解","url":"/post/1380942808.html","content":"<center> CF 343B - Alternating Current题解 </center>\n\n<!--more-->\n\n#### Problem Description\n\nMad scientist Mike has just finished constructing a new device to search for extraterrestrial intelligence! He was in such a hurry to launch it for the first time that he plugged in the power wires without giving it a proper glance and started experimenting right away. After a while Mike observed that the wires ended up entangled and now have to be untangled again.\n\nThe device is powered by two wires \"plus\" and \"minus\". The wires run along the floor from the wall (on the left) to the device (on the right). Both the wall and the device have two contacts in them on the same level, into which the wires are plugged in some order. The wires are considered entangled if there are one or more places where one wire runs above the other one. For example, the picture below has four such places (top view):\n\n![](https://espresso.codeforces.com/d9893064977f0a3ba06c4b18908f20c7ef488731.png)\n\nMike knows the sequence in which the wires run above each other. Mike also noticed that on the left side, the \"plus\" wire is always plugged into the top contact (as seen on the picture). He would like to untangle the wires without unplugging them and without moving the device. Determine if it is possible to do that. A wire can be freely moved and stretched on the floor, but cannot be cut.\n\nTo understand the problem better please read the notes to the test samples.\n\n#### Input\n\nThe single line of the input contains a sequence of characters \"+\" and \"-\" of length $n$ ($1 ≤ n ≤ 100000$). The $i$-th ($1 ≤ i ≤ n$) position of the sequence contains the character \"+\", if on the _i_-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.\n\n#### Output\n\nPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.\n\n#### Sample Input1\n\n```\n-++-\n```\n\n#### Sample Output1\n\n```\nYes\n```\n\n#### Sample Input2\n\n```\n+-\n```\n\n#### Sample Output2\n\n```\nNo\n```\n\n#### 题目大意\n\n[原题链接](https://codeforces.com/problemset/problem/343/B)\n\n给定两个线的上下顺序，问是否能够理顺。\n\n#### 解析\n\n刚看上去没思路，一开始猜首尾相同即可解开电线，然后特判长度为 $1$ 的情况。结果就是 $WA$ 了第 $6$ 个点。\n\n​然后又思索了一下，发现其实很简单。\n\n​简单来说，当你把红线放下面时，必定后续有一个操作是把红线放下面，且中间的操作是可以把线理顺的。\n\n​这样说来的话，就像括号匹配一样，找到一个完美匹配的加减序列。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nchar str[N];\nvoid solve() {\n\tscanf(\"%s\", str);\n\tint n = strlen(str);\n\tstd :: stack <char> s;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tif(s.empty()) s.push(str[i]);\n\t\telse {\n\t\t\tchar temp = s.top();\n\t\t\tif(temp == str[i]) s.pop();\n\t\t\telse s.push(str[i]);\n\t\t}\n\t}\n\tstd :: cout << (s.size() ? \"No\" : \"Yes\");\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n","tags":["solutions","栈"],"categories":["题解","CF"]},{"title":"CF 1396A - Multiples of Length题解","url":"/post/38088069.html","content":"<center> CF 1333C - Eugene and an array题解 </center>\n\n<!--more-->\n\n#### Problem Description\n\nEugene likes working with arrays. And today he needs your help in solving one challenging task.\n\nAn array $c$ is a subarray of an array $b$ if $c$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\nLet's call a nonempty array **good** if for every nonempty subarray of this array, sum of the elements of this subarray is nonzero. For example, array $[-1, 2, -3]$ is **good**, as all arrays $[-1]$, $[-1, 2]$, $[-1, 2, -3]$, $[2]$, $[2, -3]$, $[-3]$ have nonzero sums of elements. However, array $[-1, 2, -1, -3]$ isn't **good**, as his subarray $[-1, 2, -1]$ has sum of elements equal to $0$.\n\nHelp Eugene to calculate the number of nonempty **good** subarrays of a given array $a$.\n\n#### Input \n\nThe first line of the input contains a single integer $n$ ($1 \\le n \\le 2 \\times 10^5$)  — the length of array $a$.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$)  — the elements of $a$.\n\n#### Output\n\nOutput a single integer  — the number of **good** subarrays of $a$.\n\n#### Sample Input\n\n```\n3\n1 2 -3\n```\n\n#### Sample Output\n\n```\n5\n```\n\n#### 题目大意\n\n[原题链接](https://codeforces.com/problemset/problem/1333/C)\n\n这道题要找出所有的**好**区间（其子区间和均不为 $0$ ）。\n\n#### 解析：\n\n​首先肯定能想到 $O(n^2)$ 暴力，但是 $n \\leq 2e5$ ，显然是不能接受的。\n\n​再次读题，我们会发现，我们不需要枚举所有的区间，我们可以只枚举右端点，然后找到使得区间最大，但是区间内无区间和为 $0$ 的左端点，即区间 $[x+1,y]$ ，但是为了求答案方便，此处求 $[x,y]$ ，那么就会对答案贡献 $y-x$ 。\n\n​那么如何找到最小的左端点呢？\n\n​假设当前扫到了 $j$ 这个位置，前方有一个最近的区间和为 $0$ 的区间 $[a, b]$ ，且以 $j$ 为右端点的区间 $[i,j]$ 的区间和为 $0$，那么左端点就应该是 $max(a,i)$。\n\n​我们可以设 $lst$ 为前方最近的区间和为 $0$ 的区间 $[a, b]$ 中的 $a$。\n\n​我们可以讨论一下是否有以 $j$ 为右端点的区间和为 $0$ 的区间 $[i,j]$ 。\n\n​如果有的话，那就更新 $lst$ 和 $i$ 取大值更新 $lst$ 。\n\n​那么此时答案贡献为 $j - lst$ 。\n\n​求区间和不难，利用前缀和和 $map$ 即可。\n\n​同时注意，这个求法只能讨论区间内元素大于 $1$ 的情况，还要考虑单个元素的情况。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, a[N];\ni64 sum[N];\nvoid solve() {\n    int n;\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    std :: map <i64, int> cnt;\n    for(int i = 1; i <= n; ++ i)\n        sum[i] = sum[i-1] + a[i];\n    i64 ans = 0; int lst = 0;\n    cnt[0] = 0;\n    for(int i = 1; i <= n; ++ i) {\n        if(cnt.count(sum[i])) lst = std :: max(lst, cnt[sum[i]] + 1);\n        ans += i - lst;\n        if(lst == i && a[i] != 0) ans ++;\n        cnt[sum[i]] = i;\n    }\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n","tags":["solutions","前缀和","map"],"categories":["题解","CF"]},{"title":"CF 1343D - Constant Palindrome Sum题解","url":"/post/1967339.html","content":"<center> CF 1343D - Constant Palindrome Sum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1343/D)\n\n#### Problem Description\n\nYou are given an array $a$ consisting of $n$ integers (it is guaranteed that $n$ is even, i.e. divisible by $2$). All $a_i$ does not exceed some integer $k$.\n\nYour task is to replace the **minimum** number of elements (replacement is the following operation: choose some index $i$ from $1$ to $n$ and replace $a_i$ with some integer in range $[1; k]$) to satisfy the following conditions:\n\n-   after all replacements, all $a_i$ are positive integers not greater than $k$;\n-   for all $i$ from $1$ to $\\frac{n}{2}$ the following equation is true: $a_i + a_{n - i + 1} = x$, where $x$ should be **the same** for all $\\frac{n}{2}$ pairs of elements.\n\nYou have to answer $t$ independent test cases.\n\n#### Input\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5, 1 \\le k \\le 2 \\cdot 10^5$) — the length of $a$ and the maximum possible value of some $a_i$ correspondingly. It is guratanteed that $n$ is even (i.e. divisible by $2$). The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the $i$\\-th element of $a$.\n\nIt is guaranteed that the sum of $n$ (as well as the sum of $k$) over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$, $\\sum k \\le 2 \\cdot 10^5$).\n\n#### Output\n\nFor each test case, print the answer — the **minimum** number of elements you have to replace in $a$ to satisfy the conditions from the problem statement.\n\n#### Sample Input\n\n```\n4\n4 2\n1 2 1 2\n4 3\n1 2 2 1\n8 7\n6 1 1 7 6 3 4 6\n6 6\n5 2 6 1 3 4\n```\n\n#### Sample Output\n\n```\n0\n1\n4\n2\n```\n\n#### 题目大意：\n\n给出一个长度为 $n$ 的数列 $a_i$​ 和 $k$，其中保证 $1 \\leq a_i \\leq k$。\n\n将 $a$ 中任意一数 $a_i$​ 改成 $[1,k]$ 中的一个数称为一次操作。\n\n问最少经过多少次操作后，$a_i​+a_{n−i+1}$​（$i \\leq \\frac{n}{2}$​）全部相等。\n\n#### 解析：\n\n这道题初看确实没有什么眉目，还是看[一个大佬的题解](https://www.dreamwings.cn/codeforces1343d/5620.html)才会的。\n\n​浏览一遍题目，我们会发现每一个数和修改后的数都是在 $[1, k]$ 范围以内，而且对于一对数，最多修改 $2$ 次，则就会有以下三种情况产生。\n\n  1. 修改 $0$ 次。 $a[i] + a[n-i+1] = x$ ，则在 $[x,x]$ 范围内贡献的修改次数为 $0$ 。\n  2. 修改 $1$ 次。 则对区间 $[min(a[i],a[n-i+1])+1, max(a[i], a[n-i+1]) + k]$ 贡献的修改次数为 $1$ 。\n  3. 修改 $2$ 次。 则对区间 $[2, k \\times 2]$ 贡献的修改次数为 $2$ 。\n\n那我们就从 $2$ 一直扫到 $k \\times 2$ 找到一个值 $x$ ，使得所有数对都等于 $x$ 时修改次数最小。\n\n涉及到区间修改和单点查询，可以使用线段树和差分。我这里使用的差分，写起来更简单一些。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, k, a[N], diff[N<<1];\nvoid solve() {\n    std :: cin >> n >> k;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 2; i <= k << 1; ++ i)\n        diff[i] = 0;\n    int ans = INF;\n    for(int i = 1; i <= n >> 1; ++ i) {\n        int x = std :: min(a[i], a[n-i+1]);\n        int y = std :: max(a[i], a[n-i+1]);\n        // 2 [2, 2k]\n        // 1 [x+1, y+k]\n        // 0 [x+y,x+y]\n        diff[2] += 2; diff[2*k+1] -= 2;\n        diff[x+1] -= 1; diff[y+k+1] += 1;\n        diff[x+y] -= 1; diff[x+y+1] += 1;\n    }\n    for(int i = 2; i <= k << 1; ++ i) {\n        diff[i] += diff[i-1];\n        ans = std :: min(ans, diff[i]);\n    }\n    std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n## ","tags":["solutions","差分","线段树"],"categories":["题解","CF"]},{"title":"CF 1396A - Multiples of Length题解","url":"/post/2782429085.html","content":"<center> CF 1396A - Multiples of Length题解 </center>\n<!--more-->\n\n#### 题目描述\n\nYou are given an array $a$ of $n$ integers.\n\nYou want to make all elements of $a$ equal to zero by doing the following operation exactly three times:\n\n- Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment (added integers can be different).\n\nIt can be proven that it is always possible to make all elements of $a$ equal to zero.\n\n#### 输入格式\n\nThe first line contains one integer $n$ ($1 \\le n \\le 100\\,000$): the number of elements of the array.\n\nThe second line contains $n$ elements of an array $a$ separated by spaces: $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n#### 输出格式\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n- The first line contains two integers $l$, $r$ ($1 \\le l \\le r \\le n$): the bounds of the selected segment.\n\n- The second line contains $r-l+1$ integers $b_l, b_{l+1}, \\dots, b_r$ ($-10^{18} \\le b_i \\le 10^{18}$): the numbers to add to $a_l, a_{l+1}, \\ldots, a_r$, respectively; $b_i$ should be divisible by $r - l + 1$.\n\n#### 题目大意\n\n给你一个由个整数组成的数组。\n\n你想通过以下操作使中的所有元素都等于，操作次数正好为三次：\n\n-   选择一个段，对于这个段中的每个数字，我们可以向其添加的倍数，其中是这个段的长度（添加的整数可以不同）。\n\n可以证明，总是有可能使的所有元素都等于零。\n\n#### 输入样例\n\n```\n4\n1 3 2 4\n```\n\n#### 输出样例\n\n```\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6\n```\n\n#### 解析\n\n我们可以把$n$个数分为$1$和$[2,n]$，第一次操作把第$1$个数操作为$0$，第$2,3$次操作将$[2,n]$变为$0$。\n\n很显然有，$a[i] + (n-1) \\times a[i] = n \\times a[i]$。\n\n那么可以将$[2,n]$都加上一个$(n-1) \\times a[i]$，最后一次操作在$[1,n]$上减去一个$n \\times a[i]$。\n\n注意，$n=1$时要特判。\n\n#### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\n#define int ll\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 20;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN];\nsigned main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = read();\n  if(n == 1) {\n    printf(\"1 1\\n%lld\\n\", a[1]);\n    printf(\"1 1\\n%lld\\n\", a[1]);\n    printf(\"1 1\\n%lld\\n\", -3*a[1]);\n    return 0;\n  }\n  printf(\"1 1\\n%lld\\n\", -a[1]);\n  a[1] = 0;\n  printf(\"2 %lld\\n\", n);\n  for(int i = 2; i <= n; ++ i)\n    printf(\"%lld \", a[i] * (n-1));\n  puts(\"\");\n  printf(\"1 %lld\\n\", n);\n  for(int i = 1; i <= n; ++ i)\n    printf(\"%lld \", -n * a[i]);\n  return 0;\n}\n```","tags":["solutions","构造题"],"categories":["题解","CF"]},{"title":"CF 1353D - Constructing the Array题解","url":"/post/2782429083.html","content":"<center> CF 1353D - Constructing the Array题解 </center>\n<!--more-->\n\n#### 题目描述\n\nYou are given an array $a$ of length $n$ consisting of zeros. You perform $n$ actions with this array: during the $i$th action, the following sequence of operations appears:\n\n1. Choose the maximum by length subarray (continuous subsegment) consisting only of zeros, among all such segments choose the leftmost one;\n2. Let this segment be $[l; r]$. If $r-l+1$ is odd (not divisible by $2$) then assign (set) $a[\\frac{l+r}{2}] := i$ (where $i$ is the number of the current action), otherwise (if $r-l+1$ is even) assign (set) $a[\\frac{l+r-1}{2}] := i$.\n\nConsider the array $a$ of length $5$ (initially $a=[0, 0, 0, 0, 0]$). Then it changes as follows:\n\n1.  Firstly, we choose the segment $[1; 5]$ and assign $a[3] := 1$, so $a$ becomes $[0, 0, 1, 0, 0]$;\n2.  then we choose the segment $[1; 2]$ and assign $a[1] := 2$, so $a$ becomes $[2, 0, 1, 0, 0]$;\n3.  then we choose the segment $[4; 5]$ and assign $a[4] := 3$, so $a $ becomes $[2, 0, 1, 3, 0]$;\n4.  then we choose the segment $[2; 2]$ and assign $a[2] := 4$, so $a$ becomes $[2, 4, 1, 3, 0]$;\n5.  and at last we choose the segment $[5; 5]$ and assign $a[5] := 5$, so $a$ becomes $[2, 4, 1, 3, 5]$.\n\nYour task is to find the array $a$ of length $n$ after performing all $n$ actions. Note that the answer exists and unique.\n\nYou have to answer $t$ independent test cases.\n\n#### 输入格式\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n#### 输出格式\n\nFor each test case, print the answer — the array $a$ of length $n$ after performing $n$ actions described in the problem statement. Note that the answer exists and unique.\n\n#### 题目大意\n\n有​​​​​​$n$个位置，起初每一个位置都是$0$。\n\n然后进行$n$次操作，第$i$次操作为选取最长的只有的子段$[l,r]$，如果：\n\n- $r-l+1$为奇数，$a[\\frac{l+r}{2}]=i$\n    \n- $r-l+1$为偶数，​$a[\\frac{l+r-1}{2}]=i$\n\n#### 输入样例\n\n```\n6\n1\n2\n3\n4\n5\n6\n```\n\n#### 输出样例\n\n```\n1 \n1 2 \n2 1 3 \n3 1 2 4 \n2 4 1 3 5 \n3 4 1 5 2 6 \n```\n\n#### 解析\n\n题目较为清晰。\n可以使用堆来做，存下全是$0$的子段，每次操作选最大字段，然后操作，操作完再把分裂的子段放回堆，重复即可。\n\n#### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint T, n, a[MaxN];\nstruct Node {\n  int l, r;\n  friend bool operator < (Node a, Node b) {\n    return (a.r - a.l + 1) == (b.r - b.l + 1) ? a.l > b.l : (a.r - a.l + 1) < (b.r - b.l + 1);\n  }\n};\nint main() {\n  T = read();\n  while(T --) {\n    n = read(); int k = 0;\n    std :: priority_queue <Node> q;\n    q.push({1, n});\n    while(q.size()) {\n      Node p = q.top(); q.pop();\n      if(p.l == p.r) {\n        a[p.l] = ++k;\n        continue;\n      }\n      int len = p.r - p.l + 1;\n      int x = (len % 2) ? ((p.l + p.r) >> 1) : ((p.l + p.r - 1) >> 1);\n      a[x] = ++k;\n      if(x > p.l) q.push({p.l, x-1});\n      q.push({x+1, p.r});\n    }\n    for(int i = 1; i <= n; ++ i) printf(\"%d \", a[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n```","tags":["solutions","构造题","优先队列","堆"],"categories":["题解","Luogu"]},{"title":"CF 1352G - Special Permutation题解","url":"/post/2274171442.html","content":"<center> CF 1352G - Special Permutation题解 </center>\n<!--more-->\n\n#### 题目描述\n\nA permutation of length $n$ is an array $p=[p_1,p_2,\\dots,p_n]$, which contains every integer from $1$ to $n$ (inclusive) and, moreover, each number appears exactly once. For example, $p=[3,1,4,2,5]$ is a permutation of length $5$.\n\nFor a given number $n$ ($n \\ge 2$), find a permutation $p$ in which absolute difference (that is, the absolute value of difference) of any two neighboring (adjacent) elements is between $2$ and $4$, inclusive. Formally, find such permutation $p$ that $2 \\le |p_i - p_{i+1}| \\le 4$ for each $i$ ($1 \\le i < n$).\n\nPrint any such permutation for the given integer $n$ or determine that it does not exist.\n\n#### 输入格式\n\nThe first line contains an integer $t$ ($1 \\le t \\le 100$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is described by a single line containing an integer $n$ ($2 \\le n \\le 1000$).\n\n#### 输出格式\n\nPrint $t$ lines. Print a permutation that meets the given requirements. If there are several such permutations, then print any of them. If no such permutation exists, print $-1$.\n\n#### 题目大意\n\n有$t$组数据。给定一个数$n$，求$1$ ~ $n$的排列，要求相邻两个数的差的绝对值在$2$ ~ $4$之间。\n\n#### 输入样例\n\n```\n6\n10\n2\n4\n6\n7\n13\n```\n\n#### 输出样例\n\n```\n9 6 10 8 4 7 3 1 5 2 \n-1\n3 1 4 2 \n5 3 6 2 4 1 \n5 1 3 6 2 4 7 \n13 9 7 11 8 4 1 3 5 2 6 10 12 \n```\n\n#### 解析\n\n手玩几个样例，容易发现我们可以把奇数和偶数分别输出。\n比较好写的是，奇数从大到小输出，偶数从小到大输出，再连接部分，输出“4 2”.\n需要注意的是，$n$小于$4$时是不存在答案的。\n\n#### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, T;\nint main() {\n  T = read();\n  while(T --) {\n    n = read(); int x = (n % 2) ? n : (n - 1);\n    if(n <= 3) {\n      std :: cout << \"-1\\n\";\n      continue;\n    }\n    for(int i = x; i >= 1; i -= 2) std :: cout << i << ' ';\n    x = (n % 2) ? (n - 1) : n;\n    std :: cout << \"4 2 \";\n    for(int i = 6; i <= x; i += 2) std :: cout << i << ' ';\n    puts(\"\");\n  }\n  return 0;\n}\n```","tags":["solutions","构造题"],"categories":["题解","CF"]},{"title":"洛谷 P3870 TJOI2009 开关题解","url":"/post/2756585155.html","content":"\n<center> 洛谷 P3870 TJOI2009 开关题解 </center>\n<!--more-->\n\n#### 题目描述\n\n现有$n$盏灯排成一排，从左到右依次编号为：$1,2,…,n$。然后依次执行$m$项操作。\n\n操作分为两种：\n\n1.  指定一个区间$[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）;\n2.  指定一个区间$[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n#### 输入格式\n\n第一行有两个整数$n$和$m$，分别表示灯的数目和操作的数目。\n\n接下来有$m$行，每行有三个整数，依次为：$c、a、b$。其中$c$表示操作的种类。\n\n- 当$c$的值为$0$时，表示是第一种操作。\n- 当$c$的值为$1$时，表示是第二种操作。\n\n$a$和$b$则分别表示了操作区间的左右边界。\n\n#### 输出格式\n\n每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。\n\n#### 输入输出样例\n\n**输入 #1**\n\n```\n4 5\n0 1 2\n0 2 4\n1 2 3\n0 2 4\n1 1 4\n```\n**输出 #1**\n\n```\n1\n2\n```\n\n#### 说明/提示\n\n对于全部的测试点，保证$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 10^5$，$1 \\leq a$,$b \\leq n$，$c \\in \\{0,1\\}$。\n\n#### 解析\n\n这是一道分块题目。\n\n分块复杂度在$O(m \\sqrt{n})$，完全是可以通过的。\n\n每次修改时，除了边缘的灯泡暴力修改，中间块内元素完全可以打标记修改，有一处细节是，`b[i] ^= 1(b[i]：第i个块的修改次数)`即可表示整个块修改的次数。\n\n再设置一个计数数组，累计当前块内打开的灯泡个数。\n\n查询的时候，边缘的仍然暴力，中间块的累计时可以对比`b[i]`来累加`num[i]`，`sum += (b[i] ? block - num[i] : num[i])`。\n\n需要注意的是，每次查询和修改边缘元素时都需要看一下当前块有无标记，若有则下放。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, block, blk[MaxN], a[MaxN], b[MaxN], num[MaxN];\nvoid pushdown(int x) {\n  if(b[blk[x]])\n    for(int i = (blk[x] - 1) * block + 1; i <= blk[x] * block; ++ i)\n      a[i] ^= 1, num[blk[x]] += (a[i] == 1 ? 1 : -1);\n  b[blk[x]] = 0;\n}\nvoid Modify(int l, int r) {\n  pushdown(l);\n  for(int i = l; i <= min(r, blk[l] * block); ++ i)\n    a[i] ^= 1, num[blk[l]] += (a[i] == 1 ? 1 : -1);\n  if(blk[l] != blk[r]) {\n    pushdown(r);\n    for(int i = (blk[r] - 1) * block + 1; i <= r; ++ i)\n      a[i] ^= 1, num[blk[r]] += (a[i] == 1 ? 1 : -1);\n  }\n  for(int i = blk[l] + 1; i <= blk[r] - 1; ++ i)\n    b[i] ^= 1;\n}\nint query(int l, int r) {\n  int sum = 0; pushdown(l);\n  for(int i = l; i <= min(r, blk[l] * block); ++ i)\n    sum += (a[i] == 1);\n  if(blk[l] != blk[r]) {\n    pushdown(r);\n    for(int i = (blk[r] - 1) * block + 1; i <= r; ++ i)\n      sum += (a[i] == 1);\n  }\n  for(int i = blk[l] + 1; i <= blk[r] - 1; ++ i)\n    sum += (b[i] == 0 ? num[i] : (block - num[i]));\n  return sum;\n}\nint main() {\n  n = read(); m = read();\n  block = sqrt(n);\n  for(int i = 1; i <= n; ++ i)\n    blk[i] = (i - 1) / block + 1;\n  for(int i = 1; i <= m; ++ i) {\n    int opt = read(), l = read(), r = read();\n    if(opt == 0) Modify(l, r);\n    else printf(\"%d\\n\", query(l, r));\n  }\n  return 0;\n}\n```","tags":["solutions","分块"],"categories":["题解","Luogu"]},{"title":"HDU-1257 最少拦截系统题解","url":"/post/544537809.html","content":"<center> HDU-1257 最少拦截系统题解 </center>\n<!--more-->\n\n#### Problem Description\n\n某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹. \n\n怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.  \n\n#### Input\n\n输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)  \n\n#### Output\n\n对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.  \n\n#### Sample Input\n\n```\n8 389 207 155 300 299 170 158 65\n```\n\n#### Sample Output\n\n```\n2\n```\n\n#### 解析：\n\n这是一道最长上升子序列的变种题目。\n\n由题意知，只有导弹高度单调递减的时候，才可以使用同一个拦截装置。\n\n那我们就会想什么时候不会使用同一个拦截装置，就是在我们保证前面某一段一直单调递减，然后突然增大，这时候必须再开设一个拦截装置，这显然是求最长上升子序列的问题。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n  s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1010;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN], dp[MaxN], ans;\nint main() {\n  while(scanf(\"%d\", &n) != EOF) {\n    ans = 0;\n    for(int i = 1; i <= n; ++ i) a[i] = read();\n    for(int i = 1; i <= n; ++ i) {\n      dp[i] = 1;\n      for(int j = 1; j < i; ++ j)\n        if(a[i] > a[j]) dp[i] = max(dp[i], dp[j] + 1);\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n```","tags":["DP","solutions","最长上升子序列问题"],"categories":["题解","HDU"]},{"title":"洛谷 P2422 良好的感觉题解","url":"/post/2962024493.html","content":"<center> 洛谷 P2422 良好的感觉题解 </center>\n<!--more-->\n\n#### 题目描述\n\nkkk 做了一个人体感觉分析器。每一天，人都有一个感受值 $A_i$​，$A_i$​ 越大，表示人感觉越舒适。在一段时间 $[i,j]$ 内，人的舒适程度定义为 $[i,j]$ 中最不舒服的那一天的感受值 $[i,j]$中每一天感受值的和。现在给出 kkk 在连续 $N$ 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？\n\n#### 输入格式\n\n第一行为 $N$，代表数据记录的天数。\n\n第二行 $N$ 个整数，代表每一天的感受值。\n\n#### 输出格式\n\n一行，表示在最舒适的一段时间中的感受值。\n\n#### 输入输出样例\n\n**输入 #1**\n\n```\n6\n3 1 6 4 5 2\n```\n**输出 #1**\n\n```\n60\n```\n\n#### 说明/提示\n\nkkk 最开心的一段时间是第 $3$ 天到第 $5$ 天，开心值：$(6+4+5) \\times 4=60$。\n\n对于 $30\\%$ 的数据，$1 \\leq N \\leq 100$。\n\n对于 $70\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000$，$1 \\leq 感受值 \\leq 1000000$。\n\n#### 解析\n\n这是一道单调栈+前缀和题目。\n\n容易想到一个 $O(N^3)$ 的做法，枚举左端点和右端点，再遍历求和和区间最小值，显然会$T$。\n\n容易想到用前缀和优化，但是在这种做法中作用不大。\n\n转换思路，我不枚举左右端点，我枚举最小值，然后求左右端点，最后求和，这个做法可以到达 $O(N^2)$ 的复杂度，还是不行。\n\n我们可以利用单调栈先预处理出每一个点的左右区间端点，然后在枚举最小值，这样就可以达到 $O(N)$ 的复杂度了，完全够用。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline ll read() {\n  ll s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline ll max(ll a, ll b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nll n, a[MaxN], ans, sum[MaxN], L[MaxN], R[MaxN];\nstd :: stack <ll> sL, sR;\nint main() {\n  n = read(); sL.push(0); sR.push(n+1);\n  for(int i = 1; i <= n; ++ i) a[i] = read(), sum[i] = sum[i-1] + a[i];\n  for(int i = 1; i <= n; ++ i) {\n    while(sL.size() && a[sL.top()] >= a[i]) sL.pop();\n    L[i] = sL.top(); \n    sL.push(i);\n  }\n  for(int i = n; i >= 1; -- i) {\n    while(sR.size() && a[sR.top()] >= a[i]) sR.pop();\n    R[i] = sR.top() - 1;\n    sR.push(i);\n  }\n  for(int i = 1; i <= n; ++ i) ans = max(ans, (sum[R[i]] - sum[L[i]]) * a[i]);\n  printf(\"%lld\", ans);\n  return 0;\n}\n```","tags":["solutions","前缀和","单调栈"],"categories":["题解","Luogu"]},{"title":"洛谷 P2629 好消息，坏消息题解","url":"/post/3957807158.html","content":"\n<center> 洛谷 P2629 好消息，坏消息题解 </center>\n<!--more-->\n\n#### 题目描述\n\nUim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,…,n,1,2,…,k−1$（事件编号）这种顺序通报。\n\n他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k−1$ 号事件可以让老板不发怒。\n\n#### 输入格式\n\n第一行一个整数 $n$（$1 \\leq n \\leq 10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$​（$−10^3≤Ai​≤10^3$）。\n\n#### 输出格式\n\n一行一个整数，表示可行的方案个数。\n\n#### 输入输出样例\n\n**输入 #1**\n```\n4\n-3 5 1 2\n```\n**输出 #1**\n```\n2\n```\n#### 说明/提示\n\n**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1$ 或 $3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5 \\rightarrow 1 \\rightarrow 2 \\rightarrow(−3)$ 或 $1 \\rightarrow 2 \\rightarrow (−3) \\rightarrow 5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n \\leq 103$；  \n对于 $75\\%$ 的数据，$n \\leq 104$；  \n对于 $100\\%$ 的数据，$1 \\leq n \\leq 106$。\n\n#### 解析\n\n这是一道单调队列 + 前缀和题目。\n\n由题意可知，消息可以围成一个环形，可以从任意一点出发，累加完 $n$ 个消息，只要在累加过程中累加和不小于 $0$ 即可。\n\n可是用上方做法会 $T$ 掉，所以我们考虑用单调队列维护累加和的最小值。\n\n这道题目类似于滑动窗口，这里是维护 $n$ 个值的最小值，并且窗口不断向后移。\n\n首先开两倍数组存下消息，然后再用前缀和预处理。\n\n我们肯定要枚举 $n$ 个起点，所以不妨从 $1$ 开始枚举，我们可以先把前 $n$ 个前缀和加入单调队列，维护这 $n$ 个数的最小值，然后枚举点不断后移，继续维护从起始点开始的 $n$ 个数的最小值。\n\n只要这个最小值减去起点前一个点的前缀和，那么答案就加一。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN << 1], ans, sum[MaxN << 1];\nint main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = a[i+n] = read();\n  for(int i = 1; i <= n << 1; ++ i) sum[i] = sum[i-1] + a[i];\n  std :: deque <int> q;\n  for(int i = 1; i <= n; ++ i) {\n    while(q.size() && sum[q.back()] >= sum[i]) q.pop_back();\n    q.push_back(i);\n  }\n  for(int i = 1 + n; i <= (n << 1); ++ i) {\n    while(q.size() && sum[q.back()] >= sum[i]) q.pop_back();\n    q.push_back(i);\n    while(q.front() <= i - n) q.pop_front();\n    if(sum[q.front()] - sum[i-n] >= 0) ans ++;\n  } printf(\"%d\", ans);\n  return 0;\n}\n```","tags":["solutions","前缀和","单调队列"],"categories":["题解","Luogu"]},{"title":"AcWing 272. 最长公共上升子序列题解","url":"/post/4176092964.html","content":"\n<center> AcWing 272. 最长公共上升子序列题解 </center>\n<!--more-->\n\n#### 题目描述\n\n熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\n\n小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\n\n小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的\n就是最长公共上升子序列了。\n\n奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\n\n不过，只要告诉奶牛它的长度就可以了。\n\n数列 $A$ 和 $B$ 的长度均不超过 $3000$。\n\n#### 输入格式\n\n第一行包含一个整数 $N$，表示数列 $A$，$B$ 的长度。\n\n第二行包含 $N$ 个整数，表示数列 $A$。\n\n第三行包含 $N$ 个整数，表示数列 $B$。\n\n#### 输出格式\n\n输出一个整数，表示最长公共上升子序列的长度。\n\n#### 数据范围\n\n$1 \\leq N \\leq 3000$,序列中的数字均不超过 $2^{31}−1$。\n\n#### 输入样例：\n\n```\n4\n2 2 1 3\n2 1 2 3\n```\n\n#### 输出样例：\n\n```\n2\n```\n\n#### 解析：\n\n这是一道线性$dp$的题目。\n\n我们表示状态$f[i,j]$为$A_1$~$A_i$和$B_1$~$B_j$构成的以$B_j$为结尾的最长公共上升子序列的长度。\n\n考虑状态转移，因为是$B_j$结尾，所以先枚举数列$A$，再枚举数列$B$。\n\n枚举到$A_i$和$B_j$时，考虑$A_i$是否等于$B_j$。\n1. 当$A_i \\neq B_j$时，$f[i,j] = f[i-1,j]$\n2. 当$A_i = B_j$时，$f[i,j] = \\max_{0 \\leq k < j, B_k < B_j} \\{f[i-1,k]\\} + 1$\n\n主要代码如下\n\n```cpp\nfor(int i = 1; i <= n; ++ i)\n    for(int j = 1; j <= n; ++ j) {\n      f[i][j] = f[i-1][j];\n      if(a[i] == b[j]) {\n        int maxv = 1;\n        for(int k = 1; k < j; ++ k)\n          if(b[k] < b[j]) maxv = max(maxv, f[i-1][k] + 1);\n        f[i][j] = max(f[i][j], maxv);\n      }\n    }\n```\n\n显然，上述做法复杂度达到了$O(n^3)$，而$N \\leq 3000$，显然是不可以过掉的。\n\n当枚举到$B_j$时，我们都会把$k$从$1$到$j-1$给枚举一遍，当枚举到$B_{j+1}$的时候，再把$k$从$1$到$j$枚举一遍，会发现有很多重复运算。\n\n观察上式，因为当$A_i=B_j$，$f[i,j] = \\max_{0 \\leq k < j, B_k < B_j} \\{f[i-1,k]\\} + 1$可以转换为$f[i,j] = \\max_{0 \\leq k < j, B_k < A_i} \\{f[i-1,k]\\} + 1$。\n\n也就是说，当枚举到$i$时，数列$B$中小于$A_i$的数是固定的，当枚举$j$的时候，设$maxv=\\max_{1 \\leq k < j-1}{f[i-1,k]}$，但是这个$maxv$可以在枚举$j$的时候更新，不需要$k$。\n\n如果 $B_j<A_i$，我们就更新最大的$f[i-1,j]$保存到变量$maxv$中；如果$B_j=A_i$，我们就用保存的$maxv$去更新$f[i,j]$。\n\n这样复杂度就来到了$O(n^2)$级别。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 3050;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint a[MaxN], b[MaxN], n, f[MaxN][MaxN], ans = 0;\nint main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = read();\n  for(int i = 1; i <= n; ++ i) b[i] = read();\n  for(int i = 1; i <= n; ++ i) {\n    int maxv = 1;\n    for(int j = 1; j <= n; ++ j) {\n      f[i][j] = f[i-1][j];\n      if(a[i] == b[j]) f[i][j] = max(f[i][j], maxv);\n      if(b[j] < a[i]) maxv = max(maxv, f[i-1][j] + 1);\n    }\n  }\n  for(int i = 1; i <= n; ++ i) ans = max(ans, f[n][i]);\n  printf(\"%d\", ans);\n  return 0;\n}\n```","tags":["线性dp","solutions","dp"],"categories":["题解","AcWing"]},{"title":"AcWing杯 第91场周赛","url":"/post/3045974881.html","content":"\n<center> AcWing杯 第91场周赛 </center>\n<!--more-->\n\n### 本次周赛做题情况\n\n$AC \\quad 2T / 3T$\n\n### 题目分析\n\n#### A AcWing 4861. 构造数列\n\n[原题链接](https://www.acwing.com/problem/content/4864/)\n\n这题目挺简单的，把每一个数位的数除了$0$都取出来，然后乘以$10$的该数位的次方。\n\n比如说，$9876 = 9 \\times 10^3 + 8 \\times 10^2 + 7 \\times 10^1 + 6 \\times 10^0 = 9000 + 800 + 70 + 6$。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 0;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[6];\nint main() {\n  n = read(); a[0] = 1;\n  for(int i = 1; i <= 7; ++ i) a[i] = a[i-1] * 10;\n  while(n --) {\n    int x = read(), cnt = 0;\n    std :: vector < int > ans;\n    ans.clear();\n    while(x) {\n      ans.push_back(x % 10);\n      x /= 10; cnt ++;\n    }\n    for(int i = 0; i < ans.size(); ++ i) {\n      ans[i] *= a[i];\n      if(ans[i] == 0) cnt --;\n    }\n    printf(\"%d\\n\", cnt);\n    for(int i = 0; i < ans.size(); ++ i)\n      if(ans[i] != 0) printf(\"%d \", ans[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n```\n\n#### B AcWing 4862. 浇花\n\n[原题链接](https://www.acwing.com/problem/content/4865/)\n\n这个题目是非常明显的差分题目。\n\n输入的每一段就要加上一个定值$1$，所以可以用差分。\n\n差分完求出最终序列，如果有$0$或者大于$1$的则不合题意。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 10;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, ans[MaxN];\nint main() {\n  n = read(); m = read();\n  for(int i = 1; i <= m; ++ i) {\n    int l = read(), r = read();\n    ans[l] += 1; ans[r+1] -= 1;\n  }\n  for(int i = 1; i <= n; ++ i) ans[i] += ans[i-1];\n  for(int i = 1; i <= n; ++ i)\n    if(ans[i] == 0 || ans[i] > 1) {\n      printf(\"%d %d\", i, ans[i]);\n      return 0;\n    }\n  printf(\"OK\");\n  return 0;\n}\n```\n\n#### C AcWing 4863. 构造新矩阵\n\n[原题链接](https://www.acwing.com/problem/content/4866/)\n\n此题目显然用二分做的，但是我在$check$函数这一步卡住了，到头来也没处理好，还是要多动脑，多练啊。\n\n首先我们二分出一个$mid$，然后$check$它。如果是选$n$行的话，我们只需要保证每一列都至少有一个数大于等于我们的$mid$即可。\n\n而题目要求的是$n-1$，那我们只需要保证在最多$n-1$行下有$n$列中的数字大于等于$mid$即可，这就意味着有至少一行是由两个数字大于等于$mid$。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 10;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint T, n, m;\nstd :: vector <int> g[MaxN];\nbool vis[MaxN];\nbool check(int k) {\n  bool ans = false;\n  for(int i = 0; i < m; ++ i) vis[i] = false;\n  for(int i = 0; i < n; ++ i) {\n    bool flag = 1;\n    for(int j = 0; j < m; ++ j)\n      if(g[j][i] >= k) {\n        flag = 0;\n        if(vis[j]) ans = true;\n        vis[j] = true;\n      }\n    if(flag) return false;\n  } return ans;\n}\nint main() {\n  T = read();\n  while(T --) {\n    m = read(); n = read();\n    for(int i = 0; i < m; ++ i) {\n      g[i].resize(n);\n      for(int j = 0; j < n; ++ j)\n        g[i][j] = read();\n    }\n    int l = 1, r = 1e9, mid;\n    while(l < r) {  \n      mid = (l + r + 1) >> 1;\n      if(check(mid)) l = mid;\n      else r = mid - 1;\n    } printf(\"%d\\n\", r);\n  }\n  return 0;\n}\n```","tags":["summaries"],"categories":["套题报告","AcWing周赛"]},{"title":"洛谷 P2704 [NOI2001]炮兵阵地题解","url":"/post/3333748711.html","content":"\n<center> 洛谷 P2704 [NOI2001]炮兵阵地题解 </center>\n<!--more-->\n\n#### 题目描述\n\n司令部的将军们打算在 $N$ * $M$ 的网格地图上部署他们的炮兵部队。一个$N$ * $M$的地图由N行M列组成，地图的每一格可能是山地（用$“H”$ 表示），也可能是平原（用$“P”$表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/Luogu_P2704.jpg?raw=true)\n\n如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。\n\n#### 输入格式\n\n第一行包含两个由空格分割开的正整数，分别表示$N$和$M$；\n\n接下来的$N$行，每一行含有连续的$M$个字符（$‘P’$或者$‘H’$），中间没有空格。按顺序表示地图中每一行的数据。$N≤100；M≤10$。\n\n#### 输出格式\n仅一行，包含一个整数$K$，表示最多能摆放的炮兵部队的数量。\n\n#### 输入样例\n\n```\n5 4\nPHPP\nPPHH\nPPPP\nPHPP\nPHHP\n```\n\n#### 输出样例\n\n```\n6\n```\n\n#### 解析：\n\n$状压DP$\n\n$dfs$求出状态和状态数\n\n设$N[i][j]$表示第i行第j个状态所用的炮兵数量 \n\n设一个转移状态$dp[i][j][k]$是当前的炮兵数\n\n$i$表示第$i$行，$j$表示第$i$行第$j$个状态，$k$表示第$i-1$行第$k$个状态\n\n方程也特别简单\n\n$dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + N[i][j]);$\n\n然后枚举出第$n$行的所有状态和第$n-1$行的所有状态，取一个$max$\n\n但是会遇到一个问题，就是数组会开的很大，这时通过$dfs$发现\n\n当全都是$P$时，也只有$60$种状态，所以可以减小数组.\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#define re register\ninline int read() {\n\tint s = 0, f = ' '; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if(ch == '-') f = '-'; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = (s << 3) + (s << 1) + ch - '0', ch = getchar();\n\treturn f == '-' ? -s : s;\n}\ninline int max(int a, int b) { return a > b ? a : b;}\nconst int Max = 12;\nconst int MAX = 102;\nconst int INF = 0x7fffffff;\nint n, m, dp[MAX][65][65];\nint st[MAX][65], sum[MAX], N[MAX][65];\nchar ch[MAX][Max];\nvoid dfs(int x, int Sum, int j, int p) {\n\tif(j > m) {\n\t\tst[x][++sum[x]] = Sum; N[x][sum[x]] = p;\n\t\treturn ;\n\t}\n\tdfs(x, Sum, j + 1, p);\n\tif(ch[x][j] == 'P') dfs(x, Sum + (1 << j), j + 3, p + 1);\n}\nint main() {\n\tn = read(); m = read();\n\tfor(re int i = 1; i <= n; ++ i)\n\t\tscanf(\"%s\", ch[i] + 1);\n\tfor(re int i = 1; i <= n; ++ i) dfs(i,0,0,0);\n\tfor(re int i = 1; i <= n; ++ i)\n\t\tfor(re int j = 1; j <= sum[i]; ++ j)\n\t\t\tdp[i][j][0] = N[i][j];\n\tfor(re int i = 1; i <= sum[2]; ++ i)\n\t\tfor(re int j = 1; j <= sum[1]; ++ j) {\n\t\t\tif(st[2][i] & st[1][j]) continue;\n\t\t\tdp[2][i][j] = max(dp[2][i][j], dp[1][j][0] + N[2][i]);\n\t\t}\n\tfor(re int i = 3; i <= n; ++ i) \n\t\tfor(re int j = 1; j <= sum[i]; ++ j)\n\t\t\tfor(re int k = 1; k <= sum[i-1]; ++ k) \n\t\t\t\tfor(re int l = 1; l <= sum[i-2]; ++ l) { \n\t\t\t\t\tif(st[i][j] & st[i-1][k]) continue; \n\t\t\t\t\tif(st[i][j] & st[i-2][l]) continue;\n\t\t\t\t\tif(st[i-1][k] & st[i-2][l]) continue;\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + N[i][j]); \n\t\t\t\t}\n\tint ans = -INF;\n\tfor(re int i = 1; i <= sum[n]; ++ i)\n\t\tfor(re int j = 1; j <= sum[n-1]; ++ j)\n\t\t\tans = max(ans, dp[n][i][j]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n```","tags":["DP","solutions"],"categories":["题解","Luogu"]},{"title":"洛谷 P3258 [JLOI2014]松鼠的新家题解","url":"/post/1581331821.html","content":"\n<center> 洛谷 P3258 [JLOI2014]松鼠的新家题解 </center>\n<!--more-->\n\n#### 题目描述\n\n松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在”树“上。\n\n松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，......，最后到$a_n$，去参观新家。可是这样会导致维尼重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。\n\n维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。\n\n因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。\n\n#### 输入格式\n\n第一行一个整数$n$，表示房间个数第二行$n$个整数，依次描述$a_1-a_n$\n\n接下来$n-1$行，每行两个整数$x$，$y$，表示标号$x$和$y$的两个房间之间有树枝相连。\n\n#### 输出格式\n\n一共$n$行，第$i$行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。\n\n#### 输入样例\n\n```\n5\n1 4 5 3 2\n1 2\n2 4\n2 3\n4 5\n```\n\n#### 输出样例\n\n```\n1\n2\n1\n2\n1\n```\n\n#### 说明/提示\n\n$2<= n <=300000$\n\n#### 解析：\n\n$LCA + 树上差分$\n\n对于访问序号我们将其变成边的形式。\n\n对于所有的的边，\n\n我们会发现第一条和最后一条是特殊的。\n\n1. 第一条是两个端点都是包含的， 即在两个端点上都放糖果：[u,v]\n\n2. 最后一条是两个端点都不包含， 即在两个端点上不放糖果：(u,v)\n\n3. 其余的路径都是一样的，前一个包含，后一个不包含：[u,v)\n\nf数组是倍增lca数组，u和v分别是一边的端点。\n\n1. 先看第一条边，直接进行树上差分，无特殊处理。\n\n2. 最后一条边，我们要进行讨论，一共有3种情况：\n\n    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-f[v][0].\n    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-f[v][0].\n    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-son[v].\n3. 其余的边，也是讨论3种情况：\n    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-v.\n    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-v.\n    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-v\n\n做完这些，就是树上差分的板子了，这里就不赘述了。\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#define re register\n#define gc getchar\ninline int read() {\n\tint s = 0, f = 1; char ch = gc();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = gc();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = gc();\n\treturn s * f;\n}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int INF = 0x7fffffff;\nconst int Max = 600012;\nconst int mod = 19260817;\nconst int N = 1000007;\nstruct Candy {\n\tint net, to;\n}t[Max];\nint n, head[Max], cnt, f[Max][21];\nint x[Max], y[Max], k[Max], deep[Max];\ninline void insert(int u, int v) {\n\tt[++cnt].to = v;\n\tt[cnt].net = head[u];\n\thead[u] = cnt;\n}\nvoid dfs(int x, int Fa) {\n\tf[x][0] = Fa; deep[x] = deep[Fa] + 1;\n\tfor(int i = 1; (1 << i) <= deep[x]; i++)\n\t\tf[x][i] = f[f[x][i-1]][i-1];\n\tint v;\n\tfor(re int i = head[x]; i; i = t[i].net) {\n\t\tv = t[i].to;\n\t\tif(v == Fa) continue;\n\t\tdfs(v,x);\n\t}\n}\nint lca(int x, int y) {\n\tif(deep[x] < deep[y]) std :: swap(x, y);\n\tfor(re int i = 21; i >= 0; -- i)\n\t\tif(deep[x] - (1 << i) >= deep[y])\n\t\t\tx = f[x][i];\n\tif(x == y) return x;\n\tfor(re int i = 20; i >= 0; -- i)\n\t\tif(f[x][i] == f[y][i]) continue;\n\t\telse x = f[x][i], y = f[y][i];\n\treturn f[x][0];\n}\nvoid SUM(int x, int Fa) {\n\tint v;\n\tfor(re int i = head[x]; i; i = t[i].net) {\n\t\tv = t[i].to; if(v == Fa) continue;\n\t\tSUM(v, x); k[x] += k[v];\n\t}\n}\nint find_son(int x, int LCA) {\n\tint depth = deep[LCA] + 1;\n\tfor(re int i = 21; i >= 0; -- i)\n\t\tif(deep[x] - (1 << i) >= depth)\n\t\t\tx = f[x][i];\n\treturn x;\n}\nint main() {\n\tn = read(); int u, v; x[1] = read();\n\tfor(re int i = 1; i < n; ++ i) y[i] = read(), x[i+1] = y[i];\n\tfor(re int i = 1; i < n; ++ i)\n\t\tu = read(), v = read(), insert(u,v), insert(v,u);\n\tdfs(1,0);\n\tint LCA = lca(x[n-1], y[n-1]); bool fg = 1;\n\tif(x[n-1] != LCA && y[n-1] != LCA)\n\t\tu = f[x[n-1]][0], v = f[y[n-1]][0];\n\telse if(x[n-1] == LCA && y[n-1] != LCA) {\n\t\tu = find_son(y[n-1], LCA), v = f[y[n-1]][0];\n\t\tif(f[y[n-1]][0] == x[n-1]) fg = 0;\n\t}\n\telse if(x[n-1] != LCA && y[n-1] == LCA) {\n\t\tu = f[x[n-1]][0], v = find_son(x[n-1], LCA);\n\t\tif(f[x[n-1]][0] == y[n-1]) fg = 0;\n\t}\n\tLCA = lca(u, v);\n\tif(fg) k[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\tu = x[1]; v = y[1]; LCA = lca(u, v);\n\tk[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\tfor(re int i = 2; i < n - 1; ++ i) {\n\t\tLCA = lca(x[i], y[i]);\n\t\tif(x[i] != LCA && y[i] != LCA)\n\t\t\tu = f[x[i]][0], v = y[i];\n\t\telse if(x[i] == LCA && y[i] != LCA)\n\t\t\tu = find_son(y[i], LCA), v = y[i];\n\t\telse if(x[i] != LCA && y[i] == LCA)\n\t\t\tu = f[x[i]][0], v = y[i];\n\t\tLCA = lca(u,v);\n\t\tk[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\t}\n\tSUM(1,0);\n\tfor(re int i = 1; i <= n; ++ i) printf(\"%d\\n\",k[i]);\n\treturn 0;\n}\n```","tags":["solutions","LCA"],"categories":["题解","Luogu"]}]