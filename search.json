[{"title":"Codeforces Round 933 (Div. 3)","url":"/post/744274538.html","content":"\n<center> Codeforces Round 933 (Div. 3) </center>\n\n<!--more-->\n\n## 本次做题情况\n\n做 $5 \\ T \\ / \\ 7 \\ T$ ;\n补 $2 \\ T$ ;\n\n## 题目解析\n\n### [1941A - Rudolf and the Ticket](https://codeforces.com/problemset/problem/1941/A)\n\n$n$ 和 $m$ 很小，暴力计算即可。\n\n$O(NM)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nint a[N], b[N], n, m, k;\nvoid solve() {\n\tstd :: cin >> n >> m >> k;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tstd :: cin >> a[i];\n\t}\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tstd :: cin >> b[i];\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tans += (a[i] + b[j] <= k);\n\t\t}\n\t}\n\tstd :: cout << ans << '\\n';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [1941B - Rudolf and 121](https://codeforces.com/problemset/problem/1941/B)\n\n先假设可以将数组归零。\n\n由于原题公式较为别扭，改成：\n$$\n\\begin{align}\na_i \\leftarrow a_i - 1\\\\\\\\\na_{i+1} \\leftarrow a_{i+1} - 2\\\\\\\\\na_{i+2} \\leftarrow a_{i+2} - 1\n\\end{align}\n$$\n\n\n则我们从第一个非零的数开始减，第一个数减 $1$ ，第二个数减 $2$ ，第三个数减 $1$ 。\n\n遇到非零的数就这样操作。\n\n如果遇到负数，则就不能归零。\n\n如果最后两个数不是 $0$ ，则就不能归零。\n\n$O(N)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint a[N];\nvoid solve() {\n\tint n;\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tstd :: cin >> a[i];\n\t}\n\tint pos = 1;\n\twhile(a[pos] == 0) {\n\t\tpos ++;\n\t}\n\twhile(pos <= n) {\n\t\tif(a[pos] < 0 || (a[pos] > 0 && pos >= n - 1)) {\n\t\t\tstd :: cout << \"NO\\n\";\n\t\t\treturn ;\n\t\t}\n\t\ta[pos+1] -= 2 * a[pos];\n\t\ta[pos+2] -= a[pos];\n\t\ta[pos] = 0;\n\t\tpos ++;\n\t}\n\tstd :: cout << \"YES\\n\";\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [1941C - Rudolf and the Ugly String](https://codeforces.com/problemset/problem/1941/C)\n\n观察两个单词 $map$ 和 $pie$ ，容易发现删除中间的字母，答案是最少的（反例：$mmapp$，只有删除 $a$ 才是最优的）。\n\n所以就是数 $map$ 和 $pie$ 的个数。\n\n但是要注意可能会有单词 $mapie$ ，这个可能会被重复算（如果你的循环找到 $map$ 和 $pie$ 就 $i += 3$ 就不会重复算），所以这个优先级最高，有 $mapie$ 先计算 $mapie$ ，没有再计算 $map$ 和 $pie$ 。\n\n我的方法是遇到 $mapie$ 就省略它，因为后面会有 $pie$ 匹配上 。\n\n$O(N)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n\tint n;\n\tstd :: cin >> n;\n\tstd :: string s;\n\tstd :: cin >> s;\n\tstd :: string a = \"map\", b = \"pie\", c = \"mapie\";\n\tint ans = 0;\n\tfor(int i = 0; i < n - 2; ++ i) {\n\t\tint cnt = 0;\n\t\tif(i < n - 4) {\n\t\t\tfor(int j = 0; j < 5; ++ j) {\n\t\t\t\tif(s[i+j] != c[j]) {\n\t\t\t\t\tcnt ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tfor(int j = 0; j < 3; ++ j) {\n\t\t\tif(s[i+j] != a[j]) {\n\t\t\t\tcnt ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; ++ j) {\n\t\t\tif(s[i+j] != b[j]) {\n\t\t\t\tcnt ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += (cnt < 2);\n\t}\n\tstd :: cout << ans << '\\n';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [1941D - Rudolf and the Ball Game](https://codeforces.com/problemset/problem/1941/D)\n\n$dp$ 题目。\n\n设 $dp[i][j]$ 为 $i$ 号玩家在 $j$ 轮是否有球拿。\n\n递推方程为：\n$$\ndp[i][j] |= dp[k][j-1] （其中k会传球给i）\n$$\n最后看第 $m$ 轮谁可能会拿到球即可。\n\n$O(NM)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nint dp[N][N], n, m, x, a[N];\nchar ch[N];\nint calc(int x, int y) {\n\tx = (x + n + y);\n\tx %= n;\n\treturn x == 0 ? n : x;\n}\nvoid solve() {\n\tstd :: cin >> n >> m >> x;\n\tfor(int i = 0; i <= n; ++ i) {\n\t\tfor(int j = 0; j <= m; ++ j) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tstd :: cin >> a[i] >> ch[i];\n\t}\n\tdp[x][0] = 0;\n\tfor(int j = 1; j <= m; ++ j) {\n\t\tfor(int i = 1; i <= n; ++ i) {\n\t\t\tif(dp[i][j-1] == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ch[j] != '1') {\n\t\t\t\tdp[calc(i, a[j])][j] = 1;\n\t\t\t}\n\t\t\tif(ch[j] != '0') {\n\t\t\t\tdp[calc(i, -a[j])][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tstd :: set <int> ans;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tif(dp[i][m] == 1) {\n\t\t\tans.insert(i);\n\t\t}\n\t}\n\tstd :: cout << ans.size() << '\\n';\n\tfor(auto x : ans) {\n\t\tstd :: cout << x << ' ';\n\t}\n\tstd :: cout << '\\n';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [1941E - Rudolf and k Bridges](https://codeforces.com/problemset/problem/1941/E)\n\n每一行都是独立的，所以每一行单独计算花费，最后找连续 $k$ 行花费最小的结果即可。\n\n对于每一行计算最小花费，使用优先队列优化 $dp$ ，我是双端队列模拟的，差不多。\n\n设 $dp[i]$ 为在 $i$ 位置修桥梁的最小花费。\n\n转移方程为：\n$$\ndp[i] = depth + \\max_{j=i-d-1}^{i-1}dp[j]\n$$\n对于连续 $k$ 行最小和，使用前缀和取 $min$ 即可。\n\n$ONM)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst i64 Range = 1e18;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 110;\nconst int M = 1e5 + 20;\nstruct Node {\n\tint pos;\n\ti64 val;\n};\nint n, m, k, d;\ni64 cost[N];\nvoid solve() {\n\tstd :: cin >> n >> m >> k >> d;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tstd :: deque <Node> q;\n\t\tq.push_back({0, 0});\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\ti64 x;\n\t\t\tstd :: cin >> x;\n\t\t\twhile(q.size() && q.front().pos < j - d - 1) q.pop_front();\n\t\t\twhile(q.size() && q.back().val >= x + q.front().val + 1) q.pop_back();\n\t\t\tif(j == m) {\n\t\t\t\tcost[i] = q.front().val + 1;\n\t\t\t}\n\t\t\tq.push_back({j, q.front().val + x + 1});\n\t\t\tif(j == 1) {\n\t\t\t\tq.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tcost[i] += cost[i-1];\n\t}\n\ti64 ans = Range;\n\tfor(int i = k; i <= n; ++ i) {\n\t\tans = std :: min(ans, cost[i] - cost[i-k]);\n\t}\n\tstd :: cout << ans << '\\n';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [1941F - Rudolf and Imbalance 补](https://codeforces.com/problemset/problem/1941/F)\n\n首先，我们可以通过贪心确定我们要分割的差值（差值指 $a_i-a_{i-1}$）就是最大的差值。\n\n很简单，如果我们分割的不是最大差值，那么最后答案一定是最大差值，所以分割最大差值才能使答案变小。\n\n设最大差值为 $a_p - a_{p-1}$ ，则最优的 $d_i + f_j$ 一定在区间 $[a_{p-1},a_p]$ 。\n\n但是两个变量肯定不能同时枚举。\n\n考虑枚举其中一个，比如枚举 $d_i$ ，那么 $f_j$ 的范围确定在 $[a_{p-1}-d_i,a_p-d_i]$ 。\n\n再贪心地去想，最优的 $d_i + f_j$ 一定是平分 $[a_{p-1},a_p]$ ，也就是说，$f_j$ 一定是平分 $[a_{p-1}-d_i,a_p-d_i]$ 。\n\n所以可以对 $f$ 数组二分第一个大于等于中值 $a_{p-1} + a_p - 2 \\times d_i$ 的下标 $pos$ ，答案一定在下标 $pos-1,pos,pos+1$ 中取 $min$。\n\n最后别忘记和第二大差值比较，取 $max$ 即可。\n\n$O(MlogK)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\n#define int long long\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 2e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, m, k, a[N], d[N], f[N];\nvoid solve() {\n\tstd :: cin >> n >> m >> k;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tstd :: cin >> a[i];\n\t}\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tstd :: cin >> d[i];\n\t}\n\tfor(int i = 1; i <= k; ++ i) {\n\t\tstd :: cin >> f[i];\n\t}\n\tstd :: sort(f + 1, f + 1 + k);\n\tint maxx = 0, mx = 0, l, r;\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(a[i] - a[i-1] > maxx) {\n\t\t\tmx = maxx;\n\t\t\tmaxx = a[i] - a[i-1];\n\t\t\tl = a[i-1], r = a[i];\n\t\t} else {\n\t\t\tmx = std :: max(mx, a[i] - a[i-1]);\n\t\t}\n\t} \n\tf[k+1] = INF;\n\tint ans = maxx;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(d[i] >= r) continue;\n\t\tint pos = std :: lower_bound(f + 1, f + 1 + k, (l + r - d[i] * 2) / 2) - f;\n\t\tfor(int j = std :: max(1LL, pos - 1); j <= std :: min(k, pos + 1); ++ j) {\n\t\t\tint res = std :: max(d[i] + f[j] - l, r - d[i] - f[j]);\n\t\t\tans = std :: min(res, ans);\n\t\t}\n\t\t// deb(d[i]);\n\t\t// deb(ans);\n\t}\n\tstd :: cout << std :: max(ans, mx) << '\\n';\n}\nsigned main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [1941G - Rudolf and Subway 补](https://codeforces.com/problemset/problem/1941/G)\n\n赛时一直调 $F$ （错误做法），这个题没看。\n\n第二天看了一下，一眼缩点 $+$ 最短路，但是调了三个小时没调出来，于是就看题解了。\n\n结果是分层图 $+$ $01BFS$ ，顺便学习了 $01BFS$ 。\n\n这个题需要将站点和颜色分层，站点一层，颜色一层。\n\n从站点到颜色需要花费 $1$ 元，从颜色到站点免费。\n\n由以上方案就能保证花费一元的情况下可以到达该颜色下的任一站点。\n\n然后跑 $01BFS$ 就好了。\n\n$O(M)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nvoid solve() {\n\tint n, m;\n\tstd :: cin >> n >> m;\n\tstd :: vector <PII> g[n+m+1];\n\tstd :: map <int, int> mp;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tint u, v, w;\n\t\tstd :: cin >> u >> v >> w;\n\t\tif(!mp[w]) {\n\t\t\tmp[w] = ++ n;\n\t\t}\n\t\tg[u].push_back({mp[w], 1});\n\t\tg[v].push_back({mp[w], 1});\n\t\tg[mp[w]].push_back({u, 0});\n\t\tg[mp[w]].push_back({v, 0});\n\t}\n\tint st, ed;\n\tstd :: cin >> st >> ed;\n\tstd :: vector <int> dis(n+m+1, INF), vis(n+m+1, 0);\n\tdis[st] = 0;\n\tstd :: deque <int> q;\n\tq.push_back(st);\n\twhile(q.size()) {\n\t\tint u = q.front(); q.pop_front();\n\t\tif(vis[u]) {\n\t\t\tcontinue;\n\t\t}\n\t\tvis[u] = 1;\n\t\tfor(auto [v, w] : g[u]) {\n\t\t\tif(dis[v] > dis[u] + w) {\n\t\t\t\tdis[v] = dis[u] + w;\n\t\t\t\tif(w) q.push_back(v);\n\t\t\t\telse q.push_front(v);\n\t\t\t}\n\t\t}\n\t}\n\tstd :: cout << dis[ed] << '\\n';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\tstd :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n","tags":["summaries"],"categories":["比赛总结","Codeforces Div.3"]},{"title":"牛客周赛 Round 36","url":"/post/141756309.html","content":"\n<center> 牛客周赛 Round 36 </center>\n\n<!--more-->\n\n## 本次做题情况\n\n做 $6 \\ T \\ / \\ 6 \\ T$ ;\n补 $0 \\ T$ ;\n\n## 题目解析\n\n### [A 小红的数位删除](https://ac.nowcoder.com/acm/contest/76609/A)\n\n输出 $a / 1000$ 即可。\n\n$O(1)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n\tint a;\n\tstd :: cin >> a;\n\tstd :: cout << a / 1000;\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [B 小红的小红矩阵构造](https://ac.nowcoder.com/acm/contest/76609/B)\n\n暴力计算，没什么好说的。\n\n$O(NM)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 110;\nint n, m, x, g[N][N];\nvoid solve() {\n\tstd :: cin >> n >> m >> x;\n\tint sum = 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tstd :: cin >> g[i][j];\n\t\t\tsum += g[i][j];\n\t\t}\n\t}\n\tif(sum != x) {\n\t\tstd :: cout << \"wrong answer\";\n\t\treturn ;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= m; ++ i)\n\t\tans ^= g[1][i];\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tint res = 0;\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tres ^= g[i][j];\n\t\t}\n\t\tif(res != ans) {\n\t\t\tstd :: cout << \"wrong answer\";\n\t\t\treturn ;\n\t\t}\n\t}\n\tfor(int i = 2; i <= m; ++ i) {\n\t\tint res = 0;\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tres ^= g[j][i];\n\t\t}\n\t\tif(res != ans) {\n\t\t\tstd :: cout << \"wrong answer\";\n\t\t\treturn ;\n\t\t}\n\t}\n\tstd :: cout << \"accepted\";\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [C 小红的白色字符串](https://ac.nowcoder.com/acm/contest/76609/C)\n\n一个单词一共五种情况。\n\n- 先大写后小写，合法。\n- 全是小写，合法。\n- 单个大写，合法。\n- 全是大写，不合法。\n- 先小写后大写，不合法。\n\n所以重点就是大写，我们可以打标记。\n\n当遇到大写的时候令 `flag = 1` ，如果当 `flag = 1` 时再遇到大写字母显然不合法，所以必须去掉，记录个数即可。\n\n$O(N)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nstd :: string str;\nvoid solve() {\n\tstd :: cin >> str;\n\tint n = str.size(), ans = 0;\n\tbool flag = 0;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tif(flag == 1) {\n\t\t\tif(str[i] >= 'A' && str[i] <= 'Z') {\n\t\t\t\tans ++;\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tstd :: cout << ans;\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [D 小红走矩阵](https://ac.nowcoder.com/acm/contest/76609/D)\n\n简单的 $bfs$ 题目，但是我赛时忘记写 $vis$ 数组了，导致一直内存超限，后来写了一个 $dijkstra$ 过了。。\n\n贴一个 $dijkstra$ 代码吧。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int max(int a, int b) { return a > b ? a : b;}\ninline int min(int a, int b) { return a < b ? a : b;}\ninline int abs(int a) { return a < 0 ? -a : a;}\nconst int MaxN = 4e6 + 20;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, dis[MaxN], head[MaxN], cnt;\nchar g[1100][1100];\nint xx[4] = {0, 0, 1, -1};\nint yy[4] = {1, -1, 0, 0};\nstruct Edge { \n\tint to, net, dis;\n}e[MaxN<<1];\nstruct Node {\n\tint x, dis;\n\tfriend bool operator < (Node a, Node b) {\n\t\treturn a.dis > b.dis;\n\t}\n};\nvoid Insert(int u, int v, int w) {\n\te[++cnt] = {v, head[u], w};\n\thead[u] = cnt;\n}\nvoid Dijstra() {\n\tmemset(dis, 0x3f, sizeof dis); dis[1] = 0;\n\tstd :: priority_queue <Node> q; q.push({1, 0});\n\twhile(q.size()) {\n\t\tNode p = q.top(); q.pop();\n\t\tint u = p.x, d = p.dis;\n\t\tif(d != dis[u]) continue;\n\t\tfor(int i = head[u]; i; i = e[i].net) {\n\t\t\tint v = e[i].to;\n\t\t\tif(dis[v] > dis[u] + e[i].dis) {\n\t\t\t\tdis[v] = dis[u] + e[i].dis;\n\t\t\t\tq.push({v, dis[v]});\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tstd :: cin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tstd :: cin >> g[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tfor(int k = 0; k < 4; ++ k) {\n\t\t\t\tint dx = i + xx[k], dy = j + yy[k];\n\t\t\t\tif(dx < 1 || dx > n || dy < 1 || dy > m || g[i][j] == g[dx][dy]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tInsert((i-1)*m+j, (dx-1)*m+dy, 1);\n\t\t\t\tInsert((dx-1)*m+dy, (i-1)*m+j, 1);\n\t\t\t}\n\t\t}\n\t}\n\tDijstra();\n\t// for(int i = 1; i <= n * m; ++ i) {\n\t// \tstd :: cout << i << ' ' << dis[i] << '\\n';\n\t// }\n\tstd :: cout << (dis[n*m] == 1061109567 ? -1 : dis[n*m]);\n\treturn 0;\n}\n```\n\n### [E 小红的小红走矩阵](https://ac.nowcoder.com/acm/contest/76609/E)\n\n根据题目信息，得出构造出的矩阵不能满足以下条件：\n\n- $n-1$ 次向右， $m-1$ 次向上即可到达终点。\n- 所有字符全都遍历一遍到达终点。\n- 某个字符超过指定限制个数。\n- 不能到达终点。\n\n看到 $n,m \\ge 3$ ，考虑先构造一个 $3 \\times 3$ 的符合题目的矩阵。\n\n显然，构造的矩阵应该让小红多移动至少两步，手玩几个样例可以构造出以下 $3 \\times 3$ 的合法矩阵。\n$$\n\\begin{matrix}\na & b & b \\\\\\\\\na & c & c \\\\\\\\\nb & c & e\n\\end{matrix}\n$$\n~~其实就是题目给的样例。~~\n\n当然，我自己构造的和样例不一样，详情见代码。\n\n剩下的随便填就好了，我是按照 $26$ 个英文字母填的。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nint n, m;\nchar g[N][N];\nvoid solve() {\n\tstd :: cin >> n >> m;\n\tg[1][1] = g[2][1] = g[3][3] = 'a';\n\tg[1][2] = g[1][3] = g[3][1] = 'b';\n\tg[2][2] = g[2][3] = g[3][2] = 'c';\n\tint pos = 3;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tif(g[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg[i][j] = ('a' + pos);\n\t\t\tpos ++;\n\t\t\tpos %= 26;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tstd :: cout << g[i][j];\n\t\t}\n\t\tstd :: cout << '\\n';\n\t}\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### [F 小红的好子串询问](https://ac.nowcoder.com/acm/contest/76609/F)\n\n几乎可以说是原题？\n\n$CF$ 上碰到过类似的，也是三个字符，然后区间改成没有回文子串的最小个数。\n\n显然，只有三个字符循环出现的时候才不会有回文子串，否则一定会有回文子串。\n\n可以举一个最简单的例子。\n\n当你有 $re$ 这个字符串，你只能在最后面添加 $d$ 才不会有回文子串，如果是 $r, e$ 就是 $rer,ree$ 都会产生回文子串。\n\n考虑三个字符循环出现，则会有六种情况，$redredred..., rderderde...,derderder...,dredredre...,erderderd...,edredredr...$。\n\n则每一种情况都要考虑。\n\n我们可以将 $6$ 种不同的循环串的 $[L,R]$ 区间与原串的区间 $[L, R]$ 进行比较，然后选择最小的不同个数的输出即可。\n\n由于是循环串，所以可以使用模运算。\n\n查询区间最小的不同个数，可以使用树状数组或者线段树，我采用的是树状数组。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint sum[6][N], n, q;\ninline int lowbit(int x) {\n\treturn x & -x;\n}\nvoid add(int x, int k, int y) {\n\tfor(; x <= n; x += lowbit(x)) {\n\t\tsum[k][x] += y;\n\t}\n}\nint query(int x, int k) {\n\tint s = 0;\n\tfor(; x; x -= lowbit(x)) {\n\t\ts += sum[k][x];\n\t}\n\treturn s;\n}\nstd :: string str;\nvoid solve() {\n\tstd :: cin >> n >> q;\n\tstd :: cin >> str;\n\tstd :: string res[] = {\"red\", \"rde\", \"der\", \"dre\", \"edr\", \"erd\"};\n\tfor(int i = 0; i < 6; ++ i) {\n\t\tfor(int j = 0; j < n; ++ j) {\n\t\t\tadd(j + 1, i, (str[j] != res[i][j%3]));\n\t\t}\n\t}\n\twhile(q --) {\n\t\tint opt, l, r;\n\t\tchar y;\n\t\tstd :: cin >> opt;\n\t\tif(opt == 1) {\n\t\t\tstd :: cin >> l >> y;\n\t\t\tfor(int i = 0; i < 6; ++ i) {\n\t\t\t\tif(res[i][(l-1)%3] != str[l-1]) {\n\t\t\t\t\tadd(l, i, -1);\n\t\t\t\t}\n\t\t\t\tif(y != res[i][(l-1)%3]) {\n\t\t\t\t\tadd(l, i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr[l-1] = y;\n\t\t} else {\n\t\t\tstd :: cin >> l >> r;\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < 6; ++ i) {\n\t\t\t\tans = std :: min(ans, query(r, i) - query(l-1, i));\n\t\t\t}\n\t\t\tstd :: cout << ans << '\\n';\n\t\t}\n\t}\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["summaries"],"categories":["比赛总结","牛客周赛"]},{"title":"AtCoder Beginner Contest 344","url":"/post/945511026.html","content":"<center> AtCoder Beginner Contest 344 </center>\n\n<!--more-->\n\n## 本次做题情况\n\n做 $5 \\ T \\ / \\ 7 \\ T$ ;\n补 $1 \\ T$ ;\n\n## 题目解析\n\n### A - Spoiler\n\n用一个标记表示在`|s|`中还是外即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n\tstd :: string str;\n\tstd :: cin >> str;\n\tbool flag = 0;\n\tfor(int i = 0; i < str.size(); ++ i) {\n\t\tif(str[i] == '|') {\n\t\t\tflag ^= 1;\n\t\t}\n\t\tif(flag == 0 && str[i] != '|') {\n\t\t\tstd :: cout << str[i];\n\t\t}\n\t} \n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### B - Delimiter\n\n这个题用栈或者反转数组都可，我用的反转$vector$。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n\tstd :: vector <int> v;\n\twhile(1) {\n\t\tint x;\n\t\tstd :: cin >> x;\n\n\t\tv.push_back(x);\n\t\tif(x == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tstd :: reverse(v.begin(), v.end());\n\tfor(auto x : v) {\n\t\tstd :: cout << x << '\\n';\n\t}\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### C - A+B+C\n\n$N, M, L$ 比较小，所以可以直接 $O(NML)$ 枚举，然后对和打标记。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 110;\nint n, m, l, q, a[N], b[N], c[N];\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tstd :: cin >> a[i];\n\t}\n\tstd :: cin >> m;\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tstd :: cin >> b[i];\n\t}\n\tstd :: map <int, bool> s;\n\tstd :: cin >> l;\n\tfor(int i = 1; i <= l; ++ i) {\n\t\tstd :: cin >> c[i];\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tfor(int k = 1; k <= l; ++ k) {\n\t\t\t\ts[a[i]+b[j]+c[k]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tstd :: cin >> q;\n\tfor(int i = 1; i <= q; ++ i) {\n\t\tint x;\n\t\tstd :: cin >> x;\n\t\tstd :: cout << (s[x] ? \"Yes\\n\" : \"No\\n\");\n\t}\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### D - String Bags\n\n$dp$ 题。\n\n设 $dp[i][j]$ 为已经选好 $T$ 字符串的前 $i$ 位且选的最后一段字符串来自 $j$ 这个背包的最小选择次数。\n\n设我当前枚举到第 $i$ 个背包中的第 $j$ 个字符串，配对了 $T$ 中 $[k, k+len]$ 的字符串，则转移方程为：\n\n$$\n\tdp[k+len-1][i] = \\min_{h=1}^{h-1}{dp[k-1][h] + 1}\n$$\n具体细节见代码。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 110;\nint n, dp[N][N];\nstd :: string t;\nvoid solve() {\n\tstd :: cin >> t;\n\tfor(int i = 0; i < N; ++ i) {\n\t\tfor(int j = 0; j < N; ++ j) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tint x;\n\t\tstd :: cin >> x;\n\t\tfor(int j = 1; j <= x; ++ j) {\n\t\t\tstd :: string s;\n\t\t\tstd :: cin >> s;\n\t\t\tfor(int k = 0; k < t.size(); ++ k) {\n\t\t\t\tbool flag = 1;\n\t\t\t\tfor(int h = 0; h < s.size(); ++ h) {\n\t\t\t\t\tif(t[k+h] != s[h]) {\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int h = 0; h < i; ++ h) {\n\t\t\t\t\tif(k > 0 && dp[k-1][h] && flag) {\n\t\t\t\t\t\tdp[k+s.size()-1][i] = std :: min(dp[k-1][h] + 1, dp[k+s.size()-1][i]);\n\t\t\t\t\t} else if(k == 0 && flag) {\n\t\t\t\t\t\tdp[k+s.size()-1][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tans = std :: min(ans, dp[t.size()-1][i]);\n\t}\n\tstd :: cout << (ans != INF ? ans : -1);\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### E - Insert or Erase\n\n数据结构中的链表，裸的还是。。\n\n注意头指针和尾指针都要处理好，我因为这个wa了几次。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, q;\nvoid solve() {\n\tstd :: cin >> n;\n\tstd :: map <int, int> pre, nxt;\n\tint lst = 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tint x;\n\t\tstd :: cin >> x;\n\t\tpre[x] = lst;\n\t\tnxt[lst] = x;\n\t\tlst = x;\n\t}\n\tnxt[lst] = -1;\n\tpre[-1] = lst;\n\tstd :: cin >> q;\n\tfor(int i = 1; i <= q; ++ i) {\n\t\tint opt, l, r;\n\t\tstd :: cin >> opt >> l;\n\t\tif(opt == 1) {\n\t\t\tstd :: cin >> r;\n\t\t\tnxt[r] = nxt[l];\n\t\t\tpre[nxt[r]] = r;\n\t\t\tpre[r] = l;\n\t\t\tnxt[l] = r;\n\t\t} else {\n\t\t\tpre[nxt[l]] = pre[l];\n\t\t\tnxt[pre[l]] = nxt[l];\n\t\t}\n\t}\n\tint pos = 0;\n\twhile(pos != -1) {\n\t\tif(pos != 0) {\n\t\t\tstd :: cout << pos << ' ';\n\t\t}\n\t\tpos = nxt[pos];\n\t}\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n### F - Earn to Advance（补）\n\n贪心 + $DP$ \n\n设 $dis[i][j][k][h]$ 为从 $(i,j)$ 到 $(k,h)$ 所用的最少钱数，可以用 $O(N^4)$ 的复杂度求出，考虑枚举每一个点，然后由这个点出发到其他位置的最短路，$dp$ 一下即可解决，转移方程为\n\n$$\ndis[i][j][k][h] = min(dis[i][j][k][h], min(dis[i][j][k][h-1] + r[k][h-1],dis[i][j][k-1][h] + d[k-1][h]))\n$$\n\n设 $ans[i][j]$ 为到 $(i,j)$ 所用的最少操作次数， $money[i][j]$ 为最少操作次数到达 $(i,j)$ 时剩下的钱数。\n\n考虑如何进行转移。\n\n问题的关键在于我们应该在哪里进行原地获取钱。\n\n我们考虑枚举每一个点 $(i, j)$，然后再枚举原地获取钱的位置 $(x, y)$（显然 $1 \\le x \\le i,1 \\le y \\le j$且 $x=i$ 和 $y = j$ 不能同时成立），让其一直获取钱数知道足够到达当前枚举的位置即可。\n\n- 如果从获钱点 $(x,y)$ 到 $(i,j)$ 所用的步数小于 $ans[i][j]$ ，显然是更新的。\n- 如果从获钱点 $(x,y)$ 到 $(i,j)$ 所用的步数等于 $ans[i][j]$ 但是剩余钱数更多，则也要更新。\n\n也许你可能会想一个问题，如果当前枚举的获钱点 $(x, y)$ 到当前点 $(i, j)$ 的步数更多，而且钱数更多为什么不会更新。\n\n额，看了下官方题解，真心没看懂，但是感觉这样贪心一定是对的。\n\n~~如果我想明白了，会填坑的。~~\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x7f7f7f7f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst i64 Range = 1e18;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 88;\ni64 dis[N][N][N][N], money[N][N], ans[N][N];\ni64 p[N][N], r[N][N], d[N][N];\nint n;\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 0; i <= n; ++ i) {\n\t\tfor(int j = 0; j <= n; ++ j) {\n\t\t\tfor(int k = 0; k <= n; ++ k) {\n\t\t\t\tfor(int h = 0; h <= n; ++ h) {\n\t\t\t\t\tdis[i][j][k][h] = Range;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; ++ i) {\n\t\tfor(int j = 0; j <= n; ++ j) {\n\t\t\tans[i][j] = Range;\n\t\t\tfor(int k = i; k <= n; ++ k) {\n\t\t\t\tfor(int h = j; h <= n; ++ h) {\n\t\t\t\t\tif(i == k && j == h && i > 0 && j > 0) {\n\t\t\t\t\t\tdis[i][j][k][h] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans[1][1] = 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tstd :: cin >> p[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j < n; ++ j) {\n\t\t\tstd :: cin >> r[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i < n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tstd :: cin >> d[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tfor(int k = i; k <= n; ++ k) {\n\t\t\t\tfor(int h = j; h <= n; ++ h) {\n\t\t\t\t\tif(i == k && j == h) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdis[i][j][k][h] = std :: min(dis[i][j][k][h],\n\t\t\t\t\t\tstd :: min(dis[i][j][k][h-1] + r[k][h-1],\n\t\t\t\t\t\t\tdis[i][j][k-1][h] + d[k-1][h]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tfor(int k = 1; k <= i; ++ k) {\n\t\t\t\tfor(int h = 1; h <= j; ++ h) {\n\t\t\t\t\tif(i == k && j == h) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ti64 step = std :: max(0.0, std :: ceil(1.0 * (dis[k][h][i][j] - money[k][h]) / p[k][h]));\n\t\t\t\t\tif(i - k + j - h + step + ans[k][h] < ans[i][j]) {\n\t\t\t\t\t\tans[i][j] = ans[k][h] + step + i - k + j - h;\n\t\t\t\t\t\tmoney[i][j] = money[k][h] + step * p[k][h] - dis[k][h][i][j];\n\t\t\t\t\t} else if(i - k + j - h + step + ans[k][h] == ans[i][j]) {\n\t\t\t\t\t\tmoney[i][j] = std :: max(money[i][j], money[k][h] + step * p[k][h] - dis[k][h][i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd :: cout << ans[n][n];\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n### G（咕）\n","tags":["summaries"],"categories":["比赛总结","Atcoder ABC"]},{"title":"CF 607A - Chain Reaction题解","url":"/post/3547872903.html","content":"<center> CF 607A - Chain Reaction题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/607/A)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%20607A.png?raw=true)\n\n#### Sample Input\n\n```\n7\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n```\n\n#### Sample Output\n\n```\n3\n```\n\n#### 解析：\n\n由于一开始我们可以在最右侧建立一个灯塔，其可以摧毁右边连续 $i$ 个灯塔。\n\n所以我们不妨枚举一下这个右边的灯塔个数，然后看没有一开始被摧毁的灯塔被摧毁几个。\n\n没有被摧毁的灯塔可以被预处理。\n\n我们从左向右枚举，设 $dp[i]$ 为从第一个灯塔到第 $i$ 个灯塔被摧毁的个数，当前的灯塔为 $x, y$ 其位置为 $x$ ，能量为 $y$ 。\n\n那么位于 $[x-y, x-1]$ 的灯塔都会被摧毁，显然，我们可以由二分确定 $x-y$ 位置对应的下标，然后由此下标前一个答案更新当前的答案，即 $dp[i] = dp[pos-1] + i - pos$ 。\n\n最后枚举一开始被摧毁的灯塔个数求 $dp[i-1] + n - i + 1$  的最小值即可。\n\n当然要注意可能一个也不摧毁，也要考虑 $dp[n]$ 对答案的影响。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n, dp[N];\nstruct Chain {\n  int x, y;\n  friend bool operator < (Chain a, Chain b) {\n    return a.x < b.x ;\n  }\n}a[N];\nvoid solve() {\n  std :: cin >> n;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i].x >> a[i].y;\n  }\n  std :: sort(a + 1, a + 1 + n);\n  for(int i = 2; i <= n; ++ i) {\n    Chain res = {a[i].x-a[i].y, 0};\n    int pos = std :: lower_bound(a + 1, a + 1 + i, res) - a;\n    dp[i] = dp[pos-1] + i - pos;\n  }\n  int ans = INF;\n  for(int i = 1; i <= n; ++ i) {\n    ans = std :: min(ans, dp[i-1] + n - i + 1);\n  }\n  std :: cout << std :: min(ans, dp[n]);\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  //std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 1722E - Counting Rectangles题解","url":"/post/3374876020.html","content":"<center> CF 1722E - Counting Rectangles题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1722/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201722E.png)\n#### Sample Input\n\n```\n3\n2 1\n2 3\n3 2\n1 1 3 4\n5 5\n1 1\n2 2\n3 3\n4 4\n5 5\n3 3 6 6\n2 1 4 5\n1 1 2 10\n1 1 100 100\n1 1 3 3\n3 1\n999 999\n999 999\n999 998\n1 1 1000 1000\n```\n\n#### Sample Output\n\n```\n6\n41\n9\n0\n54\n4\n2993004\n```\n\n#### 解析：\n\n前缀和+容斥。\n\n我们可以先把所有矩形放到一个二维直角坐标系中，其中左下角对齐 $(0,0)$ 。\n\n然后我们可以直接标记右上角点 $(h,w)$ 来标记一个矩形。\n\n题目中要找可以包含 $h_s,w_s$ 的矩形，即 $(h_s,w_s)$ 在矩形 $(h, w)$ 的左下角即可。\n\n同理， $(h_b,w_b)$ 在矩形 $(h,w)$ 的右上角即可。\n\n考虑在 $(h_s, w_s)$ 和 $(h_b, w_b)$ 中的矩形面积。\n\n设 $sum_{i,j}$ 为 $(i,j)$ 左下角的矩形总面积。\n\n考虑容斥，不难得出答案即为 $sum_{hb-1,wb-1} - sum_{hs, wb-1} - sum_{hb-1,wb} + sum_{hs, ws}$。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nconst int M = 1e5 + 20;\ni64 sum[N][N];\nint n, q;\nvoid solve() {\n  std :: cin >> n >> q;\n  for(int i = 1; i <= N - 10; ++ i) {\n    for(int j = 1; j <= N - 10; ++ j) {\n      sum[i][j] = 0;\n    }\n  }\n  for(int i = 1; i <= n; ++ i) {\n    int h, w;\n    std :: cin >> h >> w;\n    sum[h][w] += h * w;\n  }\n  for(int i = 1; i <= N - 10; ++ i) {\n    for(int j = 1; j <= N - 10; ++ j) {\n      sum[i][j] = sum[i][j] + sum[i][j-1] + \n        sum[i-1][j] - sum[i-1][j-1];\n    }\n  }\n  while(q --) {\n    int hs, ws, hb, wb;\n    std :: cin >> hs >> ws >> hb >> wb;\n    std :: cout << sum[hb-1][wb-1] - sum[hs][wb-1] - sum[hb-1][ws] + sum[hs][ws] << '\\n';\n  }\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["前缀和","容斥"],"categories":["CF","题解"]},{"title":"CF 1703G - Good Key, Bad Key题解","url":"/post/3913583336.html","content":"<center> CF 1703G - Good Key, Bad Key题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1703/G)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201703G.png)\n\n#### Sample Input\n\n```\n5\n4 5\n10 10 3 1\n1 2\n1\n3 12\n10 10 29\n12 51\n5 74 89 45 18 69 67 67 11 96 23 59\n2 57\n85 60\n```\n\n#### Sample Output\n\n```\n11\n0\n13\n60\n58\n```\n\n#### 解析：\n\n首先，我们要知道，这一段箱子从左到右打开，则一定是先用好钥匙打开，然后一直用坏钥匙打开。\n\n比如说 $a_i,a_{i+1}$ 两个箱子，有四种情况。\n\n1. 都用好钥匙，$a_i + a_{i+1} - 2 * k$\n2. 都用坏钥匙，$\\lfloor \\frac{a_i}{2} \\rfloor + \\lfloor \\frac{a_{i+1}}{4} \\rfloor$\n3. 先用好钥匙再用坏钥匙，$a_i + \\lfloor \\frac{a_{i+1}}{2} \\rfloor - k$\n4. 先用坏钥匙再用好钥匙，$\\lfloor \\frac{a_i}{2} \\rfloor + \\lfloor \\frac{a_{i+1}}{2} \\rfloor - k$\n\n很显然，先用好钥匙一定优于先用坏钥匙。\n\n另外，我们注意到 $a_i \\le 1e9$，利用计算器算得 $\\log_2(1e9) \\approx 30$ 。\n\n则我们只需要枚举最后一个用好钥匙开锁的箱子，然后再向后枚举 $30$ 个用坏钥匙开锁的箱子即可。\n\n$30$ 个坏钥匙开锁的箱子可以使用线段树维护。\n\n总的复杂度为 $O(nlogn)$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n;\ni64 k, a[N];\nstruct Node {\n  int l, r;\n  i64 sum[31];\n}t[N<<2];\nvoid build(int l, int r, int k) {\n  t[k].l = l; t[k].r = r;\n  if(l == r) {\n    t[k].sum[0] = a[l];\n    for(int i = 1; i <= 30; ++ i) {\n      t[k].sum[i] = t[k].sum[i-1] / 2;\n    }\n    return ;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, ls); build(mid + 1, r, rs);\n  for(int i = 0; i <= 30; ++ i) {\n    t[k].sum[i] = t[ls].sum[i] + t[rs].sum[i];\n  }\n}\ni64 query(int l, int r, int k, int x) {\n  if(l > r) return 0;\n  if(t[k].l >= l && t[k].r <= r) {\n    return t[k].sum[x];\n  }\n  int mid = (t[k].l + t[k].r) >> 1;\n  i64 s = 0;\n  if(l <= mid) s += query(l, r, ls, x);\n  if(r > mid) s += query(l, r, rs, x);\n  return s;\n}\nvoid solve() {\n  std :: cin >> n >> k;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n  }\n  build(1, n, 1);\n  i64 ans = 0;\n  for(int i = 0; i <= n; ++ i) {\n    i64 sum = query(1, i, 1, 0) - 1LL * i * k;\n    int res = 1;\n    for(int j = i + 1; j <= std :: min(i + 29, n); ++ j) {\n      sum += query(j, j, 1, res);\n      res ++;\n    }\n    ans = std :: max(ans, sum);\n  }\n  std :: cout << ans << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["线段树","枚举"],"categories":["题解","CF"]},{"title":"CF 1857F - Sum and Product题解","url":"/post/4107334203.html","content":"<center> CF 1857F - Sum and Product题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1857/F)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201857F.png)\n\n#### Sample Input\n\n```\n3\n3\n1 3 2\n4\n3 2\n5 6\n3 1\n5 5\n4\n1 1 1 1\n1\n2 1\n6\n1 4 -2 3 3 3\n3\n2 -8\n-1 -2\n7 12\n```\n\n#### Sample Output\n\n```\n1 1 0 0 \n6 \n1 1 3\n```\n\n#### 解析：\n\n数学题目。\n\n很显然，​ 满足以下条件：\n\n$$\n\\begin{cases}\na_i + a_j = x \\\\\na_i \\times a_j = y\n\\end{cases}\n$$\n求解可得，$a_i = \\frac{x \\pm \\sqrt{x^2-4y}}{2},a_j = \\frac{x \\mp \\sqrt{x^2-4y}}{2}$\n\n1. 当 $x^2-4y=0$\n\n   则只需计算出 $a_i = \\frac{x}{2}$ 的个数，答案为 $\\frac{cnt \\times (cnt-1)}{2}$ 。\n\n2. 当 $x^2 - 4y = 0$\n\n   不妨令 $a_i = \\frac{x + \\sqrt{x^2-4y}}{2},a_j = \\frac{x - \\sqrt{x^2-4y}}{2}$ 。\n\n   设 $a_i$ 的个数为 $cnt1$ ， $a_j$ 的个数为 $cnt2$ 。\n\n   则答案为 $cnt1 \\times cnt2$ 。\n\n计算个数使用 $map$ 即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n  int n, q;\n  std :: cin >> n;\n  std :: map <int, int> cnt;\n  for(int i = 1; i <= n; ++ i) {\n    int x; std :: cin >> x;\n    cnt[x] ++;\n  }\n  std :: cin >> q;\n  while(q --) {\n    i64 x, y, delta, res;\n    std :: cin >> x >> y;\n    delta = x * x - 4 * y;\n    res = sqrt(delta);\n    if(res * res != delta || (res * res == delta && (cnt[(x-res)/2] == 0 || cnt[(x+res)/2] == 0))) {\n      std :: cout << 0 << ' ';\n      continue;\n    } else {\n      i64 ans;\n      if(res) {\n        ans = 1LL * cnt[(x-res)/2] * cnt[(x+res)/2];\n      } else {\n        ans = 1LL * cnt[x/2] * (cnt[x/2] - 1) / 2;\n      }\n      std :: cout << ans << ' ';\n    }\n  }\n  std :: cout << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["数学"],"categories":["题解","CF"]},{"title":"CF 1687A - The Enchanted Forest题解","url":"/post/518707783.html","content":"<center> CF 1689C - Infected Tree题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1687/A)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201687A.png)\n\n#### Sample Input\n\n```\n4\n5 2\n5 6 1 2 3\n5 7\n5 6 1 2 3\n1 2\n999999\n5 70000\n1000000000 1000000000 1000000000 1000000000 1000000000\n```\n\n#### Sample Output\n\n```\n12\n37\n1000000\n5000349985\n```\n\n#### 解析：\n\n很显然，我们首先要按照 $k \\leq n$ 和 $k > n$ 来分开想。\n\n而且需要注意的是，我们也要将一开始的蘑菇和刚长出来的要分开算。\n\n1. $k \\leq n$ \n\n   我们一定是按照某一个方向连续采集蘑菇，这一定是最优的，即 $\\max (sum[i] - sum[i-k] + \\frac{k(k-1)}{2})$ 。\n\n2. $k > n$\n\n   这个一定会全部将原来的蘑菇都采集一遍然后再采集刚长出的。\n\n   很显然，他一定会剩下一部分蘑菇拿不到，一共有 $n$ 个整数，设其总和为 $t$，而我们知道一共长出来的蘑菇有 $n \\times k$。\n\n   则答案就是 $sum[n] + n \\times k - t$ 。\n\n   $sum[n]、n \\times k$ 都是固定的，要想让答案最大，则 $t$ 最小，很显然当最后的序列为 $1,2, \\dots, n$ 时 $t$ 是最小的，则答案为 $sum[n] + n \\times k - \\frac{n(n+1)}{2}$ 。 \n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, k, a[N];\ni64 sum[N];\nvoid solve() {\n  std :: cin >> n >> k;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n    sum[i] = sum[i-1] + a[i];\n  }\n  i64 ans = -LLINF;\n  if(k <= n) {\n    for(int i = 1; i <= n; ++ i) {\n      if(i >= k) {\n        ans = std :: max(ans, sum[i] - sum[i-k] + 1LL * (k - 1) * k / 2);\n      }\n    }\n  } else {\n    ans = sum[n] + 1LL * n * k - 1LL * n * (n + 1) / 2;\n  }\n  std :: cout << ans << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["贪心","数学"],"categories":["题解","CF"]},{"title":"CF 453A - Little Pony and Expected Maximum题解","url":"/post/1796657745.html","content":"<center> CF 453A - Little Pony and Expected Maximum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/453/A)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20453A.png)\n\n#### Sample Input\n\n```\n6 3\n```\n\n#### Sample Output\n\n```\n4.958333333333\n```\n\n#### 解析：\n\n数学题。\n\n设 $n$ 次中最高分数为 $i$ 的概率为 $p[i]$ ，则期望为 $E = \\sum \\limits _{i=1} ^{m} ip[i]$ 。\n\n则重点就是求 $ip[i]$ 。\n\n首先求 $p[i]$ 。\n\n很显然，投掷 $n$ 次，则分母就是 $m^n$ 。\n\n对于最高分数为 $i$ 时，分子就是 $i^n-(i-1)^n$，即至少有一次投掷到 $i$ 。\n\n即 $E = \\sum \\limits _{i=1} ^{m} ip[i] = \\sum \\limits _{i=1} ^{m} i \\frac{i^n-(i-1)^n}{m^n} = m - \\sum \\limits _{i=1} ^{m-1} (\\frac{i}{m})^n$ 。\n\n用快速幂即可解决。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\ndouble n, m;\ndouble quick_mi(double a, double b) {\n  double sum = 1;\n  while(b) {\n    if((int)b & 1) {\n      sum = sum * a;\n    }\n    a = a * a; b = b / 2;\n  } return sum;\n}\nvoid solve() {\n  std :: cin >> m >> n;\n  double ans = m;\n  for(double i = 1; i <= m - 1; ++ i) {\n    ans -= quick_mi(i / m, n);\n  }\n  printf(\"%.10lf\", ans);\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  //std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["数学","快速幂"],"categories":["题解","CF"]},{"title":"CF 1282B2 - K for the Price of One (Hard Version)题解","url":"/post/2168176839.html","content":"<center> CF 1282B2 - K for the Price of One (Hard Version)题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1282/B2)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201282B2.png)\n#### Sample Input\n\n```\n8\n5 6 2\n2 4 3 5 7\n5 11 2\n2 4 3 5 7\n3 2 3\n4 2 6\n5 2 3\n10 1 3 9 2\n2 10000 2\n10000 10000\n2 9999 2\n10000 10000\n4 6 4\n3 2 3 2\n5 5 3\n1 2 2 1 2\n```\n\n#### Sample Output\n\n```\n3\n4\n1\n1\n2\n0\n4\n5\n```\n\n#### 解析：\n\n$dp$ 题。\n\n设 $dp[i]$ 为购买了 $i$ 和部分下标小于 $i$ 的最大答案。\n\n设 $res[i]$ 为购买了 $i$ 和部分下标小于 $i$ 所剩的最大钱数。\n\n很显然，当 $i < k$ 时，只能单个购买，而且贪心地想，肯定是顺序购买地最优的，因为价格会更低，则当 $res[i-1] >= a[i]$ ，$dp[i] = dp[i-1] + 1$ 。\n\n当 $i \\geq k$ 时，可以多个购买，则当 $res[i-k] \\geq a[i]$ 时， $dp[i] = dp[i-k] + k$ 。\n\n则答案即为 $\\max \\limits _{i=1} ^{n} dp[i]$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, p, k, a[N], res[N], dp[N], ans;\nvoid solve() {\n  std :: cin >> n >> p >> k;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n    res[i] = 0; dp[i] = 0;\n  }\n  res[0] = p; ans = 0;\n  std :: sort(a + 1, a + 1 + n);\n  for(int i = 1; i <= n; ++ i) {\n    if(i < k) {\n      if(res[i-1] >= a[i]) {\n        dp[i] = dp[i-1] + 1;\n        res[i] = res[i-1] - a[i];\n      }\n    } else {\n      if(res[i-k] >= a[i]) {\n        dp[i] = dp[i-k] + k;\n        res[i] = res[i-k] - a[i];\n      }\n    }\n    ans = std :: max(ans, dp[i]);\n  }\n  std :: cout << ans << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["贪心","DP"],"categories":["题解","CF"]},{"title":"CF 1175B - Catch Overflow!题解","url":"/post/2540438585.html","content":"<center> CF 1175B - Catch Overflow!题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1175/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201175B.png)\n\n#### Sample Input\n\n```\n9\nadd\nfor 43\nend\nfor 10\nfor 15\nadd\nend\nadd\nend\n```\n\n#### Sample Output\n\n```\n161\n```\n\n#### 解析：\n\n很显然可以使用栈来模拟 $for$ 循环。\n\n对于每层循环我们都把循环次数压进去，如果遇到 `add` 就加栈顶，遇到 `end` 就出栈。\n\n需要注意的是，可能压入的循环次数过大，所以有一个上限值，可以为 $2^{32}$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nstd :: string str[N];\nint x[N], n;\nvoid solve() {\n  std :: cin >> n;\n  i64 ans = 0;\n  i64 inf = 4294967295LL;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> str[i];\n    if(str[i] == \"for\") {\n      std :: cin >> x[i];\n    }\n  }\n  i64 maxx = 1LL << 32;\n  std ::  stack <i64> s;\n  s.push(1);\n  for(int i = 1; i <= n; ++ i) {\n    if(str[i] == \"for\") {\n      s.push(std :: min(s.top() * x[i], maxx));\n    } else if(str[i] == \"add\") {\n      ans += s.top();\n      if(ans > inf) break;\n    } else {\n      s.pop();\n    }\n  }\n\n  if(ans <= inf) {\n    std :: cout << ans;\n  } else {\n    std :: cout << \"OVERFLOW!!!\";\n  }\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  //std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["栈"],"categories":["题解","CF"]},{"title":"CF 1748C - Zero-Sum Prefixes题解","url":"/post/98466197.html","content":"<center> CF 1748C - Zero-Sum Prefixes题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1748/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201748C.png)\n\n#### Sample Input\n\n```\n5\n5\n2 0 1 -1 0\n3\n1000000000 1000000000 0\n4\n0 0 0 0\n8\n3 0 2 -10 10 -30 30 0\n9\n1 0 0 1 -1 0 1 0 -1\n```\n\n#### Sample Output\n\n```\n3\n1\n4\n4\n5\n```\n\n#### 解析：\n\n$dp$ 题。\n\n设 $dp[i]$ 为第 $i$ 位的前缀和为 $0$ 时前 $i$ 位的最大答案。\n\n设 $maxx$ 是 $\\max\\limits _{k=0} ^{i-1} dp[k]$。\n\n设 $s$ 为当前位置到上一个 $0$ 的前缀和。\n\n设 $lst[i]$ 为当前位置的上一个 $a[i] = 0$ 的位置。\n\n设 $m[s]$ 为 $map$ 数组，记录从上一个 $0$ 到当前位置上一个 $s$ 出现的位置。\n\n分情况讨论。\n\n1. 当前位是 $0$ \n\n   很显然，$dp[i] = maxx + 1$ 。\n\n2. 当前位不是 $0$ \n\n   1. 前面没有遇到过 $0$ 而且当前前缀和为 $0$ \n\n      由于前面没有出现过 $a[i] = 0$ ，所以只能从上一个前缀和为 $0$ 的地方更新，即 $dp[i] = maxx + 1$。\n\n   2. 前面有 $0$ \n\n      1.  $m[s] = 0$\n\n         证明第一次前缀和为当前值，则 $dp[i] = dp[lst[i]]$ 。\n\n      2.  $m[s] = 1$\n\n         证明已经有了至少一次，可以更新，则 $dp[i] = dp[m[s]] + 1$ 。\n\n最终答案即为 $maxx$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint t = 1;\nvoid solve() {\n  int n, res = 0;\n  std :: cin >> n;\n  std :: map <i64, int> m;\n  std :: vector <int> a(n + 1), lst(n + 1), dp(n + 1);\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n  }\n  for(int i = 1; i <= n; ++ i) {\n    lst[i] = lst[i-1];\n    if(a[i] == 0) lst[i] = i;\n  }\n  i64 s = 0;\n  int maxx = 0;\n  for(int i = 1; i <= n; ++ i) {\n    if(a[i] == 0) {\n      dp[i] = ++ maxx;\n      s = 0;\n      m.clear();\n      m[0] = i;\n      continue;\n    }\n    \n    s += a[i];\n    if(s == 0 && lst[i] == 0) {\n      if(m[s]) {\n        dp[i] = dp[m[s]] + 1;\n      } else {\n        dp[i] = 1;\n      }\n      maxx = std :: max(maxx, dp[i]);\n    }\n    if(lst[i] != 0) {\n      if(m[s]) {\n        dp[i] = dp[m[s]] + 1;\n        maxx = std :: max(maxx, dp[i]);\n      } else {\n        dp[i] = dp[lst[i]];\n      }\n    }\n    m[s] = i;\n  }\n\n  std :: cout << maxx << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T;\n  for(; t <= T; ++ t) {\n    solve();\n  }\n  return 0;\n}\n```","tags":["DP","前缀和"],"categories":["题解","CF"]},{"title":"CF 1741E - Sending a Sequence Over the Network 题解","url":"/post/3862998245.html","content":"<center> CF 1741E - Sending a Sequence Over the Network 题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1741/E)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%201741E.png?raw=true)\n\n#### Sample Input\n\n```\n7\n9\n1 1 2 3 1 3 2 2 3\n5\n12 1 2 7 5\n6\n5 7 8 9 10 3\n4\n4 8 6 2\n2\n3 1\n10\n4 6 2 1 9 4 9 3 4 2\n1\n1\n```\n\n#### Sample Output\n\n```\nYES\nYES\nYES\nNO\nYES\nYES\nNO\n```\n\n#### 解析：\n\n$dp$ 题。\n\n我们可以 $O(N)$ 扫一遍数组，设每一位都有可能是个数，然后向左向右延伸。\n\n设 $dp[i]$ 为第 $i$ 位为止且前 $i$ 位是合法的。\n\n当遍历到第 $i$ 位时，有三种情况：\n\n1. 当前位置是一个序列的开端。\n\n   那么此时当前位置的前一位必须是合法的（当然， $i + a[i] \\leq n$），即 $dp[i-1] = 1$ ，然后 $i + a[i]$ 的位置也是合法的，即 $dp[i+a[i]] = 1$ 。\n\n2. 当前位置是一个序列的结束。\n\n   那么此时当前位置的 $i-a[i]-1$ 位必须是合法的（当然， $i - a[i] - 1 \\geq 0$），即 $dp[i-a[i]-1] = 1$ ，然后 $i$ 的位置也是合法的，即 $dp[i] = 1$ 。\n\n3. 当前位置是一个序列的中间位置。\n\n   当前情况不可更新，可以略过。\n\n最后看 $dp[n]$ 是否等于 $1$ 即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, a[N], dp[N];\nvoid solve() {\n  std :: cin >> n;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n    dp[i] = 0;\n  } dp[0] = 1;\n  for(int i = 1; i <= n; ++ i) {\n    if(i + a[i] <= n && dp[i-1] == 1) {\n      dp[i+a[i]] = 1;\n    }\n    if(i - a[i] - 1 >= 0 && dp[i-a[i]-1] == 1) {\n      dp[i] = 1;\n    }\n  }\n  std :: cout << ((dp[n] == 1) ? \"YES\\n\" : \"NO\\n\");\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["DP"],"categories":["题解","CF"]},{"title":"1582D - Vupsen, Pupsen and 0","url":"/post/4092333509.html","content":"<center> CF 1582D - Vupsen, Pupsen and 0题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1582/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201582D.png)\n\n#### Sample Input\n\n```\n3\n2\n5 5\n5\n5 -2 10 -9 4\n7\n1 2 3 4 5 6 7\n```\n\n#### Sample Output\n\n```\n1 -1\n-1 5 1 -1 -1\n-10 2 2 -3 5 -1 -1\n```\n\n#### 解析：\n\n一个构造题。\n\n要求 $b[n]$ 数组，还要要求 $\\Sigma |b[i]| \\leq 1e9$ 。\n\n观察数据范围 $n \\leq 1e5， a[i] \\leq 1e4$ ，也就是说 $\\Sigma |a[i]| \\leq 1e9$ 。\n\n而我们很容易想到对于两个非负整数 $x, y$ ，一定有 $x \\times (-y) + y \\times x = 0$ 。\n\n这样我们就能凑出 $b[n]$ 数组，只需要 $a[n]$ 中相邻两个数凑出 $0$ 即可，且 $\\Sigma |b[i]| = \\Sigma |a[i]| \\leq 1e9$。\n\n需要注意的是 $n$ 可能会是奇数，那我们就要特判最后三位。\n\n有一个小点，就是对于非负整数 $x, y, z$ 来说，一定不会满足以下式子：\n\n$\\begin{cases}x + y = 0 \\\\ x + z = 0 \\\\ y + z = 0\\end{cases}$\n\n也就是说最后三个数中一定存在两个数加起来不为 $0$ ，而剩下那个数也不为 $0$ ，按照上述方法构造即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n, a[N];\nvoid solve() {\n  std :: cin >> n;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n  }\n  bool odd = 0;\n  if(n & 1) {\n    a[n-1] += a[n];\n    n --; odd = 1;\n  }\n  for(int i = 1; i <= n; i += 2) {\n    int x = a[i], y = a[i+1];\n    if(y != 0) {\n      y = -y;\n    } else {\n      a[n] -= a[n+1];\n      if(a[i] + a[n+1] != 0) {\n        std :: cout << -a[n] << ' ' << (a[i] + a[n+1]) << ' ' << -a[n] << '\\n';\n      } else {\n        std :: cout << -a[n+1] << ' ' << -a[n+1] << ' ' << (a[i] + a[n]) << '\\n';\n      }\n      return ;\n    }\n    std :: cout << y << ' ' << x << ' ';\n    if(i == n - 1 && odd) {\n      std :: cout << x;\n    }\n  }\n  std :: cout << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["构造题"],"categories":["题解","CF"]},{"title":"CF 1689C - Infected Tree题解","url":"/post/1381938340.html","content":"<center> CF 1689C - Infected Tree题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1689/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201689C.png)\n\n#### Sample Input\n\n```\n4\n2\n1 2\n4\n1 2\n2 3\n2 4\n7\n1 2\n1 5\n2 3\n2 4\n5 6\n5 7\n15\n1 2\n2 3\n3 4\n4 5\n4 6\n3 7\n2 8\n1 9\n9 10\n9 11\n10 12\n10 13\n11 14\n11 15\n```\n\n#### Sample Output\n\n```\n0\n2\n2\n10\n```\n\n#### 解析：\n\n树形 $DP$ 题目。\n\n设 $dp[u]$ 为 $u$ 感染时当前子树的最大贡献值， $num[u]$ 为 $u$ 的子树大小。\n\n由于题目中说明是二叉树，所以对于状态转移方程来说有两种情况。\n\n1.  $u$ 只有一个儿子。\n\n   由于当前 $u$ 是感染的，所以把儿子删掉即可。\n\n   此时， $dp[u] = num[lson] - 1$ 。\n\n2.  $u$ 有两个儿子。\n\n   删掉其中一个儿子。\n\n   此时， $dp[u] = max(dp[lson] + num[r] - 1, dp[rson] + num[l] - 1)$ 。\n\n最终答案即为 $dp[1]$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 3e5 + 20;\nint n, num[N], cnt, head[N], dp[N];\nstruct Edge {\n  int to, net;\n}e[N<<1];\ninline void Insert(int u, int v) {\n  e[++cnt] = {v, head[u]};\n  head[u] = cnt;\n}\nvoid dfs(int u, int fa) {\n  num[u] = 1; dp[u] = 0;\n  int l = 0, r = 0;\n  for(int i = head[u]; i; i = e[i].net) {\n    int v = e[i].to;\n    if(v == fa) continue;\n    dfs(v, u);\n    if(l == 0) {\n      l = v;\n    } else {\n      r = v;\n    }\n    num[u] += num[v];\n  }\n  if(l != 0) {\n    if(r == 0) {\n      dp[u] = num[l] - 1;\n    } else {\n      dp[u] = std :: max(dp[l] + num[r] - 1, dp[r] + num[l] - 1);\n    }\n  }\n}\nvoid init() {\n    cnt = 0;\n    std :: fill(head, head + n + 1, 0);\n}\nvoid solve() {\n  std :: cin >> n;\n    init();\n  for(int i = 1; i < n; ++ i) {\n    int u, v;\n    std :: cin >> u >> v;\n    Insert(u, v); Insert(v, u);\n  }\n  dfs(1, 1);\n  std :: cout << dp[1] << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T;\n  while(T --) solve();\n  return 0;\n}\n```","tags":["DP","树形DP"],"categories":["题解","CF"]},{"title":"CF 763A - Timofey and a tree题解","url":"/post/1875894372.html","content":"<center> CF 763A - Timofey and a tree题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/763/A)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%20763A.png?raw=true)\n\n#### Sample Input\n\n```\n4\n1 2\n2 3\n3 4\n1 2 1 1\n```\n\n#### Sample Output\n\n```\nYES\n2\n```\n\n#### 解析：\n\n在无根树里找到一个根，很显然，这个根符合一定的条件。\n\n他一定与其他颜色的子树直接相连，我们就可以根据这个找到它。\n\n设 $rt$ 为我们要找的根，$num$ 数组表示当前节点与相邻颜色不同的节点数，$cnt$ 为所有相邻颜色不同的节点个数（去重）。\n\n则一定有 $num[rt] = cnt - 1$ （除去根本身）\n\n还有一个点要注意的是，如果他这个树颜色一致，则选 $1$ 为根即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n, col[N], cnt, head[N], num[N];\nstd :: set <int> s;\nstruct Edge {\n  int to, net;\n}e[N<<1];\ninline void Insert(int u, int v) {\n  e[++cnt] = {v, head[u]};\n  head[u] = cnt;\n}\nvoid dfs(int u, int fa) {\n  for(int i = head[u]; i; i = e[i].net) {\n    int v = e[i].to;\n    if(v == fa) continue;\n    if(col[v] != col[u]) {\n      s.insert(v);\n      s.insert(u);\n      num[u] ++; num[v] ++;\n    }\n    dfs(v, u);\n  }\n}\nvoid solve() {\n  std :: cin >> n;\n  for(int i = 1; i < n; ++ i) {\n    int u, v;\n    std :: cin >> u >> v;\n    Insert(u, v); Insert(v, u);\n  }\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> col[i];\n  }\n  dfs(1, 1);\n  for(auto x : s) {\n    if(num[x] == s.size() - 1) {\n      std :: cout << \"YES\\n\";\n      std :: cout << x;\n      return ;\n    }\n  }\n  if(s.empty()) {\n    std :: cout << \"YES\\n1\";\n    return ;\n  }\n  std :: cout << \"NO\";\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  // std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["遍历","树"],"categories":["题解","CF"]},{"title":"CF 1843E - Tracking Segments题解","url":"/post/286725000.html","content":"<center> CF 1843E - Tracking Segments题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1843/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201843E.png)\n\n#### Sample Input\n\n```\n6\n5 5\n1 2\n4 5\n1 5\n1 3\n2 4\n5\n5\n3\n1\n2\n4\n4 2\n1 1\n4 4\n2\n2\n3\n5 2\n1 5\n1 5\n4\n2\n1\n3\n4\n5 2\n1 5\n1 3\n5\n4\n1\n2\n3\n5\n5 5\n1 5\n1 5\n1 5\n1 5\n1 4\n3\n1\n4\n3\n3 2\n2 2\n1 3\n3\n2\n3\n1\n```\n\n#### Sample Output\n\n```\n3\n-1\n3\n3\n3\n1\n```\n\n#### 解析：\n\n二分题。\n\n假设前 $i$ 个下标所在的值为 $1$ 且此时存在至少一个线段满足条件，则 前 $i+1$ 个下标所在的值为 $1$ 时，一定存在至少一个线段满足条件。\n\n由此，我们可以二分前 $x$ 个下标。\n\n二分出来赋值后只要有一个线段符合要求即可。\n\n$-1$ 的情况就是所有 $q$ 个值为 $1$ 但是没有线段符合要求。\n\n复杂度 $O(nlogq)$。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n, m, q, a[N], b[N], sum[N];\nstruct Segment {\n  int l, r;\n}line[N];\nvoid solve() {\n  std :: cin >> n >> m;\n  for(int i = 1; i <= m; ++ i) {\n    std :: cin >> line[i].l >> line[i].r;\n  }\n  std :: cin >> q;\n  for(int i = 1; i <= q; ++ i) {\n    std :: cin >> a[i];\n  }\n\n  auto check = [](int x) -> bool {\n    for(int i = 1; i <= n; ++ i) {\n      b[i] = 0;\n    }\n    for(int i = 1; i <= x; ++ i) {\n      b[a[i]] = 1;\n    }\n    for(int i = 1; i <= n; ++ i) {\n      sum[i] = sum[i-1] + b[i];\n    }\n    for(int i = 1; i <= m; ++ i) {\n      if(sum[line[i].r] - sum[line[i].l-1] > (line[i].r - line[i].l + 1) / 2) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  if(!check(q)) {\n    std :: cout << -1 << '\\n';\n    return ;\n  }\n\n  int l = 1, r = q, ans;\n  while(l <= r) {\n    int mid = (l + r) >> 1;\n    if(check(mid)) {\n      r = mid - 1;\n      ans = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  std :: cout << ans << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 1856C - To Become Max题解","url":"/post/3742054483.html","content":"<center> CF 1856C - To Become Max题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1856/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201856C.png)\n\n#### Sample Input\n\n```\n6\n3 4\n1 3 3\n5 6\n1 3 4 5 1\n4 13\n1 1 3 179\n5 3\n4 3 2 2 2\n5 6\n6 5 4 1 5\n2 17\n3 5\n```\n\n#### Sample Output\n\n```\n4\n7\n179\n5\n7\n6\n```\n\n#### 解析：\n\n二分题目。\n\n二分出一个最大值，然后枚举所有位置使之成为最大值。\n\n然后向后面修改值，看修改次数够不够即可。\n\n注意，假设 $x$ 为二分出的最大值，则只需要满足该序列即可：$x, x - 1, x - 2, x - 3, \\dots$ 。\n\n由于 $n$ 只有 $1000$ 所以复杂度是 $O(n^2log(2e8))$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nint a[N], b[N], n, k, ans;\nvoid solve() {\n  std :: cin >> n >> k;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n  }\n  \n  auto check = [=](int x) -> bool {\n    for(int i = 1; i <= n; ++ i) {\n      for(int j = 1; j <= n; ++ j) {\n        b[j] = a[j];\n      }\n      if(a[i] >= x) return true;\n      if(k - (x - a[i]) < 0) continue;\n      int res = k - (x - a[i]), y = x; y --;\n      for(int j = i + 1; j <= n; ++ j) {\n        if(b[j] >= y) return true;\n        res -= (y - b[j]); y --;\n        if(res < 0) break;\n      }\n    }\n    return false;\n  };\n\n  int l = 1, r = 2e8, ans;\n  while(l <= r) {\n    int mid = (l + r) >> 1;\n    if(check(mid)) {\n      l = mid + 1;\n      ans = mid;\n    } else {\n      r = mid - 1;\n    }\n  }\n  std :: cout << ans << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 1610C - Keshi Is Throwing a Party题解","url":"/post/4048825420.html","content":"<center> CF 1610C - Keshi Is Throwing a Party题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1610/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201610C.png)\n\n#### Sample Input\n\n```\n3\n3\n1 2\n2 1\n1 1\n2\n0 0\n0 1\n2\n1 0\n0 1\n```\n\n#### Sample Output\n\n```\n2\n1\n2\n```\n\n#### 解析：\n\n这个题是借鉴了题解。\n\n脑子里想到了可以用二分去做，但是没有想出一个优秀的 $check$ 方法。\n\n借鉴了题解后，觉得还是很妙的。\n\n首先，二分的是最多能选的人数。\n\n然后在 $check$ 函数中，进行如下操作。\n\n设 $res$ 为当前位置 $i$ 以前已选的人数，即选了的比当前人 $i$ 还穷的人。\n\n设 $x$ 为二分出的选择人数。\n\n如果一定可以选择当前这个人 $i$ ，需要满足以下两个条件。\n\n1.  $res \\leq b[i]$\n2.  $x - res - 1 \\leq a[i]$\n\n即， $x - a[i] + 1 \\leq res \\leq b[i]$ 。\n\n如此扫一遍记录个数与 $x$ 作比较即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n;\nstruct Node {\n  int a, b;\n}a[N];\nvoid solve() {\n  std :: cin >> n;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i].a >> a[i].b;\n  }\n\n  auto check = [=](int x) -> bool {\n    int res = 0;\n    for(int i = 1; i <= n; ++ i) {\n      if(x - a[i].a - 1 <= res && res <= a[i].b) res ++;\n    }\n    return x <= res;\n  }; \n\n  int l = 1, r = n, ans;\n  while(l <= r) {\n    int mid = (l + r) >> 1;\n    if(check(mid)) {\n      ans = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  std :: cout << ans << '\\n';\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 559A - Gerald's Hexagon题解","url":"/post/2251078398.html","content":"<center> CF 559A - Gerald's Hexagon题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/559/A)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20559A.png)\n\n#### Sample Input\n\n```\n1 2 1 2 1 2\n```\n\n#### Sample Output\n\n```\n13\n```\n\n#### 解析：\n\n一个数学题目。\n\n这个题我是借助面积进行求解。\n\n首先设六边形的面积为 $S$ ，一个小的正三角形面积为 $\\frac{\\sqrt{3}}{4}$，则答案就是 $\\frac{4S}{\\sqrt{3}}$ 。\n\n现在有一个六边形，我要求它的面积，假设六边形长这样。\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20559A%E9%85%8D%E5%9B%BE.png)\n\n那么很显然就能推出他的面积，为\n\n$$\nS = (a[1] + \\frac{a[2] + a[6]}{2}) \\times \\frac{(a[2] + a[3])\\sqrt{3}}{2} - \\frac{(a[2]^2 + a[3]^2 + a[5]^2+a[6]^2) \\sqrt{3}}{8}\n$$\n\n则最终答案​ $ans = \\frac{4S}{\\sqrt{3}}$\n\n$$\nans = 2 \\times (a[1] + \\frac{a[2] + a[6]}{2}) \\times (a[2] + a[3]) - \\frac{a[2]^2 + a[3]^2 + a[5]^2+a[6]^2}{2}\n$$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n  int n = 6;\n  double a[7];\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> a[i];\n  }\n  printf(\"%d\", int(2 * (a[1] + (a[2] + a[6]) / 2) * (a[2] + a[3]) - (\n    a[2] * a[2] + a[3] * a[3] + a[5] * a[5] + a[6] * a[6]\n  ) / 2)); \n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  //std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["数学"],"categories":["题解","CF"]},{"title":"CF 1151B - Dima and a Bad XOR题解","url":"/post/2282769078.html","content":"<center> CF 1151B - Dima and a Bad XOR题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1151/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201151B.png)\n\n#### Sample Input\n\n```\n2 3\n7 7 7\n7 7 10\n```\n\n#### Sample Output\n\n```\nTAK\n1 3 \n```\n\n#### 解析：\n\n面对异或的题目，我们是比较喜欢拆分成二进制观察每一位的情况的。\n\n这个题中 $a_{i,j}$ 的范围比较小，只有 $[0,1023]$ ，所以更容易想到按照每一个二进制位来看。\n\n很显然我们可以遍历每一个二进制位 $k$ ，观察每一行的数字情况，对于每一行来说，有三种情况。\n\n1. 当前行在 $k$ 上均为 $1$ 。\n2. 当前行在 $k$ 上均为 $0$ 。\n3. 当前行在 $k$ 上有 $0$ 也有 $1$ 。\n\n对于当前位 $k$ 来说，有解的情况就是保证有 $k$ 位为 $1$ 的行数为奇数。\n\n也是有两种情况，一是行上所有数 $k$ 位是 $1$ 的行数是奇数，二是行上有 $0$ 也有 $1$ 的行数大于 $1$ 。\n\n如果行上所有数 $k$ 位是 $1$ 的行数是偶数而且行上有 $0$ 也有 $1$ 的行数为 $0$ ，显然就是无解。\n\n那我们就按照有解的情况分配一下哪些行取 $k$ 位为 $1$ 的数，哪些行取 $k$ 位为 $0$ 的数即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\nint a[N][N], n, m;\nvoid solve() {\n  std :: cin >> n >> m;\n  for(int i = 1; i <= n; ++ i) {\n    for(int j = 1; j <= m; ++ j) {\n      std :: cin >> a[i][j];\n    }\n  }\n  for(int k = 0; k < 10; ++ k) {\n    int res0 = 0, res1 = 0;\n    for(int i = 1; i <= n; ++ i) {\n      int maxx = 1 << k, fg1 = 0, fg0 = 0;\n      for(int j = 1; j <= m; ++ j) {\n        if(a[i][j] & maxx) fg1 = 1;\n        else fg0 = 1;\n      }\n      res0 += (fg1 == 0); res1 += (fg0 == 0);\n    }\n    if(res0 + res1 < n || (res0 + res1 == n && res1 & 1)) {\n      std :: cout << \"TAK\\n\";\n      for(int i = 1; i <= n; ++ i) {\n        int maxx = 1 << k, fg1 = 0, fg0 = 0;\n        for(int j = 1; j <= m; ++ j) {\n          if(a[i][j] & maxx) fg1 = 1;\n          else fg0 = 1;\n        }\n        if(fg0 == 0 || fg1 == 0) {\n          std :: cout << 1 << ' ';\n        } \n        else {\n          for(int j = 1; j <= m; ++ j) {\n            if((maxx & a[i][j]) && !(res1 & 1)) {\n              std :: cout << j << ' ';\n              res1 ++;\n              break;\n            } else if(!(maxx & a[i][j]) && (res1 & 1)){\n              std :: cout << j << ' ';\n              break;\n            }\n          }\n        }\n      }\n      return ;\n    }\n  }\n  std :: cout << \"NIE\";\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  //std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["位运算","模拟"],"categories":["题解","CF"]},{"title":"CF 1469C - Building a Fence题解","url":"/post/853121289.html","content":"<center> CF 1469C - Building a Fence题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1469/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201469C.png)\n\n#### Sample Input\n\n```\n3\n6 3\n0 0 2 5 1 1\n2 3\n0 2\n3 2\n3 0 2\n```\n\n#### Sample Output\n\n```\nYES\nYES\nNO\n```\n\n#### 解析：\n\n一个简单的模拟题。\n\n按照题意模拟，用两个指针来决定当前位置的栅栏放置的范围。\n\n对于当前位置 $i$ 来说，设前一个栅栏的范围是 $[low, high]$。\n\n则当前位置最高是 $high = min(high + k - 1,h[i] + k - 1 + k)$。\n\n$high + k - 1$ 比较好理解，就是上一个最高范围的向上放置。\n\n$h[i] + k - 1 + k$ 的话就是对于当前地高 $h[i]$ ，那么栅栏不得高出 $k-1$ ，于是要栅栏最高，则栅栏高地面 $k - 1$ ，自身又有高度 $k$ 。\n\n当前位置最低是 $low = max(h[i], low - k + 1)$。\n\n$h[i]$ 比较好理解，就是地面高度。\n\n$low - k + 1$ 与上文的 $high + k - 1$ 差不多意思，不再赘述。\n\n更新完当前的 $low, high$ 后就要判断是否合法。\n\n很显然如果 $high - low < k$ 则就放不下一个栅栏，即不合法。\n\n最后还要看最后一个位置的栅栏是否能贴地即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, k, h[N];\nvoid solve() {\n  std :: cin >> n >> k;\n  for(int i = 1; i <= n; ++ i) {\n    std :: cin >> h[i];\n  }\n  int low = h[1], high = h[1] + k;\n  for(int i = 2; i <= n; ++ i) {\n    low = std :: max(low - k + 1, h[i]);\n    high = std :: min(high + k - 1, h[i] + k - 1 + k);\n    if(high - low < k || (i == n && low != h[i])) {\n      std :: cout << \"NO\\n\";\n      return ;\n    }\n  }\n  std :: cout << \"YES\\n\";\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n  std :: ios :: sync_with_stdio(false);\n  std :: cin.tie(0);\n  std :: cout.tie(0);\n  int T = 1;\n  std :: cin >> T; \n  while(T --) solve();\n  return 0;\n}\n```","tags":["模拟"],"categories":["题解","CF"]},{"title":"CF 1623C - Balanced Stone Heaps题解","url":"/post/1125144912.html","content":"<center> CF 1623C - Balanced Stone Heaps题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1623/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201623C.png)\n#### Sample Input\n\n```\n4\n4\n1 2 10 100\n4\n100 100 100 1\n5\n5 1 1 1 8\n6\n1 2 3 4 5 6\n```\n\n#### Sample Output\n\n```\n7\n1\n1\n3\n```\n\n#### 解析：\n\n显然二分。\n\n题目中说从左向右扫石子堆向左分配，对于当前石子堆 $i$ 来说，当它的石子个数小于二分出的个数时，它面临既可能向左分配石子，又可能有右边石子向它分配的场面，这是比较难判断到底向左边分配多少石子。\n\n所以，我考虑从右向左枚举石子堆。\n\n对于当前石子堆 $j$ 来说，有两个参数，$res[j]$ 表示一开始石子堆 $j$ 所拥有的石子个数， $temp[j]$ 表示石子堆从右边获得的石子个数。\n\n现在，如果说 $res[j] + temp[j] < mid$ ，显然，二分的值过大。\n\n反之，就考虑当前石子堆 $j$ 要向左边分配多少石子，很显然，分两种情况讨论。\n\n1. $temp[j] >= x$\n\n   可以把 $res[j]$ 全部奉献出去。\n\n2. $temp[j] < x$\n\n   只能奉献 $res[j]$ 的一部分，即 $res[j] + temp[j] - mid$。\n\n综上，对于当前石子堆 $j$ 来说，要向左分配 $min(res[j], res[j] + temp[j] - mid)$ 。\n\n最后检查一下每个位置即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint h[N], n;\nvoid solve() {\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i) {\n        std :: cin >> h[i];\n    }\n\n    auto check = [&](int x) -> bool{\n        std :: vector <int> res(n + 1), temp(n + 1);\n        for(int i = 1; i <= n; ++ i) {\n            res[i] = h[i]; temp[i] = 0;\n        }\n        for(int i = n; i >= 3; -- i) {\n            if(res[i] + temp[i] > x) {\n                int d = std :: min(res[i], temp[i] + res[i] - x) / 3;\n                res[i] -= d * 3;\n                temp[i-1] += d;\n                temp[i-2] += d * 2;\n            }\n        }\n        for(int i = 1; i <= n; ++ i) {\n            if(temp[i] + res[i] < x) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    int l = 1, r = Range, ans;\n    while(l <= r) {\n        int mid = (l + r) >> 1;\n        if(check(mid)) {\n            ans = mid;\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    std :: cout << ans << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 601A - The Two Routes题解","url":"/post/1861038821.html","content":"<center> CF 601A - The Two Routes题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/601/A)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20601A.png)\n\n#### Sample Input\n\n```\n5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n```\n\n#### Sample Output\n\n```\n3\n```\n\n#### 解析：\n\n任何城镇之间一定有马路或者铁路，也就意味着 $1$ 和 $n$ 之间一定有铁路或者公路。\n\n那么就可以分开讨论。\n\n如果 $1$ 到 $n$ 之间有马路，则用铁路求最短路；反之，用马路求。 \n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl '\\n'\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 410;\nint n, m;\nint road[N][N], rail[N][N];\nvoid solve() {\n  std :: cin >> n >> m;\n  for(int i = 1; i <= n; ++ i) {\n    for(int j = 1; j <= n; ++ j) {\n      road[i][j] = (i == j ? INF : 1);\n      rail[i][j] = INF;\n    }\n  }\n  for(int i = 1; i <= m; ++ i) {\n    int u, v;\n    std :: cin >> u >> v;\n    rail[u][v] = rail[v][u] = 1;\n    road[u][v] = road[v][u] = INF;\n  }\n  if(road[1][n] == 1) {\n    for(int k = 1; k <= n; ++ k) {\n      for(int i = 1; i <= n; ++ i) {\n        if(i == k) continue;\n        for(int j = 1; j <= n; ++ j) {\n          if(j == k || i == j) continue;\n          rail[i][j] = std :: min(rail[i][j], rail[i][k] + rail[k][j]);\n        }\n      }\n    }\n    std :: cout << (rail[1][n] == INF ? -1 : rail[1][n]);\n  } else {\n    for(int k = 1; k <= n; ++ k) {\n      for(int i = 1; i <= n; ++ i) {\n        if(i == k) continue;\n        for(int j = 1; j <= n; ++ j) {\n          if(j == k || i == j) continue;\n          road[i][j] = std :: min(road[i][j], road[i][k] + road[k][j]);\n        }\n      }\n    }\n    std :: cout << (road[1][n] == INF ? -1 : road[1][n]);\n  }\n}\nint main() {\n  //freopen(\"1.in\", \"r\", stdin);\n  //freopen(\"1.out\", \"w\", stdout);\n   std :: ios :: sync_with_stdio(false);\n   std :: cin.tie(0);\n   std :: cout.tie(0);\n  int T = 1;\n   //std :: cin >> T; \n   while(T --) solve();\n   return 0;\n}\n```","tags":["最短路","Floyd算法"],"categories":["题解","CF"]},{"title":"CF 1730B - Meeting on the Line题解","url":"/post/2210389757.html","content":"<center> CF 1730B - Meeting on the Line题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1730/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201730B.png)\n\n#### Sample Input\n\n```\n7\n1\n0\n3\n2\n3 1\n0 0\n2\n1 4\n0 0\n3\n1 2 3\n0 0 0\n3\n1 2 3\n4 1 2\n3\n3 3 3\n5 3 3\n6\n5 4 7 2 10 4\n3 2 5 1 4 6\n```\n\n#### Sample Output\n\n```\n0\n2\n2.5\n2\n1\n3\n6\n```\n\n#### 解析：\n\n首先，枚举位置肯定是行不通的。\n\n看着范围这么大，很容易想到二分，但是二分位置也是不合理的。\n\n所以，我们可以考虑二分时间，然后反推位置。\n\n思路很简单，二分出时间后，取到所有人活动的范围，然后取一个交集即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst double Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n;\ndouble a[N], t[N], ans;\nbool check(double x) {\n    double l = 0, r = Range;\n    for(int i = 1; i <= n; ++ i) {\n        if(x <= t[i]) {\n            l = std :: max(l, a[i]);\n            r = std :: min(r, a[i]);\n        } else {\n            l = std :: max(l, a[i] - (x - t[i]));\n            r = std :: min(r, a[i] + (x - t[i]));\n        }\n    }\n    ans = l;\n    return l <= r;\n}\nvoid solve() {\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> t[i];\n    double l = 0, r = Range;\n    while(r - l >= eps) {\n        double mid = (l + r) / 2;\n        if(check(mid)) r = mid;\n        else l = mid;\n    }\n    printf(\"%.6lf\\n\", ans);\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 1217B - Zmei Gorynich题解","url":"/post/2254919326.html","content":"<center> CF 1217B - Zmei Gorynich题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1217/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201217B.png)\n\n#### Sample Input\n\n```\n3\n3 10\n6 3\n8 2\n1 4\n4 10\n4 1\n3 2\n2 6\n1 100\n2 15\n10 11\n14 100\n```\n\n#### Sample Output\n\n```\n2\n3\n-1\n```\n\n#### 解析：\n\n贪心题。\n\n设需要 $x$ 次就能全部清除。\n\n则前 $x - 1$ 次一定是选择 $d[i] - h[i]$ 最大的 $i$ ，设 $res = max\\{ d[i] - h[i] \\}$。\n\n最后一次就应该选择 $d[i]$ 最大的 $i$ 。\n\n则有式子 $(x - 1)res + max\\{d[i]\\} \\ge CurX$\n\n转化，得 $x \\ge \\frac{CurX - max\\{d[i]\\} + res}{res}$ ，上取整即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 110;\nint n, m, h[N], d[N];\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> d[i] >> h[i];\n    bool flag = 0;\n    for(int i = 1; i <= n; ++ i)\n        if(d[i] > h[i] || d[i] >= m) {\n            flag = 1; break;\n        }\n    if(!flag) {\n        std :: cout << -1 << '\\n';\n        return ;\n    }\n    int maxx = 0, res = 0;\n    for(int i = 1; i <= n; ++ i)\n        maxx = std :: max(maxx, d[i]);\n    if(maxx >= m) {\n        std :: cout << \"1\\n\";\n        return ;\n    }\n    for(int i = 1; i <= n; ++ i) \n        res = std :: max(res, d[i] - h[i]);\n    std :: cout << (int)ceil((m + res - maxx) * 1.00 / res) << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心","数学"],"categories":["题解","CF"]},{"title":"CF 1213D2 - Equalizing by Division (hard version)题解","url":"/post/2269445315.html","content":"<center> CF 1213D2 - Equalizing by Division (hard version)题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1213/D2)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201213D2.png)\n\n#### Sample Input\n\n```\n5 3\n1 2 2 4 5\n```\n\n#### Sample Output\n\n```\n1\n```\n\n#### 解析：\n\n贪心题。\n\n首先将 $a$ 数组从小到大排序，然后对于每一个元素都进行不断除以 $2$ 并记录个数的操作。\n\n当某一个数的个数到 $k$ 时，取一个最小值即可。\n\n综合复杂度是 $O(nlogn)$。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, k, a[N], cnt[N];\ni64 sum[N], ans = LLINF;\nvoid solve() {\n    std :: cin >> n >> k;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    std :: sort(a + 1, a + 1 + n);\n    for(int i = 1; i <= n; ++ i) {\n        int res = a[i], num = 0;\n        cnt[res] ++;\n        if(cnt[res] == k)\n            ans = std :: min(ans, sum[res]);\n        while(res != 0) {\n            res >>= 1; num ++;\n            cnt[res] ++; sum[res] += num;\n            if(cnt[res] == k) \n                ans = std :: min(ans, sum[res]);\n        }\n    }\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1593E - Gardener and Tree题解","url":"/post/2866798842.html","content":"<center> CF 1593E - Gardener and Tree题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1593/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201593E.png)\n\n#### Sample Input\n\n```\n6\n\n14 1\n1 2\n2 3\n2 4\n4 5\n4 6\n2 7\n7 8\n8 9\n8 10\n3 11\n3 12\n1 13\n13 14\n\n2 200000\n1 2\n\n3 2\n1 2\n2 3\n\n5 1\n5 1\n3 2\n2 1\n5 4\n\n6 2\n5 1\n2 5\n5 6\n4 2\n3 4\n\n7 1\n4 3\n5 1\n1 3\n6 1\n1 7\n2 1\n```\n\n#### Sample Output\n\n```\n7\n0\n0\n3\n1\n2\n```\n\n#### 解析：\n\n很显然的一点，就是，最后一个点或者两个点一定是在直径上的，且这一两个点一定是树的根。\n\n为什么？因为树的直径是最长的，消除的话一定直径的两端开始。\n\n现在，我们就能找到树的根，就是树的直径的中间一个（直径长为奇数）或者两个（直径长为偶数）。\n\n找到了根，就可以更新每个点的层级。\n\n利用前缀和，可以算出前 $i$ 层点的个数。\n\n然后再根据 $k$ 和根的层级比较计算出答案。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 4e5 + 20;\nint head[N], deg[N], sum[N], dis[N], dep[N];\nint n, k, cnt;\nstruct Edge {\n    int to, net;\n}e[N << 1];\n\ninline void init() {\n    cnt = 0;\n    std :: fill(head, head + 1 + n, 0);\n    std :: fill(deg, deg + 1 + n, 0);\n    std :: fill(sum, sum + 1 + n, 0);\n    std :: fill(dis, dis + 1 + n, 0);\n    std :: fill(dep, dep + 1 + n, 0);\n}\n\ninline void Insert(int u, int v) {\n    e[++cnt] = {v, head[u]};\n    head[u] = cnt;\n}\n\nvoid dfs(int u) {\n    for(int i = head[u]; i; i = e[i].net) {\n        int v = e[i].to;\n        if(dis[v]) continue;\n        dis[v] = dis[u] + 1;\n        dfs(v);\n    }\n}\n\nint calc(int u, int fa) {\n    if(deg[u] == 1) {\n        dep[u] = 1;\n        sum[1] ++;\n        return 1;\n    }\n    for(int i = head[u]; i; i = e[i].net) {\n        int v = e[i].to;\n        if(v == fa) continue;\n        dep[u] = std :: max(dep[u], calc(v, u) + 1);\n    }\n    sum[dep[u]] ++;\n    return dep[u];\n}\n\nvoid solve() {\n    std :: cin >> n >> k; init();\n    for(int i = 1; i < n; ++ i) {\n        int u, v; std :: cin >> u >> v;\n        Insert(u, v); Insert(v, u);\n        deg[u] ++; deg[v] ++;\n    }\n\n    dis[1] = 1; dfs(1);\n    int v, maxx = 0;\n    for(int i = 1; i <= n; ++ i)\n        if(maxx < dis[i]) maxx = dis[i], v = i;\n\n    std :: fill(dis + 1, dis + 1 + n, 0);\n    dis[v] = 1; dfs(v); maxx = 0;\n    for(int i = 1; i <= n; ++ i)\n        if(maxx < dis[i]) maxx = dis[i], v = i;\n\n    std :: vector <int> L;\n    L.push_back(v);\n    while(1) {\n        bool flag = 0;\n        for(int i = head[v]; i; i = e[i].net) {\n            int x = e[i].to;\n            if(dis[x] == dis[v] - 1) {\n                L.push_back(x); v = x; flag = 1;\n                break;\n            }\n        }\n        if(!flag) break;\n    }\n\n    int m = L.size(), rt = 1, rt1 = 1, rt2 = n;\n    if(m & 1) {\n        rt = L[m>>1];\n        calc(rt, rt);\n        if(k >= dep[rt]) {\n            std :: cout << 0 << '\\n';\n            return ;\n        }\n        for(int i = 1; i <= dep[rt]; ++ i)\n            sum[i] = sum[i-1] + sum[i];\n        std :: cout << n - sum[k] << '\\n';\n    } else {\n        rt1 = L[(m>>1)-1], rt2 = L[m>>1];\n        calc(rt1, rt2); calc(rt2, rt1);\n        if(k >= dep[rt1]) {\n            std :: cout << \"0\\n\";\n            return ;\n        }\n        for(int i = 1; i <= dep[rt1]; ++ i)\n            sum[i] = sum[i-1] + sum[i];\n        std :: cout << n - sum[k] << '\\n';\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["前缀和","树的直径"],"categories":["题解","CF"]},{"title":"CF 1779C - Least Prefix Sum题解","url":"/post/779213514.html","content":"<center> CF 1779C - Least Prefix Sum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1779/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201779C.png)\n\n#### Sample Input\n\n```\n6\n4 3\n-1 -2 -3 -4\n4 3\n1 2 3 4\n1 1\n1\n5 5\n-2 3 -5 1 -20\n5 2\n-2 3 -5 -5 -20\n10 4\n345875723 -48 384678321 -375635768 -35867853 -35863586 -358683842 -81725678 38576 -357865873\n```\n\n#### Sample Output\n\n```\n1\n1\n0\n0\n3\n4\n```\n\n#### 解析：\n\n一道比较显然的贪心题。\n\n这个要分段去考虑。\n\n1. $sum[x] > sum[m] 且 x \\leq m$\n\n因为 $sum[x]$ 是 $sum[m]$ 的前缀，则改变 $[1, x]$ 的值无意义，对于 $sum[x]$ 和 $sum[m]$ 的差值不影响。\n\n所以我们只能改变 $[x+1,m]$ 内的数字，最优的方案一定是改变这个区间内最大的正数。\n\n2. $sum[x] > sum[m] 且 x > m$\n\n因为 $sum[m]$ 是 $sum[x]$ 的前缀，所以改变 $[1, m]$ 的值无意义。\n\n考虑改变 $[m+1, x]$ 内的值，最优的方案是改变区间内 最小的负数。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int n, m, ans = 0; std :: cin >> n >> m;\n    std :: vector <int> a(n + 1);\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    std :: priority_queue <int> q;\n    i64 res = 0;\n\n    for(int i = m; i > 1; -- i) {\n        res += a[i];\n        q.push(a[i]);\n        if(res > 0) {\n            res -= q.top() * 2;\n            ans ++; q.pop();\n        }\n    }\n\n    res = 0;\n    std :: priority_queue <i64, std :: vector <i64>, std :: greater <i64> > p;\n    for(int i = m + 1; i <= n; ++ i) {\n        res += a[i];\n        p.push(a[i]);\n        if(res < 0) {\n            res -= p.top() * 2;\n            ans ++; p.pop();\n        }\n    }\n    std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1294D - MEX maximizing题解","url":"/post/2398711314.html","content":"<center> CF 1294D - MEX maximizing题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1294/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201294D.png)\n\n#### Sample Input\n\n```\n7 3\n0\n1\n2\n2\n0\n0\n10\n```\n\n#### Sample Output\n\n```\n1\n2\n3\n3\n4\n4\n7\n```\n\n#### 解析：\n\n由于 $a_i$ 可以转化为 $a_i \\pm x$ ，所以我们可以很显然的转化为取模的问题，模数为 $x$ 。\n\n设某一个数取完模后是 $z$ ，在本题中我使用线段树维护，所以 $z \\in [1, x]。$\n\n很显然，他可以转化为 $x + z, x + 2z, \\dots , x + nz(n = 0, 1, 2, \\dots )$。\n\n我们就可以看，当前为第 $i(i从0开始)$ 个数，则前 $i \\% x + 1$ 的数每个数的个数至少为 $i / x + 1。$\n\n如果最小的小于这个数，则找出最少的那个数的下标 $r(r从1开始)$, 个数 $res$，答案即为 $res \\times x + r - 1$。\n\n从 $i \\% x + 2$ 到 $x$ 的数每个数的个数至少为 $i / x$。\n\n否则，同上。\n\n最小值和查询下标使用线段树维护即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 4e5 + 20;\nstruct Node {\n    int l, r, minn, id;\n}t[N<<2];\nint n, m;\nvoid pushUp(int k) {\n    if(t[ls].minn <= t[rs].minn) t[k].minn = t[ls].minn, t[k].id = t[ls].id;\n    else t[k].minn = t[rs].minn, t[k].id = t[rs].id;\n}\nvoid build(int l, int r, int k) {\n    t[k].l = l; t[k].r = r;\n    if(l == r) {\n        t[k].id = l;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(l, mid, ls); build(mid + 1, r, rs);\n    pushUp(k);\n}\nvoid modify(int k, int x) {\n    if(t[k].l == t[k].r) {\n        t[k].minn ++;\n        return ;\n    }\n    int mid = (t[k].l + t[k].r) >> 1;\n    if(x <= mid) modify(ls, x);\n    else modify(rs, x);\n    pushUp(k);\n}\nint query(int l, int r, int k) {\n    if(l <= t[k].l && t[k].r <= r) return t[k].minn;\n    int mid = (t[k].l + t[k].r) >> 1, minn = INF;\n    if(l <= mid) minn = std :: min(minn, query(l, r, ls));\n    if(r > mid) minn = std :: min(minn, query(l, r, rs));\n    return minn;\n}\nint find(int l, int r, int k, int x) {\n    if(t[k].l >= l && t[k].r <= r) {\n        if(t[k].minn == x) return t[k].id;\n        return INF;\n    }\n    int mid = (t[k].l + t[k].r) >> 1, id = INF;\n    if(l <= mid) id = std :: min(id, find(l, r, ls, x));\n    if(r > mid) id = std :: min(id, find(l, r, rs, x));\n    return id;\n}\nvoid solve() {\n    std :: cin >> n >> m;\n    build(1, m, 1);\n    for(int i = 0; i < n; ++ i) {\n        int x, ans = i + 1; std :: cin >> x;\n        modify(1, x % m + 1);\n        int y = i % m + 1;\n        int z = i / m;\n        z ++;\n        int res = query(1, y, 1), r;\n        if(res < z) {\n            r = find(1, y, 1, res);\n            ans = res * m + r - 1;\n        }\n        if(y != m) {\n            z --;\n            res = query(y + 1, m, 1);\n            if(res < z) {\n                r = find(y + 1, m, 1, res);\n                ans = std :: min(ans, res * m + r - 1);\n            }\n        }\n        std :: cout << ans << '\\n';\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["线段树"],"categories":["题解","CF"]},{"title":"CF 1395D - Boboniu Chats with Du题解","url":"/post/3518355615.html","content":"<center> CF 1395D - Boboniu Chats with Du题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1395/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201395D.png)\n\n#### Sample Input\n\n```\n20 2 16\n20 5 8 2 18 16 2 16 16 1 5 16 2 13 6 16 4 17 21 7\n```\n\n#### Sample Output\n\n```\n195\n```\n\n#### 解析：\n\n一个很显然的贪心，但是我贪心没过。。。\n\n换了个做法，由于 $a[i] > m$ 的个数最多为 $n$ 个，所以我们不妨枚举要选的 $a[i] > m$ 的个数。\n\n然后，根据 $a[i] > m$ 的个数推出 $a[i] \\leq m$ 的个数，计算出结果取最大值即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\n#define int long long\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nint n, d;\ni64 m;\nvoid solve() {\n    std :: cin >> n >> d >> m;\n    std :: vector <i64> a(n), low, high;\n    for(int i = 0; i < n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 0; i < n; ++ i)\n        if(a[i] > m) high.push_back(a[i]);\n        else low.push_back(a[i]);\n    std :: sort(low.rbegin(), low.rend());\n    std :: sort(high.rbegin(), high.rend());\n\n    int l = low.size(), r = high.size();\n\n    std :: vector <i64> sa(l+1), sb(r+1);\n    for(int i = 1; i <= l; ++ i)\n        sa[i] = sa[i-1] + low[i-1];\n    for(int i = 1; i <= r; ++ i)\n        sb[i] = sb[i-1] + high[i-1];\n\n    i64 ans = sa[l];\n\n    for(int i = 1; i <= r; ++ i) {\n        int res = (i - 1) * (d + 1) + 1;\n\n        if(res > n) break;\n\n        res = n - res;\n        ans = std :: max(ans, sb[i] + sa[std :: min(res, l)]);\n    }\n\n    std :: cout << ans;\n}\nsigned main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心","枚举","暴力"],"categories":["题解","CF"]},{"title":"CF 1251C - Minimize The Integer题解","url":"/post/1232871816.html","content":"<center> CF 1251C - Minimize The Integer题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1251/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201251C.png)\n\n#### Sample Input\n\n```\n3\n0709\n1337\n246432\n```\n\n#### Sample Output\n\n```\n0079\n1337\n234642\n```\n\n#### 解析：\n\n很显然一点就是，奇数最多移动到相邻的偶数段的另一端；偶数最多移动到相邻的奇数段的另一端。\n\n我们可以从开头开始，对于当前位，设为奇数，看后面离他最近的偶数是否小于它，若小于，则就放在当前奇数前面；偶数亦然。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst i64 LLINF = 0x3f3f3f3f3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nstruct Node {\n    char num;\n    int pos;\n};\nvoid solve() {\n    std :: string str; std :: cin >> str;\n    str = \"0\" + str; int n = str.length() - 1;\n    std :: vector <Node> even, odd;\n    std :: vector <char> ans;\n    for(int i = 1; i <= n; ++ i)\n        if(str[i] % 2 == 0) even.push_back({str[i], i});\n        else odd.push_back({str[i], i});\n        \n    if(odd.empty() || even.empty()) {\n        for(int i = 1; i <= n; ++ i)\n            std :: cout << str[i];\n        std :: cout << '\\n';\n        return ;\n    }\n    std :: vector <bool> vis(n+1, 0);\n    int l = 0, r = 0, p = 1;\n    for(int i = 1; i <= n; ++ i) {\n        if(vis[i]) continue; p = i;\n        while(l < odd.size() - 1 && odd[l].pos <= i) l ++;\n        while(vis[odd[l].pos] == 1 && l < odd.size() - 1) l ++;\n        while(r < even.size() - 1 && even[r].pos <= i) r ++;\n        while(vis[even[r].pos] == 1 && r < even.size() - 1) r ++;\n        if(str[i] % 2 == 0) {\n             if(str[i] > odd[l].num && l < odd.size() && vis[odd[l].pos] == 0) {\n                 ans.push_back(odd[l].num);\n                 vis[odd[l].pos] = 1;\n                 i --;\n             }\n        } else {\n             if(str[i] > even[r].num && r < even.size() && vis[even[r].pos] == 0) {\n                 ans.push_back(even[r].num);\n                 vis[even[r].pos] = 1;\n                 i --;\n             }\n        }\n        if(p == i) ans.push_back(str[i]); vis[i] = 1;\n    }\n    for(auto x : ans)\n        std :: cout << x;\n    std :: cout << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1482C - Basic Diplomacy题解","url":"/post/2578431059.html","content":"<center> CF 1482C - Basic Diplomacy </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1482/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201482C.png)\n#### Sample Input\n\n```\n2\n4 6\n1 1\n2 1 2\n3 1 2 3\n4 1 2 3 4\n2 2 3\n1 3\n2 2\n1 1\n1 1\n```\n\n#### Sample Output\n\n```\nYES\n1 2 1 1 2 3 \nNO\n```\n\n#### 解析：\n\n贪心题。\n\n首先，要注意到一点，就是一共有 $m$ 天，总的选择的某一个朋友来的次数不能超过 $\\lceil \\frac{m}{2} \\rceil$\n\n则我们只需要找到某一个朋友出现的次数大于等于 $\\lceil \\frac{m}{2} \\rceil$ ，那么在 $\\lceil \\frac{m}{2} \\rceil$ 天中选择这个朋友，剩下的天数随便选。\n\n如果没有，那就不必要处理什么随便选就好了。\n\n需要注意的，可能存在某一天只能选择一个人的情况\n\n为了更合理，我们要按照每天选择的情况从小到大排序\n\n优先选择选择余地少的那天\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define PII std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int n, m;\n    std :: cin >> n >> m;\n    std :: map <int, int> g, f;\n    std :: vector <int> a[m + 1], ans(m + 1);\n    for(int i = 1; i <= m; ++ i) {\n        int k; std :: cin >> k;\n        for(int j = 1; j <= k; ++ j) {\n            int x; std :: cin >> x; a[i].push_back(x);\n            g[x] ++;\n        }\n    }\n    int pos = 0;\n    for(auto [x, y] : g)\n        if(y >= ceil((double)m / 2)) pos = x;\n    std :: priority_queue <PII> q;\n    for(int i = 1; i <= m; ++ i)\n        q.push({-a[i].size(), i});\n    int cnt = 0;\n    while(q.size()) {\n        int flag = 0;\n        if(cnt < ceil((double)m / 2))\n            for(auto x : a[q.top().second])\n                if(x == pos) {\n                    flag = 1;\n                    ans[q.top().second] = x; cnt ++; break;\n                }\n        if(flag == 0) {\n            for(auto x : a[q.top().second])\n                if(x != pos && f[x] <= ceil((double)m / 2)) {\n                    ans[q.top().second] = x;break;\n                }\n        }\n        q.pop();\n    }\n\n    for(int i = 1; i <= m; ++ i)\n        if(ans[i] == 0) {\n            std :: cout << \"NO\\n\";\n            return ;\n        }\n    std :: cout << \"YES\\n\";\n    for(int i = 1; i <= m; ++ i)\n        std :: cout << ans[i] << ' ';\n    std :: cout << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1555D - Say No to Palindromes题解","url":"/post/3531244015.html","content":"<center> CF 1555D - Say No to Palindromes题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1555/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201555D.png)\n#### Sample Input\n\n```\n5 4\nbaacb\n1 3\n1 5\n4 5\n2 3\n```\n\n#### Sample Output\n\n```\n1\n2\n0\n1\n```\n\n#### 解析：\n\n构造题。\n\n手玩几组样例，会发现当长度大于等于 $3$ 的时候，要想不是回文串，就必须是 $abcabc...$ 或 $acbacb...$ 等等 $6$ 种情况\n\n我们还会发现，这 $6$ 种串的情况也包含了长度在 $3$ 以内的。\n\n所以我们可以将原来的串改造成 $6$ 种串，然后取个最小值即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, m;\nstd :: string s = \"abc\", str;\nvoid solve() {\n    std :: cin >> n >> m >> str;\n    std :: vector dp(n + 1, std :: vector <int> (6));\n    int now = 0;\n    do {\n        for(int i = 0; i < n; ++ i)\n            dp[i+1][now] = dp[i][now] + (str[i] != s[i%3]);\n        now ++;\n    } while(std :: next_permutation(s.begin(), s.end()));\n    while(m --) {\n        int l, r; std :: cin >> l >> r;\n        int ans = INF;\n        for(int i = 0; i < 6; ++ i)\n            ans = std :: min(ans, dp[r][i] - dp[l-1][i]);\n        std :: cout << ans << '\\n';\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["构造题"],"categories":["题解","CF"]},{"title":"CF 322B - Ciel and Flowers题解","url":"/post/3066685154.html","content":"<center> CF 322B - Ciel and Flowers题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/322/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20322B.png)\n#### Sample Input\n\n```\n4 4 4\n```\n\n#### Sample Output\n\n```\n4\n```\n\n#### 解析：\n\n我们可以发现，混合花朵的数量可以不会超过 $2$ ，因为一旦超过 $2$ ，就一定能分解为相同数量的单色花朵。\n\n所以我们只需要看 $r,g,b$ 模完 $3$ 之后最多能组装出几个混合花朵即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int r, g, b;\n    std :: cin >> r >> g >> b;\n    int R = r % 3, G = g % 3, B = b % 3;\n    int cnt0 = ((R == 0) && (r > 0)) + ((G == 0) && (g > 0)) + ((B == 0) && (b > 0));\n    int cnt2 = (R == 2) + (G == 2) + (B == 2);\n    int ans = (r / 3) + (g / 3) + (b / 3)\n        + std :: min(r % 3, std :: min(g % 3, b % 3));\n    if(cnt0 + cnt2 == 3 && cnt0 > 0 && cnt2 > 0) ans = ans - cnt0 + 2;\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["思维题"],"categories":["题解","CF"]},{"title":"CF 1512E - Permutation by Sum题解","url":"/post/2781184933.html","content":"<center> CF 1512E - Permutation by Sum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1512/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201512E.png)\n#### Sample Input\n\n```\n5\n5 2 3 5\n5 3 4 1\n3 1 2 4\n2 2 2 2\n2 1 1 3\n```\n\n#### Sample Output\n\n```\n1 2 3 4 5 \n-1\n1 3 2 \n1 2 \n-1\n```\n\n#### 解析：\n\n首先肯定能排除查询值小于 $\\sum \\limits _{i=1} ^{r-l+1} {i}$ 或者大于 $\\sum \\limits _{i=n-r+l} ^{n} {i}$ 的。\n\n手玩几组样例会发现在 $1$ ~ $n$ 中挑选 $r-l+1$ 个数的和为 $sum$ ，则满足 $\\sum \\limits _{i=1} ^{r-l+1} {i} \\leq sum \\leq \\sum \\limits _{i=n-r+l} ^{n} {i}$，且 $sum$ 可以范围内**任何**一个整数。\n\n所以我们可以先找到第一个连续 $r-l+1$ 个值的和大于等于 $s$ 的段。\n\n如果相等可以直接输出。\n\n反之，假设多了 $d$ ，我们可以将该段的第 $d$ 个数换成该段的前一个数。\n\n例如， $n = 5,s = 6, r - l + 1 = 2$\n\n我们所找到的段为 $[3,4]$\n\n$d = 3 + 4 - 6 = 1$\n\n则将段的第一个数字 $3$ 换成段的前一个数字 $2$ 即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\nvoid solve() {\n    int n, l, r, s, m = N * (N + 1) / 2;\n    std :: cin >> n >> l >> r >> s;\n    std :: vector <int> sum(n + 1);\n    for(int i = 1; i <= n; ++ i)\n        sum[i] = sum[i-1] + i;\n    int len = r - l + 1;\n    if(sum[len] > s || sum[n] - sum[n-len] < s) {\n        std :: cout << -1 << '\\n';\n        return ;\n    }\n    int now = sum[len], ll = 1, rr = len;\n    while(now < s) {\n        now -= ll; now += rr + 1;\n        ll ++; rr ++;\n    }\n    std :: map <int, int> g;\n    if(s == now) {\n        for(int i = ll; i <= rr; ++ i)\n            g[i] = 1;\n    } else {\n        g[ll-1] = 1;\n        for(int i = ll; i <= rr; ++ i)\n            if(i != ll + now - s - 1) g[i] = 1;\n    }\n    int i = 0;\n    for(int k = 1; k <= n; ++ k) {\n        if(g[k] == 1) continue;\n        if(i == l - 1) break;\n        i ++; std :: cout << k << ' '; g[k] = -1;\n    }\n    for(int k = 1; k <= n; ++ k)\n        if(g[k] == 1)\n            std :: cout << k << ' ';\n    for(int k = 1; k <= n; ++ k)\n        if(g[k] == 0)\n            std :: cout << k << ' ';\n    std :: cout << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["思维题"],"categories":["题解","CF"]},{"title":"CF 1511D - Min Cost String题解","url":"/post/2493124995.html","content":"<center> CF 1511D - Min Cost String题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1511/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201511D.png)\n#### Sample Input\n\n```\n9 4\n```\n\n#### Sample Output\n\n```\naabacadbb\n```\n\n#### 解析：\n\n构造题\n\n按照题意可以这么构造，例如 `abcde`\n\n构造出 `aabacadaebbcbdbe...`\n\n这样构造出可能保证是答案是最小的\n\n当  $n$ 大于所能组成最大长度时，可以不断拼接，直至长度大于等于 $n$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nchar ch[26];\nvoid solve() {\n    int n, k; std :: cin >> n >> k;\n    if(k == 1) {\n        for(int i = 1; i <= n; ++ i)\n            std :: cout << 'a';\n        return ;\n    }\n    for(int i = 0; i < k; ++ i)\n        ch[i] = i;\n    std :: string ans = \"\";\n    for(int i = 0; i < k; ++ i) {\n        ans = ans + char(ch[i] + 'a') + char(ch[i] + 'a');\n        for(int j = i + 1; j < k; ++ j) {\n            if(j == k - 1 && i != j - 1) {\n                ans = ans + char(ch[j] + 'a');\n                break;\n            }\n            if(j != k - 1) {\n                ans = ans + char(ch[j] + 'a');\n                ans = ans + char(ch[i] + 'a');\n            }\n        }\n    }\n    while(ans.length() < n) ans = ans + ans;\n    for(int i = 0; i < n; ++ i)\n        std :: cout << ans[i];\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["构造题"],"categories":["题解","CF"]},{"title":"CF 1437C - Chef Monocarp题解","url":"/post/584931702.html","content":"<center> CF 1437C - Chef Monocarp题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1437/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201437C.png)\n#### Sample Input\n\n```\n6\n6\n4 2 4 4 5 2\n7\n7 7 7 7 7 7 7\n1\n1\n5\n5 1 2 4 3\n4\n1 4 4 4\n21\n21 8 1 4 1 5 21 1 8 21 11 21 11 3 12 8 19 15 9 11 13\n```\n\n#### Sample Output\n\n```\n4\n12\n0\n0\n2\n21\n```\n\n#### 解析：\n\n线性 $DP$\n\n记 $dp[i][j]$ 为第 $i$ 个食物在第 $j$ 时刻被拿出来的的最小不愉快值。\n\n显然容易推出 $dp[i][j] = \\min \\limits _{k = 1} ^{j - 1} dp[i-1][k] + abs(a[i]-j)$\n\n初始化条件是 $dp[1][i] = abs(a[1] - i)$\n\n最终答案即为 $\\max \\limits _{i = 1} ^{N} dp[n][i]$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\nvoid solve() {\n    int n; std :: cin >> n;\n    std :: vector <int> a(n);\n    std :: vector dp(N + 1, std :: vector <int> (N + 1));\n    for(int i = 0; i < n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= N; ++ i)\n        for(int j = 1; j <= N; ++ j)\n            dp[i][j] = INF;\n    std :: sort(a.begin(), a.end());\n    for(int i = 1; i <= N; ++ i)\n        dp[1][i] = std :: abs(a[0] - i);\n    for(int i = 2; i <= n; ++ i)\n        for(int j = 1; j <= N; ++ j)\n            for(int k = 1; k < j; ++ k)\n                dp[i][j] = std :: min(dp[i][j], dp[i-1][k] + std :: abs(a[i-1] - j));\n    int ans = INF;\n    for(int i = 1; i <= N; ++ i)\n        ans = std :: min(ans, dp[n][i]);\n    std :: cout << ans << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["线性dp","DP"],"categories":["题解","CF"]},{"title":"CF 148D - Bag of mice题解","url":"/post/275361330.html","content":"<center> CF 148D - Bag of mice题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/148/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20148D.png)\n\n#### Sample Input\n\n```\n5 5\n```\n\n#### Sample Output\n\n```\n0.658730159\n```\n\n#### 解析：\n\n概率 $DP$ \n\n设 $dp[i][j]$ 为有 $i$ 只白鼠， $j$ 只黑鼠时公主获胜的概率，则 $dp[w][b]$ 为答案。\n\n边界条件为 $dp[i][0] = 1$ ， $dp[0][i] = 0$\n\n分类讨论如下：\n\n当白鼠数量为 $i$ ，黑鼠数量为 $j$ 时，\n\n1. 公主取的白鼠， $dp[i][j] += \\frac{i}{i+j}$\n2. 公主取的黑鼠，龙取的白鼠， $dp[i][j] += 0$\n3. 公主取的黑鼠，龙取的黑鼠，跑走一个黑鼠， $dp[i][j] += \\frac{j}{i+j} \\times \\frac{j-1}{i+j-1} \\times \\frac{j-2}{i+j-2} \\times dp[i][j-3]$\n4. 公主取的黑鼠，龙取的黑鼠，跑走一个白鼠， $dp[i][j] += \\frac{j}{i+j} \\times \\frac{j-1}{i+j-1} \\times \\frac{i}{i+j-2} \\times dp[i-1][j-2]$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\ndouble dp[N][N];\nint w, b;\nvoid solve() {\n    std :: cin >> w >> b;\n    for(int i = 1; i <= w; ++ i)\n        dp[i][0] = 1;\n    for(int i = 1; i <= w; ++ i)\n        for(int j = 1; j <= b; ++ j) {\n            dp[i][j] += (double)i / (i + j);\n            if(j >= 3)\n                dp[i][j] += (double)j / (i + j) * (j - 1) / (i + j - 1) * (j - 2) / (i + j - 2) * dp[i][j-3];\n            if(i >= 1 && j >= 2)\n                dp[i][j] += (double)j / (i + j) * (j - 1) / (i + j - 1) * i / (i + j - 2) * dp[i-1][j-2];\n        }\n    printf(\"%.9lf\", dp[w][b]);\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["DP","概率DP"],"categories":["题解","CF"]},{"title":"CF 1360F - Spy-string题解","url":"/post/614255496.html","content":"<center> CF 1360F - Spy-string题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1360/problem/F)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201360F.png)\n\n#### Sample Input\n\n```\n5\n2 4\nabac\nzbab\n2 4\naaaa\nbbbb\n3 3\nbaa\naaa\naab\n2 2\nab\nbb\n3 1\na\nb\nc\n```\n\n#### Sample Output\n\n```\nabab\n-1\naaa\nab\nz\n```\n\n#### 解析：\n\n暴力即可，把第一个字符串作为模板，然后每一位枚举 $26$ 个字母形成答案串\n\n与其他串作比较，如果符合条件就输出。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int n, m; std :: cin >> n >> m;\n    std :: vector <std :: string> a(n);\n    for(int i = 0; i < n; ++ i)\n        std :: cin >> a[i];\n    for(int j = 0; j < m; ++ j) {\n        std :: string ans = a[0];\n        for(int k = 0; k < 26; ++ k) {\n            ans[j] = char(k + 'a');\n            int flag = 0;\n            for(int h = 0; h < n; ++ h) {\n                int cnt = 0;\n                for(int s = 0; s < m; ++ s)\n                    if(ans[s] != a[h][s]) cnt ++;\n                if(cnt > 1) {\n                    flag = 1;\n                    break;\n                }\n                if(flag == 1) break;\n            }\n            if(flag == 0) {\n                std :: cout << ans << endl;\n                return ;\n            }\n        }\n    }\n    std :: cout << -1 << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["暴力"],"categories":["题解","CF"]},{"title":"CF 1753B - Factorial Divisibility题解","url":"/post/2774934111.html","content":"<center> CF 1753B - Factorial Divisibility题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1753/problem/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201753B.png)\n\n#### Sample Input\n\n```\n6 4\n3 2 2 2 3 3\n```\n\n#### Sample Output\n\n```\nYes\n```\n\n#### 解析：\n\n很显然，$k! \\mid x \\times k!$ \n\n所以只有 $\\sum \\limits _{i=1} ^{n} a_i = x \\times k!$ 时，才会被整除\n\n一个很显然的运算是 $i! \\times (i + 1) = (i+1)!$\n\n所以我们可以合并相同的 $a_i$ ，然后合并到 $k!$ 及以上\n\n合并了一圈之后，如果存在 $h! < k!$ ，那么就不能被 $k!$ 整除。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5e5 + 20;\nint a[N], n, x;\nvoid solve() {\n    std :: cin >> n >> x;\n    for(int i = 1; i <= n; ++ i) {\n        int x; std :: cin >> x;\n        a[x] ++;\n    }\n    for(int i = 1; i < x; ++ i) {\n        while(a[i] % (i + 1) == 0 && a[i] > 0) a[i+1] ++, a[i] -= (i + 1);\n        if(a[i] > 0) {\n            std :: cout << \"No\\n\";\n            return ;\n        }\n    }\n    std :: cout << \"Yes\\n\";\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["数学"],"categories":["题解","CF"]},{"title":"CF 1539D - PriceFixed题解","url":"/post/3388638821.html","content":"<center> CF 1539D - PriceFixed题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1539/problem/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201539D.png)\n\n#### Sample Input\n\n```\n5\n2 7\n2 8\n1 2\n2 4\n1 8\n```\n\n#### Sample Output\n\n```\n12\n```\n\n#### 解析：\n\n贪心题\n\n首先，很显然的是，她肯定会只买 $\\sum \\limits _{i=1} ^{n} a_i$ 个商品，但凡多买一个就会多花 $1$ 卢布。\n\n我们按照 $b_i$ 即折扣最低购买量排序，然后一个指针从头开始，另外一个指针从后开始\n\n我们所要达到的目的就是尽量满足前方的最低要求，按折扣买，后方的按原价买。\n\n题目不难，只是细节比较多。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint n;\nstruct Node {\n    i64 need, least;\n    friend bool operator < (Node a, Node b) {\n        return a.least < b.least;\n    }\n}a[N];\nvoid solve() {\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i].need >> a[i].least;\n    std :: sort(a + 1, a + 1 + n);\n\n    i64 now = 0, ans = 0;\n    for(int i = 1; i <= n; ++ i) {\n        if(now >= a[i].least) ans += a[i].need, now += a[i].need;\n        else {\n            while(n > i && now < a[i].least)\n                now += a[n].need, ans += a[n].need * 2, a[n].need = 0, n --;\n            if(now >= a[i].least) {\n                ans += a[i].need;\n                n ++, a[n].need = now - a[i].least, ans -= a[n].need * 2, now = a[i].least;\n            } else {\n                if(a[i].least >= a[i].need + now) ans += a[i].need * 2;\n                else ans += (a[i].least - now) * 2 + (a[i].need + now - a[i].least);\n            }\n            now += a[i].need;\n        }\n    }\n\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心","双指针"],"categories":["题解","CF"]},{"title":"CF 1886C - Decreasing String题解","url":"/post/1910237204.html","content":"<center> CF 1886C - Decreasing String题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1886/problem/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201886C.png)\n#### Sample Input\n\n```\n3\ncab\n6\nabcd\n9\nx\n1\n```\n\n#### Sample Output\n\n```\nabx\n```\n\n#### 解析：\n\n贪心题。\n\n我感觉还是比较明显的。\n\n首先要删的是，当前位大于后一位的，比如 `cba` 先删除 $c$ ，再删 $b$\n\n然后就会得到一个不减序列，在从后面往前删即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nvoid solve() {\n    std :: string s; i64 n;\n    std :: cin >> s >> n;\n    int len = s.length();\n    i64 now = len, del = 0;\n    if(n <= now) {\n        std :: cout << s[n-1];\n        return;\n    }\n    std :: stack <int> st;\n    std :: map <int, bool> m;\n    for(int i = 0; i < len; ++ i) {\n        bool flag = 0;\n        while(st.size() && s[st.top()] > s[i]) {\n            m[st.top()] = 1;\n            st.pop(); del ++;\n            now += len - del;\n            if(now >= n) {\n                flag = 1;\n                break;\n            }\n        } if(flag == 1) break;\n        st.push(i);\n    }\n    if(n <= now) {\n        int j = 0;\n        i64 pos = n - (now - len + del), limit = 0;\n        for(int i = 0; i < len; ++ i) {\n            if(m[i] == 1) continue;\n            j ++;\n            if(j == pos) {\n                std :: cout << s[i];\n                return ;\n            }\n        }\n    }\n\n    int d = 0;\n    while(now < n) d ++, now += len - del - d;\n    i64 pos = n - (now - len + del + d), j = 0;\n    for(int i = 0; i < len; ++ i) {\n        if(m[i] == 1) continue;\n        j ++;\n        if(j == pos) {\n            std :: cout << s[i];\n            return ;\n        }\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 75C - Modified GCD题解","url":"/post/2795344347.html","content":"<center> CF 75C - Modified GCD题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/75/problem/C)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%2075C.png?raw=true)\n#### Sample Input\n\n```\n9 27\n3\n1 5\n10 11\n9 11\n```\n\n#### Sample Output\n\n```\n3\n-1\n9\n```\n\n#### 解析：\n\n二分。\n\n既然求 $[l,r]$ 内 $a, b$ 的最大公约数 $k$ ，那么 $k \\mid d$ ，$d$ 为 $a,b$ 的最大公约数。\n\n我们只需要求出 $d$ ，然后排列出 $d$ 的因数，二分一下即可。\n\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int a, b; std :: cin >> a >> b;\n    int gcd = std :: __gcd(a, b);\n    std :: vector <int> div;\n    for(int i = 1; i <= sqrt(gcd); ++ i)\n        if(gcd % i == 0) {\n            div.push_back(i);\n            if(i * i != gcd) div.push_back(gcd / i);\n        }\n    div.push_back(0);\n    div.push_back(Range + 1);\n    std :: sort(div.begin(), div.end());\n    int n; std :: cin >> n;\n    while(n --) {\n        int l, r; std :: cin >> l >> r;\n        int x = std :: upper_bound(div.begin(), div.end(), r) - div.begin();\n        if(div[x-1] < l) std :: cout << -1 << '\\n';\n        else std :: cout << div[x-1] << '\\n';\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","categories":["题解","CF"]},{"title":"CF 1537D - Deleting Divisors题解","url":"/post/2328484107.html","content":"<center> CF 1537D - Deleting Divisors题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1537/problem/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201537D.png)\n\n#### Sample Input\n\n```\n4\n1\n4\n12\n69\n```\n\n#### Sample Output\n\n```\nBob\nAlice\nAlice\nBob\n```\n\n#### 解析：\n\n博弈论\n\n我们进行分类讨论，按照三种情况：1）$n$ 为奇数 ，2） $n$ 为偶数但不是 $2$ 的幂，3） $n$ 为偶数并且是 $2$ 的幂。\n\n1. $n$ 为奇数\n\n   a. $n$ 为质数，则当前玩家败。\n\n   b. $n$ 不为质数，那么 $n$ 的因子一定全为奇数，那么减去任意一个奇数， $n$ 就会变成一个偶数，且该偶数一定不是 $2$ 的幂。\n\n2. $n$ 为偶数但不是 $2$ 的幂\n\n因为 $n$ 不为 $2$ 的幂，所以 $n$ 一定存在一个非 $1$ 的奇数因子 $d$ ，那么对于当前情况来说，一定可以减去 $d$ ，从而 $n$ 变成一个奇数（情况 $1$ ）\n\n下一步又会变成情况 $2$ \n\n...\n\n最后直至变成一个质数奇数\n\n显然，当前状态是必胜的。\n\n3. $n$ 为偶数且是 $2$ 的幂\n\n对于当前玩家来说，最优的方案就是将 $n$ 减半，又变成一个 $2$ 的幂。\n\n因为你减去其他因子，会变成情况 $2$ ，那么就会是必败态。\n\n那么， $n$ 一直减半，直到 $2$ 失败。\n\n显然，当 $n$ 为 $2$ 的奇次幂是必败态，偶次幂是必胜态。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\n// const int N = ;\nvoid solve() {\n    int n; std :: cin >> n;\n    int cnt = 0;\n    while(n % 2 == 0) cnt ++, n /= 2;\n    if(n == 1 && cnt & 1) {\n        std :: cout << \"Bob\\n\";\n        return ;\n    }\n    if(cnt > 0) std :: cout << \"Alice\\n\";\n    else std :: cout << \"Bob\\n\";\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["博弈论"],"categories":["题解","CF"]},{"title":"CF 165C - Another Problem on Strings题解","url":"/post/2520344268.html","content":"<center> CF 165C - Another Problem on Strings题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/165/C)\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20165C.png)\n\n#### Sample Input\n\n```\n2\n01010\n```\n\n#### Sample Output\n\n```\n4\n```\n\n#### 解析：\n\n数学题。\n\n注意到 $k$ 的范围，所以我们分类讨论。\n\n1. $0 < k \\leq 10^6$\n\n那么子串中必须有 $1$ ，所以我们可以把 $1$ 的位置都记录下来，然后从第一个 $1$ 开始枚举，看这 $k$ 个 $1$ 左右两边 $0$ 的个数，答案即为乘积累加和。\n\n2. $k = 0$\n\n那么子串中不能有 $1$ ，我们仍然可以利用存 $1$ 的数组，计算相邻的 $1$ 之间的 $0$ 串的子串和，再把答案累加即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nint k;\nstd :: string s;\nvoid solve() {\n    std :: cin >> k >> s;\n    int n = s.length();\n    std :: vector <int> v;\n    v.push_back(0);\n    for(int i = 0; i < n; ++ i)\n        if(s[i] == '1')\n            v.push_back(i + 1);\n    v.push_back(n + 1);\n    int m = v.size() - 2;\n    i64 ans = 0;\n    if(k > 0) {\n        for(int i = 1; i <= m; ++ i)\n            if(i + k - 1 <= m)\n                ans += (i64)(v[i] - v[i-1]) * (v[i+k] - v[i+k-1]);\n    } else {\n        for(int i = 1; i <= m + 1; ++ i)\n            if(v[i] > v[i-1] + 1)\n                ans += i64(v[i] - v[i-1]) * (v[i] - v[i-1] - 1) / 2;\n    }\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["数学"],"categories":["题解","CF"]},{"title":"CF 1567C - Carrying Conundrum题解","url":"/post/1573286431.html","content":"<center> CF 1567C - Carrying Conundrum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1567/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201567C.png)\n\n#### Sample Input\n\n```\n5\n100\n12\n8\n2021\n10000\n```\n\n#### Sample Output\n\n```\n9\n4\n7\n44\n99\n```\n\n#### 解析：\n\n与正常的加法相比，隔位进 $1$ 。\n\n也就是说相邻的两位之间无任何关系。\n\n那么我们可以把奇数位置的数单独拿出来当作一个数，偶数位置的数单独拿出来当作一个数，可以按照正常加法来算方案数。\n\n设奇数位置的数为 $a$ ，偶数位置的数为 $b$ ，那么方案数就是 $(a + 1) \\times (b + 1)$\n\n题目中又说是正整数，那么再减去 $2$ 就好了（一个情况是 $a$ 为 $0$ ，另一个情况是 $b$ 为 $0$）。\n\n答案即 $(a+1) \\times (b+1) - 2$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 20;\nvoid solve() {\n    std :: string s; std :: cin >> s;\n    int n = s.length();\n    int a = 0, b = 0;\n    for(int i = 0; i < n; ++ i)\n        if(i % 2 == 0) a = a * 10 + (s[i] - '0');\n        else b = b * 10 + (s[i] - '0');\n    std :: cout << (a + 1) * (b + 1) - 2 << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["组合数学"],"categories":["题解","CF"]},{"title":"CF 1455D - Sequence and Swaps题解","url":"/post/1117243170.html","content":"<center> CF 1455D - Sequence and Swaps题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1455/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201455D.png)\n#### Sample Input\n\n```\n6\n4 1\n2 3 5 4\n5 6\n1 1 3 4 4\n1 10\n2\n2 10\n11 9\n2 10\n12 11\n5 18\n81 324 218 413 324\n```\n\n#### Sample Output\n\n```\n3\n0\n0\n-1\n1\n3\n```\n\n#### 解析：\n\n贪心。\n\n观察题目，我们得知，每一次交换 $x$ 的值是在变大的，所以我们一定是从前向后交换值。\n\n所以我们从开始一直到结束不断交换，直到最后一个乱序的位置即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\nvoid solve() {\n    int n, x, ans = 0, k = 0; std :: cin >> n >> x;\n    std :: vector <int> a(n + 1);\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= n; ++ i)\n        if(a[i] < a[i-1]) k = i;\n    for(int i = 1; i <= k; ++ i)\n        if(a[i] > x) std :: swap(a[i], x), ans ++;\n    for(int i = 1; i <= n; ++ i)\n        if(a[i] < a[i-1]) {\n            std :: cout << -1 << endl;\n            return ;\n        }\n    std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1537E1 - Erase and Extend (Easy Version)题解","url":"/post/3670149279.html","content":"<center> CF 1537E1 - Erase and Extend (Easy Version)题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/1537/problem/E1)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201537E1.png)\n\n#### Sample Input\n\n```\n8 16\ndbcadabc\n```\n\n#### Sample Output\n\n```\ndbcadabcdbcadabc\n```\n\n#### 解析：\n\n暴力。\n\n考虑只会不断复制给定字符串的前缀，长度大于等于 $k$ ，删除多余的即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5050;\nvoid solve() {\n    int n, k;\n    std :: string str, ans = \"\";\n    std :: cin >> n >> k >> str;\n    for(int i = 1; i <= k; ++ i)\n        ans += 'z';\n    for(int i = 0; i < n; ++ i) {\n        int l = 0;\n        while((i + 1) * (1 << l) < k) l ++;\n        std :: string s = str.substr(0, i + 1);\n        for(int j = 1; j <= l; ++ j)\n            s = s + s;\n        // deb(l); deb(s);\n        ans = std :: min(ans, s.substr(0, k));\n    }\n    std :: cout << ans << '\\n';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["暴力"],"categories":["题解","CF"]},{"title":"CF 1890E1 - Doremy's Drying Plan (Easy Version)题解","url":"/post/2531427535.html","content":"<center> CF 1890E1 - Doremy's Drying Plan (Easy Version)题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1890/E1)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201890E1.png)\n\n#### Sample Input\n\n```\n6\n2 3 2\n1 2\n1 2\n1 1\n5 3 2\n1 3\n2 4\n3 5\n10 6 2\n1 5\n6 10\n2 2\n3 7\n5 8\n1 4\n100 6 2\n1 100\n1 100\n1 100\n1 100\n1 100\n1 100\n1000 2 2\n1 1\n1 1\n20 5 2\n9 20\n3 3\n10 11\n11 13\n6 18\n```\n\n#### Sample Output\n\n```\n1\n2\n3\n0\n1000\n15\n```\n\n#### 解析：\n\n简单版本只需要考虑去除两条线段，完全可以暴力。\n\n去除两条线段，就只有两种情况：第一，两线段互不相交；第二，两个线段有一部分交集。\n\n对于第一种情况，我们只需要统计对于每一条线段所覆盖的 $1$ 的数量即可，然后取前两大加起来。\n\n对于第二种情况，我们只需要找到只被两条线段覆盖的点，然后找到那两个线段，统计覆盖的点为 $1$ 或 $2$ 的个数即可，\n\n对于如何找那两个线段，我们可以这么做：\n\n当遍历到只被两条线段覆盖的点，我们把前面所有左端点小于等于当前点的线段加到一个集合里。\n\n然后删除掉右端点大于当前点的线段，那么集合中一定只剩下那两个线段。\n\n对于某个点被一个线段覆盖还是被两个线段覆盖，我们可以利用差分和前缀和：\n\n把每个线段差分一下，然后计算出每个点的情况。\n\n然后对于 $1$ 和 $2$ 分别进行前缀和。\n\n最后一定不要忘了在加上 $0$ 的点。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, m, k, d[N], s1[N], s2[N];\nstruct Line {\n    int l, r;\n    friend bool operator < (Line a, Line b) {\n        return a.l == b.l ? a.r < b.r : a.l < b.l;\n    }\n}line[N];\nint solution1() {\n    std :: priority_queue <int> q;\n    for(int i = 1; i <= m; ++ i)\n        q.push(s1[line[i].r] - s1[line[i].l-1]);\n    int maxx = q.top(); q.pop();\n    return q.top() + maxx;\n}\nint solution2() {\n    std :: sort(line + 1, line + 1 + m);\n    std :: multiset <pi> s;\n    int j = 1, maxx = 0;\n    for(int i = 1; i <= n; ++ i) {\n        if(d[i] == 2) {\n            while(j <= m && line[j].l <= i) s.insert({line[j].r, line[j].l}), ++ j;\n            while(s.size() && s.begin()->first < i) s.erase(s.begin());\n            int l = std :: min(s.begin()->second, s.rbegin()->second);\n            int r = std :: max(s.begin()->first, s.rbegin()->first);\n            int res = s1[r] - s1[l-1];\n            l = std :: max(s.begin()->second, s.rbegin()->second);\n            r = std :: min(s.begin()->first, s.rbegin()->first);\n            res += s2[r] - s2[l-1];\n            maxx = std :: max(maxx, res);\n        }\n    }\n    return maxx;\n}\nvoid init() {\n    for(int i = 1; i <= n; ++ i)\n        d[i] = 0;\n}\nvoid solve() {\n    std :: cin >> n >> m >> k;\n    init(); int cnt = 0;\n    for(int i = 1; i <= m; ++ i)\n        std :: cin >> line[i].l >> line[i].r;\n    for(int i = 1; i <= m; ++ i)\n        d[line[i].l] ++, d[line[i].r+1] --;\n    for(int i = 1; i <= n; ++ i)\n        d[i] += d[i-1];\n    for(int i = 1; i <= n; ++ i)\n        cnt += (d[i] == 0);\n    for(int i = 1; i <= n; ++ i)\n        s1[i] = s1[i-1] + (d[i] == 1);\n    for(int i = 1; i <= n; ++ i)\n        s2[i] = s2[i-1] + (d[i] == 2);\n    std :: cout << std :: max(solution1(), solution2()) + cnt << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["前缀和","差分","multiset"],"categories":["题解","CF"]},{"title":"CF 1615C - Menorah题解","url":"/post/224910530.html","content":"<center> CF 1615C - Menorah题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1615/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201615C.png)\n\n#### Sample Input\n\n```\n5\n5\n11010\n11010\n2\n01\n11\n3\n000\n101\n9\n100010111\n101101100\n9\n001011011\n011010101\n```\n\n#### Sample Output\n\n```\n0\n1\n-1\n3\n4\n```\n\n#### 解析：\n\n我们肯定能知道，所作次数与蜡烛的位置是没有关系的。\n\n我们手玩几个样例会发现一种偶数次操作次数的方案。\n\n当然，这个偶数次操作方案必须有一个条件，在对应位置上，$s1[i]$ 为 $1$ 且 $s2[i]$ 为 $0$ 的个数与 $s1[j]$ 为 $0$ 且 $s2[j]$ 为 $1$ 的个数相同。\n\n第一步选择 $s1[i] = 1 , s2[i] = 0$ 的位置，操作一次。\n\n第二步选择 $s1[j]=0 , s2[j]=1$ 的位置，操作一次。\n\n你会发现，$s1[i] = 0,s1[j] = 1$。\n\n不断重复上述过程即可，这就是偶数次操作。\n\n然后我们就会想，如何奇数次操作呢？\n\n如果奇数次操作，那么不动那些不一样的即可，奇数次后会将他们变得一样，那我们就只能动一样的。\n\n对于一样的来说也是如此，奇数次就会变得不一样，我们一样的我们都要选中一次操作，那么对于选其他位置的数操作来说，当前这个数就相当于操作了偶数次，即不变。\n\n手玩几个样例，会发现，操作次序一定是，选择 $s[i]=1$ ，选择 $s[j]0$ ，选择 $s[k]=1$ ，...，$s[h]=1$。\n\n即一定是$1010...1$，所以保证相同的位置是 $1$ 的个数比相同位置为 $0$ 的个数多一个即可。\n\n遮这样的话，只记录个数即可，复杂度为 $O(N)$.\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nvoid solve() {\n    std :: string s1, s2;\n    int n;\n    std :: cin >> n;\n    std :: cin >> s1 >> s2;\n    if(s1 == s2) {\n        std :: cout << 0 << endl;\n        return ;\n    }\n    // solution1\n    int cnt0 = 0, cnt1 = 0;\n    for(int i = 0; i < n; ++ i)\n        if(s1[i] == '0' && s2[i] == '0') cnt0 ++;\n        else if(s1[i] == '1' && s2[i] == '1') cnt1 ++;\n    int ans = INF;\n    if(cnt1 == cnt0 + 1) ans = cnt0 * 2 + 1;\n    // solution2\n    cnt0 = 0; cnt1 = 0;\n    for(int i = 0; i < n; ++ i)\n        if(s1[i] == '1' && s2[i] == '0') cnt1 ++;\n        else if(s1[i] == '0' && s2[i] == '1') cnt0 ++;\n    if(cnt0 == cnt1 && cnt0 != 0) ans = std :: min(ans, cnt0 + cnt1);\n    if(ans == INF) std :: cout << -1 << endl;\n    else std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["暴力"],"categories":["题解","CF"]},{"title":"CF 1890D - Doremy's Connecting Plan题解","url":"/post/1511877259.html","content":"<center> CF 1890D - Doremy's Connecting Plan题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1890/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201890D.png)\n\n#### Sample Input\n\n```\n7\n4 10\n0 20 15 10\n2 1\n1 1\n5 1\n0 1 0 4 199\n5 2\n1 1 3 1 1\n5 5\n5 6 1 10 2\n5 1000000\n1000000000000 1000000000000 1000000000000 1000000000000 1000000000000\n3 1\n0 0 2\n```\n\n#### Sample Output\n\n```\nYes\nYes\nYes\nNo\nNo\nYes\nNo\n```\n\n#### 解析：\n\n贪心。\n\n观察式子 $\\sum \\limits _{k \\in S} {a_k \\ge i \\cdot j \\cdot c}$ ，\n\n显然，为了让这个不等式成立，我们要尽量让 $i$ 或 $j$ 取最小值，\n\n设 $s[i]$ 为 $i$ 代表的连通块的和， $s[j]$ 也是如此，\n\n则有 $s[i] + s[j] \\ge i \\cdot j \\cdot c$ ，\n\n不妨让 $i = 1$ ，\n\n则 $s[1] + s[j] \\ge j \\cdot c$ 。\n\n我们可以反证一下，证明上式的正确性。\n\n设存在 $i \\ge 2,j \\ge 2$  满足 $\\begin{cases} i \\neq j \\\\ s[i] + s[j] \\ge i \\cdot j \\cdot c \\\\ s[1] + s[j] < j \\cdot c \\\\ s[1] + s[i] < i \\cdot c\\end{cases}$\n\n合并后两个式子，\n\n$$s[i] + s[j] < (i + j) \\cdot c - 2s[1] $$\n\n$$s[i] + s[j] < (i + j) \\cdot c $$\n\n$$s[i] + s[j] < i \\cdot j \\cdot c $$\n\n与假设矛盾，则假设不成立，即原式正确。\n\n所以我们转化一下 $s[1] + s[j] \\ge j \\cdot c$ ，有 $s[1] \\ge j \\cdot c - s[j]$。\n\n为了尽量合并更多联通块，我们可以按照 $j \\cdot c - s[j]$ 排序，从最小值开始合并。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\ni64 n, c;\nstruct Node {\n    i64 val, id;\n    friend bool operator < (Node a, Node b) {\n        return c * a.id - a.val < c * b.id - b.val;\n    }\n}a[N];\nvoid solve() {\n    std :: cin >> n >> c;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i].val, a[i].id = i;\n    std :: sort(a + 2, a + 1 + n);\n    i64 s = a[1].val;\n    for(int i = 2; i <= n; ++ i) {\n        if(s + a[i].val >= a[i].id * c) s += a[i].val;\n        else {\n            std :: cout << \"No\\n\";\n            return ;\n        }\n    }\n    std :: cout << \"Yes\\n\";\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["贪心"],"categories":["题解","CF"]},{"title":"CF 1303C - Perfect Keyboard题解","url":"/post/1834842648.html","content":"<center> CF 1303C - Perfect Keyboard题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1303/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201303C.png)\n\n#### Sample Input\n\n```\n5\nababa\ncodedoca\nabcda\nzxzytyz\nabcdefghijklmnopqrstuvwxyza\n```\n\n#### Sample Output\n\n```\nYES\nbacdefghijklmnopqrstuvwxyz\nYES\nedocabfghijklmnpqrstuvwxyz\nNO\nYES\nxzytabcdefghijklmnopqrsuvw\nNO\n```\n\n#### 解析：\n\n构造题。\n\n首先，我们要确定什么条件下才能构造出来一个序列。\n\n我们把相邻的字母都连一条边，然后需要满足以下条件：\n\n1. 没有一个字母的度大于 $2$。\n2. 没有环。\n\n第一个条件很好判断，在此不讲。\n\n第二个条件的话，有两种判断方法。\n\n1. 先判断是否有度等于 $1$ ，如果没有那就说明一定有环，则可以输出`NO`。\n2. 如果有，那么也有可能有环，可以从度为 $1$ 的进入，遇到环就判否。\n\n两个条件都满足，则一定会有一条链，按顺序输出，然后把剩下的随便输出即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 220;\nstd :: string str;\nint s[N];\nvoid solve() {\n    std :: cin >> str;\n    int n = str.length();\n    for(int i = 0; i < n; ++ i)\n        s[i+1] = str[i] - 'a' + 1;\n    if(n == 1) {\n        std :: cout << \"YES\\n\";\n        for(int i = 1; i <= 26; ++ i)\n            std :: cout << char(i+'a'-1);\n        std :: cout << endl;\n        return ;\n    }\n    std :: set <int> adj[N];\n    std :: vector <int> vis(30);\n    adj[s[1]].insert(s[2]);\n    adj[s[n]].insert(s[n-1]);\n    for(int i = 2; i < n; ++ i) {\n        adj[s[i]].insert(s[i-1]);\n        adj[s[i]].insert(s[i+1]);\n    }\n    for(int i = 1; i <= 26; ++ i)\n        if(adj[i].size() > 2) {\n            std :: cout << \"NO\\n\";\n            return ;\n        }\n    std :: vector <int> ans;\n    int cnt_1 = 0;\n    for(int i = 1; i <= 26; ++ i)\n        if(adj[i].size() == 1) {\n            int x = i; cnt_1 ++;\n            while(1) {\n                if(vis[x]) {\n                    std :: cout << \"NO\\n\";\n                    return ;\n                }\n                vis[x] = 1;\n                ans.push_back(x);\n                if(adj[x].size() == 0) break;\n                for(auto y : adj[x])\n                    if(y != x) {\n                        adj[x].erase(y);\n                        adj[y].erase(x);\n                        x = y;\n                        break;\n                    }\n            }\n        }\n    if(cnt_1 == 0) {\n        std :: cout << \"NO\\n\";\n        return ;\n    }\n    std :: cout << \"YES\\n\";\n    for(auto x : ans)\n        std :: cout << char(x+'a'-1);\n    for(int i = 1; i <= 26; ++ i)\n        if(!vis[i])\n            std :: cout << char(i+'a'-1);\n    std :: cout << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["构造题"],"categories":["题解","CF"]},{"title":"CF 1622C - Set or Decrease题解","url":"/post/248256200.html","content":"<center> CF 1622C - Set or Decrease题解题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1622/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201622C.png)\n\n#### Sample Input\n\n```\n4\n1 10\n20\n2 69\n6 9\n7 8\n1 2 1 3 1 2 1\n10 1\n1 2 3 1 2 6 1 6 8 10\n```\n\n#### Sample Output\n\n```\n10\n0\n2\n7\n```\n\n#### 解析：\n\n首先要确定一点，当最大值和最小值的差大于 $1$ 时，赋值远比减一划算。\n\n所以我们尽量减小最小值，并且把最小值赋给较大的值是最优的。\n\n这个题我想了两种思路，但是第一种没有成功实现，两种方法都说一下。\n\n设 $a[]$ 为原数组，$sum$ 为前缀和数组， $k$ 为不等式右边的值， $m$ 为要被 $a[1]$ 赋值的个数。\n\n##### 方法一：\n\n枚举不被赋值的数的个数，求 $a[1]$ 减后的值，继而求出答案。\n\n设不被赋值的数的个数为 $i(1 \\leq i \\leq n - 2)$ ，$a[1]$ 减后的值为 $b$ 。\n\n则有 $(m + 1) \\times b + sum[n-m] - sum[1] \\leq k$ ，\n\n变形，有 $m \\times b \\leq k - (sum[n-m] - sum[1])$ ，\n\n设 $\\Delta$ 为 $sum[n-m] - sum[1]$ ，\n\n有 $m \\times b \\leq k - \\Delta$ ，\n\n1. 当 $k - \\Delta \\ge 0$ ，则 $b \\leq \\frac{k - \\Delta}{m}$\n   1. $a[1] \\leq \\frac{k - \\Delta}{m}$ ，则答案为 $m$\n   2. $a[1] > \\frac{k - \\Delta}{m}$，则答案为 $a[1] - b + m$\n2. 当 $k - \\Delta < 0$ ，则 $-b > \\frac{\\Delta - k}{m}$ ，答案为 $\\frac{\\Delta - k}{m} + a[1] + m$\n\n##### 方法二：\n\n二分一下操作次数，然后枚举被 $a[1]$ 赋值的数的个数，$mid$ 减去上述的数即为 $a[1]$ 要减去的数。\n\n仅贴一下方法二的代码。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\ni64 n, k, a[N], sum[N];\nbool check(i64 mid) {\n    if(mid >= n - 1)\n        if(n * (a[1] - (mid - n + 1)) <= k) return true;\n    for(i64 i = 0; i < n - 1; ++ i)\n        if(mid >= i)\n            if((i + 1) * (a[1] - (mid - i)) + sum[n-i] - sum[1] <= k)\n                return true;\n    return false;\n}\nvoid solve() {\n    std :: cin >> n >> k;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    if(n == 1) {\n        std :: cout << (a[1] <= k ? 0 : a[1] - k) << endl;\n        return ; \n    }\n    std :: sort(a + 1, a + 1 + n);\n    for(int i = 1; i <= n; ++ i)\n        sum[i] = sum[i-1] + a[i];\n    i64 l = 0, r = 1e15, ans;\n    while(l <= r) {\n        i64 mid = (l + r) >> 1;\n        if(check(mid)) r = mid - 1, ans = mid;\n        else l = mid + 1;\n    }\n    std :: cout << std :: min(ans, (sum[n] - k) >= 0 ? (sum[n] - k) : 0) << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["前缀和","二分"],"categories":["题解","CF"]},{"title":"CF 1474C - Array Destruction题解","url":"/post/3694985655.html","content":"<center> CF 1474C - Array Destruction题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1474/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201474C.png)\n\n#### Sample Input\n\n```\n4\n2\n3 5 1 2\n3\n1 1 8 8 64 64\n2\n1 1 2 4\n5\n1 2 3 4 5 6 7 14 3 11\n```\n\n#### Sample Output\n\n```\nYES\n6\n1 5\n2 3\nNO\nNO\nYES\n21\n14 7\n3 11\n5 6\n2 4\n3 1\n```\n\n#### 解析：\n\n容易发现，最大的数只能第一次删除，第二大的数只能第二次删除，第三大的数只能第三次删除，...，第 $k$ 大的数只能第三次删除。\n\n所以我们奠定一个基础，删除的时候从大的遍历到小的。\n\n那么我们如何确定第一个最大的数和哪个数组合呢？\n\n我们发现 $n \\leq 1,000$\n\n我们可以枚举这个数，复杂度为 $O(n^2)$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nvoid solve() {\n    int n; std :: cin >> n;\n    std :: vector <int> a(n<<1);\n    for(int i = 0; i < n << 1; ++ i)\n        std :: cin >> a[i];\n    std :: sort(a.begin(), a.end());\n    for(int i = 0; i < (n << 1) - 1; ++ i) {\n        std :: map <int, int> cnt;\n        for(int j = 0; j < (n << 1); ++ j)\n            cnt[a[j]] ++;\n        int x = a[i] + a[(n<<1)-1];\n        std :: vector <pi> ans;\n\n        for(int j = (n << 1) - 1; j >= 0; -- j) {\n            if(cnt[a[j]] == 0) continue;\n            if(cnt[x-a[j]] == 0) break;\n            if(a[j] << 1 == x && cnt[a[j]] == 1) break;\n            ans.push_back({x-a[j], a[j]});\n            cnt[x-a[j]] --; cnt[a[j]] --; x = a[j];\n        }\n        // deb(ans.size());\n        if(ans.size() == n) {\n            std :: cout << \"YES\\n\" << a[i] + a[(n<<1)-1] << endl;\n            for(auto [s, t] : ans)\n                std :: cout << s << ' ' << t << endl;\n             return ;\n        }\n    }\n    std :: cout << \"NO\" << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["枚举","暴力"],"categories":["题解","CF"]},{"title":"CF 1632C - Strange Test题解","url":"/post/2327128442.html","content":"\n<center> CF 1632C - Strange Test题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1632/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201632C.png)\n\n#### Sample Input\n\n```\n5\n1 3\n5 8\n2 5\n3 19\n56678 164422\n```\n\n#### Sample Output\n\n```\n1\n3\n2\n1\n23329\n```\n\n#### 解析：\n\n首先要确定一个性质： $a \\mid b \\geq b$\n\n所以我们就会有三种方案：\n\n1. $a$ 一直自加到 $b$\n2. $a$ 一直自加，然后 $a \\mid b = b$\n3. $b$ 一直自加，然后 $a \\mid b = b$\n\n我们观察到 $\\sum \\limits{b} \\leq 10^6$\n\n所以是可以暴力枚举的。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nint solution1(int a, int b) {\n    return b - a;\n}\nint solution2(int a, int b) {\n    int ans = 1;\n    while(1) {\n        if((a | b) == b) return ans;\n        ans ++; a ++;\n    }\n}\nint solution3(int a, int b) {\n    int ans = 1;\n    while(1) {\n        if((a | b) == b) {\n            return ans;\n        }\n        b ++; ans ++;\n    }\n}\nvoid solve() {\n    int a, b;\n    std :: cin >> a >> b;\n    std :: cout << std :: min(solution1(a, b), \n        std :: min(solution2(a, b), solution3(a, b))) << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["位运算","暴力"],"categories":["题解","CF"]},{"title":"洛谷 P3567 POI2014 KUR-Couriers题解","url":"/post/469529373.html","content":"<center> 洛谷 P3567 POI2014 KUR-Couriers题解 </center>\n<!--more-->\n\n[原题链接](https://www.luogu.com.cn/problem/P3567)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/Luogu%20P3567.png)\n#### Sample Input\n\n```\n7 5\n1 1 3 2 3 4 3\n1 3\n1 4\n3 7\n1 7\n6 6\n```\n\n#### Sample Output\n\n```\n1\n0\n3\n0\n4\n```\n\n#### 解析：\n\n求区间内严格超过一半的数。\n\n一个性质（废话）：区间内严格超过一半的数一定在区间内严格超过一半。\n\n我们可以使用主席树，我们只需要在权值线段树内找个数大于当前区间一半的那一半子树。\n\n一直找下去，分为两种情况：\n\n1. 有答案，那就会一直找到叶子节点，返回答案即可。\n2. 无答案，则在当前树中，左右两颗子树的数个数一定都不会大于区间一半。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e9;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5e5 + 20;\nint n, m, a[N], rt[N*40], tot;\nstruct Node {\n    int l, r, cnt;\n}t[N*40];\nvoid insert(int &k, int bk, int l, int r, int val) {\n    if(!k) k = ++ tot;\n    t[k].cnt = t[bk].cnt + 1;\n    if(l == r) return ;\n    int mid = (l + r) >> 1;\n    if(val <= mid) {\n        t[k].r = t[bk].r;\n        insert(t[k].l, t[bk].l, l, mid, val);\n    } else {\n        t[k].l = t[bk].l;\n        insert(t[k].r, t[bk].r, mid+1, r, val);\n    }\n}\nint query(int k1, int k2, int l, int r, int len) {\n    // std :: cout << l << ' ' << r << endl;\n    if(l == r && t[k1].cnt - t[k2].cnt > len) return l;\n    if(t[t[k1].l].cnt - t[t[k2].l].cnt <= len && t[t[k1].r].cnt - t[t[k2].r].cnt <= len)\n        return 0;\n    int mid = (l + r) >> 1;\n    if(t[t[k1].l].cnt - t[t[k2].l].cnt > len) return query(t[k1].l, t[k2].l, l, mid, len);\n    return query(t[k1].r, t[k2].r, mid+1, r, len);\n}\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= n; ++ i)\n        insert(rt[i], rt[i-1], 1, n, a[i]);\n    for(int i = 1; i <= m; ++ i) {\n        int l, r; std :: cin >> l >> r;\n        std :: cout << query(rt[r], rt[l-1], 1, n, (r - l + 1) >> 1) << endl;\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["主席树"],"categories":["题解","Luogu"]},{"title":"洛谷 P3963 TJOI2013 奖学金题解","url":"/post/1445769701.html","content":"<center> 洛谷 P3963 TJOI2013 奖学金题解 </center>\n<!--more-->\n\n[原题链接](https://www.luogu.com.cn/problem/P3963)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/Luogu%20P3963.png)\n#### Sample Input\n\n```\n3 5 70\n30 25\n50 21\n20 20\n5 18\n35 30\n```\n\n#### Sample Output\n\n```\n35\n```\n\n#### 解析：\n\n求最大中位数。\n\n按照题意，我们只需要找到一个最大的中位数，且满足该中位数前面的前 $\\frac{n}{2}$ 小值的和该中位数后面的前 $\\frac{n}{2}$ 值的和不超过 $f$ 即可。\n\n很容易想到可以二分，但是二分并不满足单调性，所以不能用二分。\n\n观察数据范围， $0 \\leq c \\leq 2e5$ ，可以用 $O(nlogn)$ 的方法通过。\n\n我们可以枚举每一个数作为中位数，然后在 $O(logn)$ 的时间内查询该数前面前 $\\frac{n}{2}$ 小值的和该数后面的前 $\\frac{n}{2}$ 值的和。\n\n可以用优先队列和主席树维护。\n\n我这里用的主席树。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define int long long\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst int Range = 1e5;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint c, n, f, rt[N*40], tot;\nstruct stu {\n    i64 a, b;\n    friend bool operator < (stu a, stu b) {\n        return a.a < b.a;\n    }\n}s[N];\nstruct Node {\n    int l, r, cnt;\n    i64 sum;\n}t[N*40];\nvoid pushUp(int k) {\n    t[k].sum = t[t[k].l].sum + t[t[k].r].sum;\n    t[k].cnt = t[t[k].l].cnt + t[t[k].r].cnt;\n}\nvoid modify(int &k, int bk, int l, int r, int val) {\n    if(!k) k = ++ tot;\n    if(l == r) {\n        t[k].sum = t[bk].sum + val;\n        t[k].cnt = t[bk].cnt + 1;\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    if(val <= mid) {\n        t[k].r = t[bk].r;\n        modify(t[k].l, t[bk].l, l, mid, val);\n    } else {\n        t[k].l = t[bk].l;\n        modify(t[k].r, t[bk].r, mid+1, r, val);\n    }\n    pushUp(k);\n}\ni64 query(int k1, int k2, int l, int r, int x) {\n    // std :: cout << l << ' ' << r << endl;\n    if(l == r) return l * x;\n    if(t[k1].cnt - t[k2].cnt <= x)\n        return t[k1].sum - t[k2].sum;\n    int mid = (l + r) >> 1;\n    int res = t[t[k1].l].cnt - t[t[k2].l].cnt;\n    if(res >= x)\n        return query(t[k1].l, t[k2].l, l, mid, x);\n    return query(t[k1].l, t[k2].l, l, mid, res) + \n        query(t[k1].r, t[k2].r, mid+1, r, x-res);\n}\nvoid solve() {\n    std :: cin >> n >> c >> f;\n    for(int i = 1; i <= c; ++ i)\n        std :: cin >> s[i].a >> s[i].b;\n    std :: sort(s + 1, s + 1 + c);\n\n    for(int i = 1; i <= c; ++ i)\n        modify(rt[i], rt[i-1], 0, Range, s[i].b);\n    // for(int i = 1; i <= c; ++ i) {\n    //     std :: cout << query(rt[i], rt[0], 0, Range, 1) << endl;\n    // }\n    n >>= 1;\n    for(int i = c - n; i >= n + 1; -- i) {\n        i64 sum = query(rt[c], rt[i], 0, Range, n) + \n            query(rt[i-1], rt[0], 0, Range, n) + s[i].b;\n        if(sum > f) continue;\n        std :: cout << s[i].a;\n        return ;\n    }\n    std :: cout << -1;\n}\nsigned main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["主席树"],"categories":["题解","Luogu"]},{"title":"洛谷 P3939 数颜色题解","url":"/post/1580322897.html","content":"<center> 洛谷 P3939 数颜色题解 </center>\n<!--more-->\n\n[原题链接](https://www.luogu.com.cn/problem/P3939)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/Luogu%20P3939.png)\n#### Sample Input\n\n```\n6 5 \n1 2 3 2 3 3  \n1 1 3 2 \n1 4 6 3  \n2 3 \n1 1 3 2  \n1 4 6 3\n```\n\n#### Sample Output\n\n```\n1 \n2 \n2 \n3\n```\n\n#### 解析：\n\n主席树裸题。\n\n查询时，只需要 $r$ 这个版本的颜色总数减去 $l-1$ 这个版本的颜色总数。\n\n修改时，只需要修改一下 $l$ 版本的线段树，减去 $col[l]$ ，加上 $col[l+1]$ 即可。\n\n$l + 1$ 这个版本是不用动的，因为主席树维护的就是前缀和的信息，$col[l]$ 和 $col[l+1]$ 交换不会影响 $l+1$ 版本。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int Range = 3e5;\nconst int N = 3e5 + 20;\nint n, m, col[N], rt[N<<7], tot;\nstruct Node {\n    int l, r, sum;\n}t[N<<7];\nvoid modify(int &k, int bk, int l, int r, int val, int x) {\n    k = ++ tot; t[k] = t[bk]; t[k].sum += x;\n    if(l == r) return ;\n    int mid = (l + r) >> 1;\n    if(val <= mid) modify(t[k].l, t[bk].l, l, mid, val, x);\n    else modify(t[k].r, t[bk].r, mid+1, r, val, x);\n}\nint query(int k1, int k2, int l, int r, int val) {\n    if(l == r) return t[k1].sum - t[k2].sum;\n    int mid = (l + r) >> 1;\n    if(val <= mid) return query(t[k1].l, t[k2].l, l, mid, val);\n    else return query(t[k1].r, t[k2].r, mid+1, r, val);\n}\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> col[i];\n    for(int i = 1; i <= n; ++ i)\n        modify(rt[i], rt[i-1], 1, Range, col[i], 1);\n    for(int i = 1; i <= m; ++ i) {\n        int opt, l, r, c;\n        std :: cin >> opt >> l;\n        if(opt == 1) {\n            std :: cin >> r >> c;\n            std :: cout << query(rt[r], rt[l-1], 1, Range, c) << endl;\n        } else {\n            modify(rt[l], rt[l], 1, Range, col[l], -1);\n            modify(rt[l], rt[l], 1, Range, col[l+1], 1);\n            std :: swap(col[l], col[l+1]);\n        }\n    }\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["主席树"],"categories":["题解","Luogu"]},{"title":"CF 1324E - Sleeping Schedule题解","url":"/post/3247311213.html","content":"<center> CF 1324E - Sleeping Schedule题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1324/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201324E.png)\n\n#### Sample Input\n\n```\n7 24 21 23\n16 17 14 20 20 11 22\n```\n\n#### Sample Output\n\n```\n3\n```\n\n#### 解析：\n\n线性 $DP$ 题。\n\n设 $dp[i][j]$ 为第 $i$ 天时刻为 $j$ 时的最大答案。\n\n转移方程为 $f[i][j] = max(f[i-1][j-a[i]],f[i-1][j-a[i]+1]) + (l \\leq j \\And\\And j \\leq r)$\n\n答案即 ​​​$\\max \\limits _{i=0} ^{h-1} {dp[n][i]}$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2023;\nint n, h, l, r, dp[N][N];\nvoid solve() {\n\tstd :: cin >> n >> h >> l >> r;\n\tstd :: vector <int> a(n);\n\tmemset(dp, -0x3f, sizeof dp); dp[0][0] = 0;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> a[i];\n\tfor(int i = 1; i <= n; ++ i)\n\t\tfor(int j = 0; j < h; ++ j)\n\t\t\tdp[i][j] = std :: max(dp[i-1][(j-a[i]+h)%h], dp[i-1][(j-a[i]+1+h)%h]) + (l <= j && j <= r);\n\tint ans = 0;\n\tfor(int i = 0; i < h; ++ i)\n\t\tans = std :: max(ans, dp[n][i]);\n\tstd :: cout << ans;\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["线性dp","DP"],"categories":["题解","CF"]},{"title":"CF 1288C - Two Arrays题解","url":"/post/2333156433.html","content":"<center> CF 1288C - Two Arrays题解 </center>\n\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1288/C)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201288C.png)\n#### Sample Input\n\n```\n723 9\n```\n\n#### Sample Output\n\n```\n157557417\n```\n\n#### 解析：\n\n一道线性 $DP$ 题目。\n\n记 $f[0/1][i][j]$ 为不降 $/$ 不减序列在第 $i$ 位上为 $j$ 的方案数。\n\n转移方程为\n\n$$f[0][i][j] = \\sum \\limits _{h=1} ^{j} {f[0][i-1][h]}$$\n\n$$f[1][i][j] = \\sum \\limits _{h=j} ^{n} {f[1][i-1][h]}$$\n\n最后的答案即为 $\\sum \\limits _{i=1} ^{n} \\sum \\limits _{j=i} ^{n} {f[0][n][i] * f[1][n][j]}$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1010;\nint n, m;\ni64 f[2][15][N];\nvoid solve() {\n    std :: cin >> n >> m;\n    for(int i = 1; i <= n; ++ i)\n        f[0][1][i] = f[1][1][i] = 1;\n    for(int i = 2; i <= m; ++ i) {\n        i64 res = 0;\n        for(int j = 1; j <= n; ++ j) {\n            res = (res + f[0][i-1][j]) % Mod;\n            f[0][i][j] = res;\n        }\n    }\n    for(int i = 2; i <= m; ++ i) {\n        i64 res = 0;\n        for(int j = n; j >= 1; -- j) {\n            res = (res + f[1][i-1][j]) % Mod;\n            f[1][i][j] = res;\n        }\n    }\n    i64 ans = 0;\n    for(int i = 1; i <= n; ++ i)\n        for(int j = i; j <= n; ++ j)\n            ans = (ans + f[0][m][i] * f[1][m][j] % Mod) % Mod;\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n","tags":["线性dp","DP"],"categories":["题解","CF"]},{"title":"CF 1398D - Colored Rectangles题解","url":"/post/3804056477.html","content":"<center> CF 1398D - Colored Rectangles题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1398/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%201398D.png)\n\n#### Sample Input\n\n```\n10 1 1\n11 7 20 15 19 14 2 4 13 14\n8\n11\n```\n\n#### Sample Output\n\n```\n372\n```\n\n#### 解析：\n\n容易发现， $R,G,B$ 不超过 $200$ ，可以使用 $O(RGB)$ 的复杂度通过这个题，可以考虑 $dp$ 。\n\n设 $dp[i][j][k]$ 为 $R,G,B$ 三种颜色分别选择前 $i,j,k$ 个所产生的最大面积。\n\n当每一次选择时就有三种情况：\n\n1. 选择 $R,G$ ， $dp[i][j][k] = dp[i-1][j-1][k] + R[i] \\times G[j]$ 。\n2. 选择 $R, B$ ， $dp[i][j][k] = dp[i-1][j][k-1] + R[i] \\times B[k]$ 。\n3. 选择 $G,B$ ， $dp[i][j][k] = dp[i][j-1][k-1] + G[j] \\times B[k]$ 。\n\n总的方程就是\n\n$$dp[i][j][k] = max(dp[i-1][j-1][k] + R[i] \\times G[j], dp[i-1][j][k-1]) + R[i] \\times B[k], dp[i][j-1][k-1] + G[j] \\times B[k])$$\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2020;\nint r, g, b, R[N], G[N], B[N];\ni64 dp[220][220][220];\ni64 dfs(int a, int b, int c) {\n    if(dp[a][b][c]) return dp[a][b][c];\n    if(a && b) dp[a][b][c] = std :: max(dp[a][b][c],\n        dfs(a-1, b-1, c) + R[a] * G[b]);\n    if(a && c) dp[a][b][c] = std :: max(dp[a][b][c],\n        dfs(a-1, b, c-1) + R[a] * B[c]);\n    if(b && c) dp[a][b][c] = std :: max(dp[a][b][c],\n        dfs(a, b-1, c-1) + G[b] * B[c]);\n    return dp[a][b][c];\n}\nvoid solve() {\n    std :: cin >> r >> g >> b;\n    for(int i = 1; i <= r; ++ i)\n        std :: cin >> R[i];\n    for(int i = 1; i <= g; ++ i)\n        std :: cin >> G[i];\n    for(int i = 1; i <= b; ++ i)\n        std :: cin >> B[i];\n    std :: sort(R + 1, R + 1 + r);\n    std :: sort(G + 1, G + 1 + g);\n    std :: sort(B + 1, B + 1 + b);\n    std :: cout << dfs(r, g, b);\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["DP","记忆化搜索"],"categories":["题解","CF"]},{"title":"CF 577B - Modulo Sum题解","url":"/post/708848240.html","content":"<center> CF 577B - Modulo Sum题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/577/B)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20577B.png)\n#### Sample Input\n\n```\n6 6\n5 5 5 5 5 5\n```\n\n#### Sample Output\n\n```\nYES\n```\n\n#### 解析：\n\n取子序列的和为某一个值，容易联想到 $01$ 背包，但是 $n$ 有 $10^6$ 且 $a_i$ 的范围为 $[0,10^9]$ ，显然是不可行的。\n\n由于子序列的和是 $m$ 的倍数即可，不妨先将 $a_i$ 均模上 $m$ ，这样 $a$ 数组的范围就缩小到了 $10^3$ 级别。\n\n当 $n$ 大于 $m$ 时，我们可以想到，将 $a$ 数组求一个前缀和，那么就会有 $n$ 个前缀和，再加上对 $m$ 取模，相当于将 $n$ 个数对应 $m$ 个数。\n\n我们就会想到抽屉原理，抽屉原理指的是`将n+1个物体，划分为n组，那么有至少一组有两个（或以上）的物体。`\n\n则就是说，一定存在两个前缀和值相等，则该两个数的位置之间的子数组的和为 $m$ 的倍数。\n\n即，当 $n$ 大于 $m$ 时，一定存在子序列的和等于 $m$ 的倍数。\n\n当 $n$ 小于等于 $m$ 时，由于 $n,m \\leq 10^3$，则可以进行 $01$ 背包。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nconst int M = 1e3 + 20;\nint a[N], f[M][M], n, m;\nvoid solve() {\n\tstd :: cin >> n >> m;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> a[i], a[i] %= m;\n\tif(n > m) {\n\t\tstd :: cout << \"YES\";\n\t\treturn ;\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tf[i][a[i]] = 1;\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tf[i][j] |= f[i-1][j];\n\t\t\tf[i][(j+a[i])%m] |= f[i-1][j];\n\t\t}\n\t\tif(f[i][0] == 1) {\n\t\t\tstd :: cout << \"YES\";\n\t\t\treturn ;\n\t\t}\n\t}\n\tstd :: cout << \"NO\";\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["前缀和","01背包","抽屉原理"],"categories":["题解","CF"]},{"title":"CF 600E-Lomsat gelral题解","url":"/post/1680840527.html","content":"<center> CF 600E - Lomsat gelral题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/600/E)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20600E.png)\n\n#### Sample Input\n\n```\n15\n1 2 3 1 2 3 3 1 1 3 2 2 1 2 3\n1 2\n1 3\n1 4\n1 14\n1 15\n2 5\n2 6\n2 7\n3 8\n3 9\n3 10\n4 11\n4 12\n4 13\n```\n\n#### Sample Output\n\n```\n6 5 4 3 2 3 3 1 1 3 2 2 1 2 3\n```\n\n#### 解析：\n\n解析见[树上启发式合并（dsu on tree）小结](https://atmizz.github.io/post/4180854850.html)\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint son[N], head[N], cnt, num[N], col[N], n, sz[N];\ni64 ans[N], sum, maxx;\nstruct Edge {\n\tint to, net;\n}e[N<<1];\nvoid Insert(int u, int v) {\n\te[++cnt] = {v, head[u]};\n\thead[u] = cnt;\n}\nvoid dfsSon(int u, int fa) {\n\tsz[u] = 1;\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa) continue;\n\t\tdfsSon(v, u); sz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\nvoid count(int u, int fa, int pson, int val) {\n\tint c = col[u];\n\tnum[c] += val;\n\tif(num[c] > maxx) maxx = num[c], sum = c;\n\telse if(num[c] == maxx) sum += c;\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == pson) continue;\n\t\tcount(v, u, pson, val);\n\t}\n}\nvoid dfs(int u, int fa, bool keep) {\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == son[u]) continue;\n\t\tdfs(v, u, 0);\n\t}\n\tif(son[u]) dfs(son[u], u, 1);\n\tcount(u, fa, son[u], 1);\n\tans[u] = sum;\n\tif(!keep) {\n\t\tcount(u, fa, 0, -1);\n\t\tsum = maxx = 0;\n\t}\n}\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> col[i];\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint u, v; std :: cin >> u >> v;\n\t\tInsert(u, v); Insert(v, u);\n\t}\n\tdfsSon(1, 1); dfs(1, 1, 1);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cout << ans[i] << ' ';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["树上启发式合并"],"categories":["题解","CF"]},{"title":"树上启发式合并（dsu on tree）小结","url":"/post/3958277707.html","content":"<center> 树上启发式合并（dsu on tree）小结 </center>\n<!--more-->\n\n## 算法介绍\n\n树上启发式合并英文名叫 `dsu on tree` ，其中 $dsu$ 就是并查集的意思，但是这个算法并用不到并查集，应该是受并查集的启发式合并的启发应用到树上的。\n\n其中**启发式合并**的意思就是，两个集合需要合并，将元素少的集合合并到元素多的集合。\n\n树上启发式合并的意思就是，轻子树的贡献并入重子树。\n\n树上启发式合并优点在于，对于某些树上离线问题可以速度大于等于大部分算法且更易于理解和实现的算法。\n\n树上启发式合并合并所能解决的问题有以下特性：\n1. 只有对子树的查询。\n2. 没有修改操作。\n\n由一道题目进行引入，[CF 600E-Lomsat gelral](https://codeforces.com/problemset/problem/600/E)\n\n题目大意：给定一棵树，每个节点上都有一种颜色，从节点 $1$ 到节点 $n$ ，输出以当前节点为根的子树内出现的最多的颜色的编号和。\n\n首先，我们肯定能想到暴力，复杂度是 $O(N^2)$ ，显然是不优秀的。\n\n当然了，我们也能想到可以将树上问题转化为序列问题，然后莫队一下，那样的话，复杂度就来到了 $O(N \\sqrt{N})$ ，但是还不是太优秀。\n\n我们考虑优化暴力，有一种优化策略是这样的：\n\n记**答案**为最终的输出结果，**贡献**为记录各种颜色个数的数组。\n\n对于当前节点来说，\n1. 我们将每个儿子按照树链剖分一样分轻、重儿子，\n2. 优先遍历轻儿子，轻儿子的子树优先计算**答案**，但是不保留轻儿子的子树对当前节点的**贡献**。\n3. 然后遍历重儿子，计算重儿子子树的**答案**，并且保留其对当前节点的**贡献**。\n4. 再次遍历轻儿子，计算轻儿子的子树的**贡献**，与重儿子子树的**贡献**合并为当前节点的**答案**。\n5. 如果当前节点是轻儿子，当前节点的子树的**贡献**。\n\n上述优化策略即为树上启发式合并，时间复杂度为 $O(NlogN)$ ，这是非常优秀的。\n\n简单小证明：对于某一点来说，最坏情况下是一直处在轻链中，一直会被删除，而轻链最多有 $logN$ 个（我道听途说的），即该点最多会被各计算和删除 $logN$ 次，则总体复杂度为 $O(NlogN)$ 。\n\n## 代码详解\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 20;\nint son[N], head[N], cnt, num[N], col[N], n, sz[N];\ni64 ans[N], sum, maxx;\nstruct Edge {\n\tint to, net;\n}e[N<<1];\nvoid Insert(int u, int v) {\n\te[++cnt] = {v, head[u]};\n\thead[u] = cnt;\n}\nvoid dfsSon(int u, int fa) { // 找出每个节点的轻重儿子\n\tsz[u] = 1;\n\tfor(int i = head[u]; i; i = e[i].net) {\n\t\tint v = e[i].to;\n\t\tif(v == fa) continue;\n\t\tdfsSon(v, u); sz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v; // 当前儿子节点数多，那就是重儿子\n\t}\n}\nvoid count(int u, int fa, int pson, int val) { \n// pson 指的是dfs函数中当前节点的重儿子，我们只保留重儿子的贡献，而不会保留轻儿子的重儿子的贡献。\n// val 指的是计算/删除贡献。\n\tint c = col[u];\n\tnum[c] += val;\n\tif(num[c] > maxx) maxx = num[c], sum = c;\n\telse if(num[c] == maxx) sum += c;\n\tfor(int i = head[u]; i; i = e[i].net) { // 计算/删除dfs中u的轻子树的贡献\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == pson) continue; // 注意是pson，非son[u]。因为只保留dfs中u的重子树的贡献，而不是每一个轻儿子的重儿子。\n\t\tcount(v, u, pson, val);\n\t}\n}\nvoid dfs(int u, int fa, bool keep) { // keep表示是否为重儿子\n\tfor(int i = head[u]; i; i = e[i].net) { // 优先遍历轻儿子\n\t\tint v = e[i].to;\n\t\tif(v == fa || v == son[u]) continue;\n\t\tdfs(v, u, 0);\n\t}\n\tif(son[u]) dfs(son[u], u, 1); // 最后遍历重儿子\n\tcount(u, fa, son[u], 1); // 计算以 u 为根的子树答案\n\tans[u] = sum; // 离线记录答案\n\tif(!keep) { // 轻儿子要删除其子树的贡献\n\t\tcount(u, fa, 0, -1); // 注意pson为-1，即当前轻儿子的子树全部删除贡献\n\t\tsum = maxx = 0; // 不对下一次答案统计造成影响。\n\t}\n}\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> col[i];\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint u, v; std :: cin >> u >> v;\n\t\tInsert(u, v); Insert(v, u);\n\t}\n\tdfsSon(1, 1);\n\tdfs(1, 1, 1);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cout << ans[i] << ' ';\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n- 参考文献\n[C语言网 树上启发式合并](https://www.dotcpp.com/course/1054)\n[AgOHの算法胡扯 树上启发式合并（dsu on tree）](https://www.bilibili.com/video/BV1JE411d7tD?p=1&vd_source=f1b67e1f6e1304f6b7fc4bb2ddcc67ab)\n","tags":["树上启发式合并"],"categories":["笔记","树上操作","树上启发式合并"]},{"title":"CF 86D - Powerful array题解","url":"/post/1166923456.html","content":"<center> CF 86D - Powerful array题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/contest/86/problem/D)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%2086D.png)\n\n#### Sample Input\n\n```\n3 2\n1 2 1\n1 2\n1 3\n```\n\n#### Sample Output\n\n```\n3\n6\n```\n\n#### 解析：\n\n这个题是普通莫队的模板题。\n\n普通莫队就是离线处理区间问题的算法。\n\n其精髓在于`将询问区间排序，然后把当前询问结果当作下一个询问区间的基础`。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e6 + 20;\nint a[N], cnt[N], n, m, l[N], r[N], block, blk[N];\ni64 ans[N], sum;\nstruct Node {\n    int l, r, id;\n    friend bool operator < (Node a, Node b) {\n        return (blk[a.l] ^ blk[b.l]) ? blk[a.l] < blk[b.l] : (blk[a.l] & 1 ?\n         a.r < b.r : a.r > b.r);\n    }\n}q[N];\nvoid add(int x) {\n    sum -= (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n    cnt[a[x]] ++;\n    sum += (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n}\nvoid del(int x) {\n    sum -= (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n    cnt[a[x]] --;\n    sum += (i64)cnt[a[x]] * cnt[a[x]] * a[x];\n}\nvoid solve() {\n    std :: cin >> n >> m; block = pow(n, 2.0 / 3);\n    for(int i = 1; i <= n; ++ i)\n        blk[i] = (i - 1) / block + 1;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 1; i <= m; ++ i)\n        std :: cin >> q[i].l >> q[i].r, q[i].id = i;\n    std :: sort(q + 1, q + 1 + m);\n    int l = 0, r = 0;\n    for(int i = 1; i <= m; ++ i) {\n        while(l < q[i].l) del(l ++);\n        while(l > q[i].l) add(-- l);\n        while(r < q[i].r) add(++ r);\n        while(r > q[i].r) del(r --);\n        ans[q[i].id] = sum;\n    }\n    for(int i = 1; i <= m; ++ i)\n        std :: cout << ans[i] << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n","tags":["普通莫队"],"categories":["题解","CF"]},{"title":"CF 372A - Counting Kangaroos is Fun题解","url":"/post/1114312715.html","content":"<center> CF 372A - Counting Kangaroos is Fun题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/372/A)\n\n#### Problem Description\n\n![](https://raw.githubusercontent.com/Atmizz/picturebox/main/Github_blog/pictures/CF%20372A.png)\n\n#### Sample Input\n\n```\n8\n2\n5\n7\n6\n9\n8\n4\n2\n```\n\n#### Sample Output\n\n```\n5\n```\n\n#### 解析：\n\n二分可以被收纳的袋鼠的数量，答案就是 $n - ans$ 。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 5e5 + 20;\nint n, a[N];\nbool check(int x) {\n\tint y = n;\n\tfor(int i = x; i >= 1; -- i)\n\t\tif(a[y] >= 2 * a[i]) y --;\n\t\telse return false;\n\treturn true;\n}\nvoid solve() {\n\tstd :: cin >> n;\n\tfor(int i = 1; i <= n; ++ i)\n\t\tstd :: cin >> a[i];\n\tstd :: sort(a + 1, a + 1 + n);\n\tint l = 0, r = n / 2, ans;\n\twhile(l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\tstd :: cout << n - ans;\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```","tags":["二分"],"categories":["题解","CF"]},{"title":"CF 1437D - Minimal Height Tree题解","url":"/post/512996338.html","content":"<center> CF Constant Palindrome Sum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1437/D)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%201437D.png?raw=true)\n\n#### Sample Input\n\n```\n3\n4\n1 4 3 2\n2\n1 2\n3\n1 2 3\n```\n\n#### Sample Output\n\n```\n3\n1\n1\n```\n\n#### 解析：\n\n按照题意模拟即可，有从小到大的连续的数字就放到一个节点当儿子，遇到大的就退出。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, a[N], dep[N];\nvoid solve() {\n    std :: cin >> n; int k = 2;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    std :: queue <int> q;\n    q.push(a[1]);\n    while(q.size()) {\n        int u = q.front(); q.pop();\n        if(k <= n) {\n            dep[a[k]] = dep[u] + 1;\n            q.push(a[k]);\n            k ++;\n        }\n        for(; k <= n; ++ k) {\n            if(a[k] > a[k-1]) dep[a[k]] = dep[u] + 1, q.push(a[k]);\n            else break;\n        }\n    }\n    std :: cout << dep[a[n]] << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n","tags":["队列"],"categories":["题解","CF"]},{"title":"CF 295B - Greg and Graph题解","url":"/post/1845811931.html","content":"<center> CF 295B - Greg and Graph题解 </center>\n\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/295/B)\n\n#### Problem Description\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/CF%20295B.png?raw=true)\n\n#### Sample Input\n\n```\n4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n4 1 2 3\n```\n\n#### Sample Output\n\n```\n17 23 404 0\n```\n\n#### 解析：\n\n乍一眼看，感觉是 $Floyd$ 板子，其实确实是。\n\n正着删点跑 $Floyd$ 的复杂度是 $O(n^4)$ ，显然要寄。\n\n我们可以发现，可以正难则反。\n\n一个一个加入点，然后用这个点去松弛其他边，然后记录答案即可。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 550;\ni64 d[N][N], n, ans[N], arr[N];\nbool vis[N];\nvoid solve() {\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i)\n        for(int j = 1; j <= n; ++ j)\n            std :: cin >> d[i][j];\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> arr[i];\n    for(int h = n; h >= 1; -- h) {\n        int k = arr[h]; vis[k] = 1;\n        for(int i = 1; i <= n; ++ i)\n            for(int j = 1; j <= n; ++ j)\n                d[i][j] = std :: min(d[i][j], d[i][k] + d[k][j]);\n\n        for(int i = 1; i <= n; ++ i)\n            for(int j = 1; j <= n; ++ j)\n                if(vis[i] == 1 && vis[j] == 1)\n                    ans[h] += d[i][j];\n\n    }\n    for(int i = 1; i <= n; ++ i)\n        std :: cout << ans[i] << ' ';\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```","tags":["Floyd"],"categories":["题解","CF"]},{"title":"CF 343B - Alternating Current题解","url":"/post/1380942808.html","content":"<center> CF 343B - Alternating Current题解 </center>\n\n<!--more-->\n\n#### Problem Description\n\nMad scientist Mike has just finished constructing a new device to search for extraterrestrial intelligence! He was in such a hurry to launch it for the first time that he plugged in the power wires without giving it a proper glance and started experimenting right away. After a while Mike observed that the wires ended up entangled and now have to be untangled again.\n\nThe device is powered by two wires \"plus\" and \"minus\". The wires run along the floor from the wall (on the left) to the device (on the right). Both the wall and the device have two contacts in them on the same level, into which the wires are plugged in some order. The wires are considered entangled if there are one or more places where one wire runs above the other one. For example, the picture below has four such places (top view):\n\n![](https://espresso.codeforces.com/d9893064977f0a3ba06c4b18908f20c7ef488731.png)\n\nMike knows the sequence in which the wires run above each other. Mike also noticed that on the left side, the \"plus\" wire is always plugged into the top contact (as seen on the picture). He would like to untangle the wires without unplugging them and without moving the device. Determine if it is possible to do that. A wire can be freely moved and stretched on the floor, but cannot be cut.\n\nTo understand the problem better please read the notes to the test samples.\n\n#### Input\n\nThe single line of the input contains a sequence of characters \"+\" and \"-\" of length $n$ ($1 ≤ n ≤ 100000$). The $i$-th ($1 ≤ i ≤ n$) position of the sequence contains the character \"+\", if on the _i_-th step from the wall the \"plus\" wire runs above the \"minus\" wire, and the character \"-\" otherwise.\n\n#### Output\n\nPrint either \"Yes\" (without the quotes) if the wires can be untangled or \"No\" (without the quotes) if the wires cannot be untangled.\n\n#### Sample Input1\n\n```\n-++-\n```\n\n#### Sample Output1\n\n```\nYes\n```\n\n#### Sample Input2\n\n```\n+-\n```\n\n#### Sample Output2\n\n```\nNo\n```\n\n#### 题目大意\n\n[原题链接](https://codeforces.com/problemset/problem/343/B)\n\n给定两个线的上下顺序，问是否能够理顺。\n\n#### 解析\n\n刚看上去没思路，一开始猜首尾相同即可解开电线，然后特判长度为 $1$ 的情况。结果就是 $WA$ 了第 $6$ 个点。\n\n​然后又思索了一下，发现其实很简单。\n\n​简单来说，当你把红线放下面时，必定后续有一个操作是把红线放下面，且中间的操作是可以把线理顺的。\n\n​这样说来的话，就像括号匹配一样，找到一个完美匹配的加减序列。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 1e6 + 20;\nchar str[N];\nvoid solve() {\n\tscanf(\"%s\", str);\n\tint n = strlen(str);\n\tstd :: stack <char> s;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tif(s.empty()) s.push(str[i]);\n\t\telse {\n\t\t\tchar temp = s.top();\n\t\t\tif(temp == str[i]) s.pop();\n\t\t\telse s.push(str[i]);\n\t\t}\n\t}\n\tstd :: cout << (s.size() ? \"No\" : \"Yes\");\n}\nint main() {\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.out\", \"w\", stdout);\n\tstd :: ios :: sync_with_stdio(false);\n\tstd :: cin.tie(0);\n\tstd :: cout.tie(0);\n\tint T = 1;\n\t//std :: cin >> T; \n\twhile(T --) solve();\n\treturn 0;\n}\n```\n\n","tags":["solutions","栈"],"categories":["题解","CF"]},{"title":"CF 1396A - Multiples of Length题解","url":"/post/38088069.html","content":"<center> CF 1333C - Eugene and an array题解 </center>\n\n<!--more-->\n\n#### Problem Description\n\nEugene likes working with arrays. And today he needs your help in solving one challenging task.\n\nAn array $c$ is a subarray of an array $b$ if $c$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\nLet's call a nonempty array **good** if for every nonempty subarray of this array, sum of the elements of this subarray is nonzero. For example, array $[-1, 2, -3]$ is **good**, as all arrays $[-1]$, $[-1, 2]$, $[-1, 2, -3]$, $[2]$, $[2, -3]$, $[-3]$ have nonzero sums of elements. However, array $[-1, 2, -1, -3]$ isn't **good**, as his subarray $[-1, 2, -1]$ has sum of elements equal to $0$.\n\nHelp Eugene to calculate the number of nonempty **good** subarrays of a given array $a$.\n\n#### Input \n\nThe first line of the input contains a single integer $n$ ($1 \\le n \\le 2 \\times 10^5$)  — the length of array $a$.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$)  — the elements of $a$.\n\n#### Output\n\nOutput a single integer  — the number of **good** subarrays of $a$.\n\n#### Sample Input\n\n```\n3\n1 2 -3\n```\n\n#### Sample Output\n\n```\n5\n```\n\n#### 题目大意\n\n[原题链接](https://codeforces.com/problemset/problem/1333/C)\n\n这道题要找出所有的**好**区间（其子区间和均不为 $0$ ）。\n\n#### 解析：\n\n​首先肯定能想到 $O(n^2)$ 暴力，但是 $n \\leq 2e5$ ，显然是不能接受的。\n\n​再次读题，我们会发现，我们不需要枚举所有的区间，我们可以只枚举右端点，然后找到使得区间最大，但是区间内无区间和为 $0$ 的左端点，即区间 $[x+1,y]$ ，但是为了求答案方便，此处求 $[x,y]$ ，那么就会对答案贡献 $y-x$ 。\n\n​那么如何找到最小的左端点呢？\n\n​假设当前扫到了 $j$ 这个位置，前方有一个最近的区间和为 $0$ 的区间 $[a, b]$ ，且以 $j$ 为右端点的区间 $[i,j]$ 的区间和为 $0$，那么左端点就应该是 $max(a,i)$。\n\n​我们可以设 $lst$ 为前方最近的区间和为 $0$ 的区间 $[a, b]$ 中的 $a$。\n\n​我们可以讨论一下是否有以 $j$ 为右端点的区间和为 $0$ 的区间 $[i,j]$ 。\n\n​如果有的话，那就更新 $lst$ 和 $i$ 取大值更新 $lst$ 。\n\n​那么此时答案贡献为 $j - lst$ 。\n\n​求区间和不难，利用前缀和和 $map$ 即可。\n\n​同时注意，这个求法只能讨论区间内元素大于 $1$ 的情况，还要考虑单个元素的情况。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, a[N];\ni64 sum[N];\nvoid solve() {\n    int n;\n    std :: cin >> n;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    std :: map <i64, int> cnt;\n    for(int i = 1; i <= n; ++ i)\n        sum[i] = sum[i-1] + a[i];\n    i64 ans = 0; int lst = 0;\n    cnt[0] = 0;\n    for(int i = 1; i <= n; ++ i) {\n        if(cnt.count(sum[i])) lst = std :: max(lst, cnt[sum[i]] + 1);\n        ans += i - lst;\n        if(lst == i && a[i] != 0) ans ++;\n        cnt[sum[i]] = i;\n    }\n    std :: cout << ans;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    //std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n","tags":["solutions","前缀和","map"],"categories":["题解","CF"]},{"title":"CF 1343D - Constant Palindrome Sum题解","url":"/post/1967339.html","content":"<center> CF 1343D - Constant Palindrome Sum题解 </center>\n<!--more-->\n\n[原题链接](https://codeforces.com/problemset/problem/1343/D)\n\n#### Problem Description\n\nYou are given an array $a$ consisting of $n$ integers (it is guaranteed that $n$ is even, i.e. divisible by $2$). All $a_i$ does not exceed some integer $k$.\n\nYour task is to replace the **minimum** number of elements (replacement is the following operation: choose some index $i$ from $1$ to $n$ and replace $a_i$ with some integer in range $[1; k]$) to satisfy the following conditions:\n\n-   after all replacements, all $a_i$ are positive integers not greater than $k$;\n-   for all $i$ from $1$ to $\\frac{n}{2}$ the following equation is true: $a_i + a_{n - i + 1} = x$, where $x$ should be **the same** for all $\\frac{n}{2}$ pairs of elements.\n\nYou have to answer $t$ independent test cases.\n\n#### Input\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5, 1 \\le k \\le 2 \\cdot 10^5$) — the length of $a$ and the maximum possible value of some $a_i$ correspondingly. It is guratanteed that $n$ is even (i.e. divisible by $2$). The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the $i$\\-th element of $a$.\n\nIt is guaranteed that the sum of $n$ (as well as the sum of $k$) over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$, $\\sum k \\le 2 \\cdot 10^5$).\n\n#### Output\n\nFor each test case, print the answer — the **minimum** number of elements you have to replace in $a$ to satisfy the conditions from the problem statement.\n\n#### Sample Input\n\n```\n4\n4 2\n1 2 1 2\n4 3\n1 2 2 1\n8 7\n6 1 1 7 6 3 4 6\n6 6\n5 2 6 1 3 4\n```\n\n#### Sample Output\n\n```\n0\n1\n4\n2\n```\n\n#### 题目大意：\n\n给出一个长度为 $n$ 的数列 $a_i$​ 和 $k$，其中保证 $1 \\leq a_i \\leq k$。\n\n将 $a$ 中任意一数 $a_i$​ 改成 $[1,k]$ 中的一个数称为一次操作。\n\n问最少经过多少次操作后，$a_i​+a_{n−i+1}$​（$i \\leq \\frac{n}{2}$​）全部相等。\n\n#### 解析：\n\n这道题初看确实没有什么眉目，还是看[一个大佬的题解](https://www.dreamwings.cn/codeforces1343d/5620.html)才会的。\n\n​浏览一遍题目，我们会发现每一个数和修改后的数都是在 $[1, k]$ 范围以内，而且对于一对数，最多修改 $2$ 次，则就会有以下三种情况产生。\n\n  1. 修改 $0$ 次。 $a[i] + a[n-i+1] = x$ ，则在 $[x,x]$ 范围内贡献的修改次数为 $0$ 。\n  2. 修改 $1$ 次。 则对区间 $[min(a[i],a[n-i+1])+1, max(a[i], a[n-i+1]) + k]$ 贡献的修改次数为 $1$ 。\n  3. 修改 $2$ 次。 则对区间 $[2, k \\times 2]$ 贡献的修改次数为 $2$ 。\n\n那我们就从 $2$ 一直扫到 $k \\times 2$ 找到一个值 $x$ ，使得所有数对都等于 $x$ 时修改次数最小。\n\n涉及到区间修改和单点查询，可以使用线段树和差分。我这里使用的差分，写起来更简单一些。\n\n```cpp\n#include <bits/stdc++.h>\n//#pragma GCC optimize(2)\n#define ls k << 1\n#define rs k << 1 | 1\n#define pi std :: pair<int, int>\n#define endl \"\\n\"\n#define deb(x) std :: cout << #x << \" = \" << x << '\\n';\n#define DEB std :: cout << \"ok\" << endl;\nusing i64 = long long;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int Mod = 1e9 + 7;\nconst int N = 2e5 + 20;\nint n, k, a[N], diff[N<<1];\nvoid solve() {\n    std :: cin >> n >> k;\n    for(int i = 1; i <= n; ++ i)\n        std :: cin >> a[i];\n    for(int i = 2; i <= k << 1; ++ i)\n        diff[i] = 0;\n    int ans = INF;\n    for(int i = 1; i <= n >> 1; ++ i) {\n        int x = std :: min(a[i], a[n-i+1]);\n        int y = std :: max(a[i], a[n-i+1]);\n        // 2 [2, 2k]\n        // 1 [x+1, y+k]\n        // 0 [x+y,x+y]\n        diff[2] += 2; diff[2*k+1] -= 2;\n        diff[x+1] -= 1; diff[y+k+1] += 1;\n        diff[x+y] -= 1; diff[x+y+1] += 1;\n    }\n    for(int i = 2; i <= k << 1; ++ i) {\n        diff[i] += diff[i-1];\n        ans = std :: min(ans, diff[i]);\n    }\n    std :: cout << ans << endl;\n}\nint main() {\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    std :: ios :: sync_with_stdio(false);\n    std :: cin.tie(0);\n    std :: cout.tie(0);\n    int T = 1;\n    std :: cin >> T; \n    while(T --) solve();\n    return 0;\n}\n```\n\n## ","tags":["solutions","线段树","差分"],"categories":["题解","CF"]},{"title":"CF 1396A - Multiples of Length题解","url":"/post/2782429085.html","content":"<center> CF 1396A - Multiples of Length题解 </center>\n<!--more-->\n\n#### 题目描述\n\nYou are given an array $a$ of $n$ integers.\n\nYou want to make all elements of $a$ equal to zero by doing the following operation exactly three times:\n\n- Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment (added integers can be different).\n\nIt can be proven that it is always possible to make all elements of $a$ equal to zero.\n\n#### 输入格式\n\nThe first line contains one integer $n$ ($1 \\le n \\le 100\\,000$): the number of elements of the array.\n\nThe second line contains $n$ elements of an array $a$ separated by spaces: $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n#### 输出格式\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n- The first line contains two integers $l$, $r$ ($1 \\le l \\le r \\le n$): the bounds of the selected segment.\n\n- The second line contains $r-l+1$ integers $b_l, b_{l+1}, \\dots, b_r$ ($-10^{18} \\le b_i \\le 10^{18}$): the numbers to add to $a_l, a_{l+1}, \\ldots, a_r$, respectively; $b_i$ should be divisible by $r - l + 1$.\n\n#### 题目大意\n\n给你一个由个整数组成的数组。\n\n你想通过以下操作使中的所有元素都等于，操作次数正好为三次：\n\n-   选择一个段，对于这个段中的每个数字，我们可以向其添加的倍数，其中是这个段的长度（添加的整数可以不同）。\n\n可以证明，总是有可能使的所有元素都等于零。\n\n#### 输入样例\n\n```\n4\n1 3 2 4\n```\n\n#### 输出样例\n\n```\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6\n```\n\n#### 解析\n\n我们可以把$n$个数分为$1$和$[2,n]$，第一次操作把第$1$个数操作为$0$，第$2,3$次操作将$[2,n]$变为$0$。\n\n很显然有，$a[i] + (n-1) \\times a[i] = n \\times a[i]$。\n\n那么可以将$[2,n]$都加上一个$(n-1) \\times a[i]$，最后一次操作在$[1,n]$上减去一个$n \\times a[i]$。\n\n注意，$n=1$时要特判。\n\n#### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\n#define int ll\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 20;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN];\nsigned main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = read();\n  if(n == 1) {\n    printf(\"1 1\\n%lld\\n\", a[1]);\n    printf(\"1 1\\n%lld\\n\", a[1]);\n    printf(\"1 1\\n%lld\\n\", -3*a[1]);\n    return 0;\n  }\n  printf(\"1 1\\n%lld\\n\", -a[1]);\n  a[1] = 0;\n  printf(\"2 %lld\\n\", n);\n  for(int i = 2; i <= n; ++ i)\n    printf(\"%lld \", a[i] * (n-1));\n  puts(\"\");\n  printf(\"1 %lld\\n\", n);\n  for(int i = 1; i <= n; ++ i)\n    printf(\"%lld \", -n * a[i]);\n  return 0;\n}\n```","tags":["solutions","构造题"],"categories":["题解","CF"]},{"title":"CF 1353D - Constructing the Array题解","url":"/post/2782429083.html","content":"<center> CF 1353D - Constructing the Array题解 </center>\n<!--more-->\n\n#### 题目描述\n\nYou are given an array $a$ of length $n$ consisting of zeros. You perform $n$ actions with this array: during the $i$th action, the following sequence of operations appears:\n\n1. Choose the maximum by length subarray (continuous subsegment) consisting only of zeros, among all such segments choose the leftmost one;\n2. Let this segment be $[l; r]$. If $r-l+1$ is odd (not divisible by $2$) then assign (set) $a[\\frac{l+r}{2}] := i$ (where $i$ is the number of the current action), otherwise (if $r-l+1$ is even) assign (set) $a[\\frac{l+r-1}{2}] := i$.\n\nConsider the array $a$ of length $5$ (initially $a=[0, 0, 0, 0, 0]$). Then it changes as follows:\n\n1.  Firstly, we choose the segment $[1; 5]$ and assign $a[3] := 1$, so $a$ becomes $[0, 0, 1, 0, 0]$;\n2.  then we choose the segment $[1; 2]$ and assign $a[1] := 2$, so $a$ becomes $[2, 0, 1, 0, 0]$;\n3.  then we choose the segment $[4; 5]$ and assign $a[4] := 3$, so $a $ becomes $[2, 0, 1, 3, 0]$;\n4.  then we choose the segment $[2; 2]$ and assign $a[2] := 4$, so $a$ becomes $[2, 4, 1, 3, 0]$;\n5.  and at last we choose the segment $[5; 5]$ and assign $a[5] := 5$, so $a$ becomes $[2, 4, 1, 3, 5]$.\n\nYour task is to find the array $a$ of length $n$ after performing all $n$ actions. Note that the answer exists and unique.\n\nYou have to answer $t$ independent test cases.\n\n#### 输入格式\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n#### 输出格式\n\nFor each test case, print the answer — the array $a$ of length $n$ after performing $n$ actions described in the problem statement. Note that the answer exists and unique.\n\n#### 题目大意\n\n有​​​​​​$n$个位置，起初每一个位置都是$0$。\n\n然后进行$n$次操作，第$i$次操作为选取最长的只有的子段$[l,r]$，如果：\n\n- $r-l+1$为奇数，$a[\\frac{l+r}{2}]=i$\n    \n- $r-l+1$为偶数，​$a[\\frac{l+r-1}{2}]=i$\n\n#### 输入样例\n\n```\n6\n1\n2\n3\n4\n5\n6\n```\n\n#### 输出样例\n\n```\n1 \n1 2 \n2 1 3 \n3 1 2 4 \n2 4 1 3 5 \n3 4 1 5 2 6 \n```\n\n#### 解析\n\n题目较为清晰。\n可以使用堆来做，存下全是$0$的子段，每次操作选最大字段，然后操作，操作完再把分裂的子段放回堆，重复即可。\n\n#### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint T, n, a[MaxN];\nstruct Node {\n  int l, r;\n  friend bool operator < (Node a, Node b) {\n    return (a.r - a.l + 1) == (b.r - b.l + 1) ? a.l > b.l : (a.r - a.l + 1) < (b.r - b.l + 1);\n  }\n};\nint main() {\n  T = read();\n  while(T --) {\n    n = read(); int k = 0;\n    std :: priority_queue <Node> q;\n    q.push({1, n});\n    while(q.size()) {\n      Node p = q.top(); q.pop();\n      if(p.l == p.r) {\n        a[p.l] = ++k;\n        continue;\n      }\n      int len = p.r - p.l + 1;\n      int x = (len % 2) ? ((p.l + p.r) >> 1) : ((p.l + p.r - 1) >> 1);\n      a[x] = ++k;\n      if(x > p.l) q.push({p.l, x-1});\n      q.push({x+1, p.r});\n    }\n    for(int i = 1; i <= n; ++ i) printf(\"%d \", a[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n```","tags":["solutions","构造题","优先队列","堆"],"categories":["题解","Luogu"]},{"title":"CF 1352G - Special Permutation题解","url":"/post/2274171442.html","content":"<center> CF 1352G - Special Permutation题解 </center>\n<!--more-->\n\n#### 题目描述\n\nA permutation of length $n$ is an array $p=[p_1,p_2,\\dots,p_n]$, which contains every integer from $1$ to $n$ (inclusive) and, moreover, each number appears exactly once. For example, $p=[3,1,4,2,5]$ is a permutation of length $5$.\n\nFor a given number $n$ ($n \\ge 2$), find a permutation $p$ in which absolute difference (that is, the absolute value of difference) of any two neighboring (adjacent) elements is between $2$ and $4$, inclusive. Formally, find such permutation $p$ that $2 \\le |p_i - p_{i+1}| \\le 4$ for each $i$ ($1 \\le i < n$).\n\nPrint any such permutation for the given integer $n$ or determine that it does not exist.\n\n#### 输入格式\n\nThe first line contains an integer $t$ ($1 \\le t \\le 100$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is described by a single line containing an integer $n$ ($2 \\le n \\le 1000$).\n\n#### 输出格式\n\nPrint $t$ lines. Print a permutation that meets the given requirements. If there are several such permutations, then print any of them. If no such permutation exists, print $-1$.\n\n#### 题目大意\n\n有$t$组数据。给定一个数$n$，求$1$ ~ $n$的排列，要求相邻两个数的差的绝对值在$2$ ~ $4$之间。\n\n#### 输入样例\n\n```\n6\n10\n2\n4\n6\n7\n13\n```\n\n#### 输出样例\n\n```\n9 6 10 8 4 7 3 1 5 2 \n-1\n3 1 4 2 \n5 3 6 2 4 1 \n5 1 3 6 2 4 7 \n13 9 7 11 8 4 1 3 5 2 6 10 12 \n```\n\n#### 解析\n\n手玩几个样例，容易发现我们可以把奇数和偶数分别输出。\n比较好写的是，奇数从大到小输出，偶数从小到大输出，再连接部分，输出“4 2”.\n需要注意的是，$n$小于$4$时是不存在答案的。\n\n#### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, T;\nint main() {\n  T = read();\n  while(T --) {\n    n = read(); int x = (n % 2) ? n : (n - 1);\n    if(n <= 3) {\n      std :: cout << \"-1\\n\";\n      continue;\n    }\n    for(int i = x; i >= 1; i -= 2) std :: cout << i << ' ';\n    x = (n % 2) ? (n - 1) : n;\n    std :: cout << \"4 2 \";\n    for(int i = 6; i <= x; i += 2) std :: cout << i << ' ';\n    puts(\"\");\n  }\n  return 0;\n}\n```","tags":["solutions","构造题"],"categories":["题解","CF"]},{"title":"洛谷 P3870 TJOI2009 开关题解","url":"/post/2756585155.html","content":"\n<center> 洛谷 P3870 TJOI2009 开关题解 </center>\n<!--more-->\n\n#### 题目描述\n\n现有$n$盏灯排成一排，从左到右依次编号为：$1,2,…,n$。然后依次执行$m$项操作。\n\n操作分为两种：\n\n1.  指定一个区间$[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）;\n2.  指定一个区间$[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n#### 输入格式\n\n第一行有两个整数$n$和$m$，分别表示灯的数目和操作的数目。\n\n接下来有$m$行，每行有三个整数，依次为：$c、a、b$。其中$c$表示操作的种类。\n\n- 当$c$的值为$0$时，表示是第一种操作。\n- 当$c$的值为$1$时，表示是第二种操作。\n\n$a$和$b$则分别表示了操作区间的左右边界。\n\n#### 输出格式\n\n每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。\n\n#### 输入输出样例\n\n**输入 #1**\n\n```\n4 5\n0 1 2\n0 2 4\n1 2 3\n0 2 4\n1 1 4\n```\n**输出 #1**\n\n```\n1\n2\n```\n\n#### 说明/提示\n\n对于全部的测试点，保证$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 10^5$，$1 \\leq a$,$b \\leq n$，$c \\in \\{0,1\\}$。\n\n#### 解析\n\n这是一道分块题目。\n\n分块复杂度在$O(m \\sqrt{n})$，完全是可以通过的。\n\n每次修改时，除了边缘的灯泡暴力修改，中间块内元素完全可以打标记修改，有一处细节是，`b[i] ^= 1(b[i]：第i个块的修改次数)`即可表示整个块修改的次数。\n\n再设置一个计数数组，累计当前块内打开的灯泡个数。\n\n查询的时候，边缘的仍然暴力，中间块的累计时可以对比`b[i]`来累加`num[i]`，`sum += (b[i] ? block - num[i] : num[i])`。\n\n需要注意的是，每次查询和修改边缘元素时都需要看一下当前块有无标记，若有则下放。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, block, blk[MaxN], a[MaxN], b[MaxN], num[MaxN];\nvoid pushdown(int x) {\n  if(b[blk[x]])\n    for(int i = (blk[x] - 1) * block + 1; i <= blk[x] * block; ++ i)\n      a[i] ^= 1, num[blk[x]] += (a[i] == 1 ? 1 : -1);\n  b[blk[x]] = 0;\n}\nvoid Modify(int l, int r) {\n  pushdown(l);\n  for(int i = l; i <= min(r, blk[l] * block); ++ i)\n    a[i] ^= 1, num[blk[l]] += (a[i] == 1 ? 1 : -1);\n  if(blk[l] != blk[r]) {\n    pushdown(r);\n    for(int i = (blk[r] - 1) * block + 1; i <= r; ++ i)\n      a[i] ^= 1, num[blk[r]] += (a[i] == 1 ? 1 : -1);\n  }\n  for(int i = blk[l] + 1; i <= blk[r] - 1; ++ i)\n    b[i] ^= 1;\n}\nint query(int l, int r) {\n  int sum = 0; pushdown(l);\n  for(int i = l; i <= min(r, blk[l] * block); ++ i)\n    sum += (a[i] == 1);\n  if(blk[l] != blk[r]) {\n    pushdown(r);\n    for(int i = (blk[r] - 1) * block + 1; i <= r; ++ i)\n      sum += (a[i] == 1);\n  }\n  for(int i = blk[l] + 1; i <= blk[r] - 1; ++ i)\n    sum += (b[i] == 0 ? num[i] : (block - num[i]));\n  return sum;\n}\nint main() {\n  n = read(); m = read();\n  block = sqrt(n);\n  for(int i = 1; i <= n; ++ i)\n    blk[i] = (i - 1) / block + 1;\n  for(int i = 1; i <= m; ++ i) {\n    int opt = read(), l = read(), r = read();\n    if(opt == 0) Modify(l, r);\n    else printf(\"%d\\n\", query(l, r));\n  }\n  return 0;\n}\n```","tags":["solutions","分块"],"categories":["题解","Luogu"]},{"title":"HDU-1257 最少拦截系统题解","url":"/post/544537809.html","content":"<center> HDU-1257 最少拦截系统题解 </center>\n<!--more-->\n\n#### Problem Description\n\n某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹. \n\n怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.  \n\n#### Input\n\n输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)  \n\n#### Output\n\n对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.  \n\n#### Sample Input\n\n```\n8 389 207 155 300 299 170 158 65\n```\n\n#### Sample Output\n\n```\n2\n```\n\n#### 解析：\n\n这是一道最长上升子序列的变种题目。\n\n由题意知，只有导弹高度单调递减的时候，才可以使用同一个拦截装置。\n\n那我们就会想什么时候不会使用同一个拦截装置，就是在我们保证前面某一段一直单调递减，然后突然增大，这时候必须再开设一个拦截装置，这显然是求最长上升子序列的问题。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n  s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1010;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN], dp[MaxN], ans;\nint main() {\n  while(scanf(\"%d\", &n) != EOF) {\n    ans = 0;\n    for(int i = 1; i <= n; ++ i) a[i] = read();\n    for(int i = 1; i <= n; ++ i) {\n      dp[i] = 1;\n      for(int j = 1; j < i; ++ j)\n        if(a[i] > a[j]) dp[i] = max(dp[i], dp[j] + 1);\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n```","tags":["solutions","DP","最长上升子序列问题"],"categories":["题解","HDU"]},{"title":"洛谷 P2422 良好的感觉题解","url":"/post/2962024493.html","content":"<center> 洛谷 P2422 良好的感觉题解 </center>\n<!--more-->\n\n#### 题目描述\n\nkkk 做了一个人体感觉分析器。每一天，人都有一个感受值 $A_i$​，$A_i$​ 越大，表示人感觉越舒适。在一段时间 $[i,j]$ 内，人的舒适程度定义为 $[i,j]$ 中最不舒服的那一天的感受值 $[i,j]$中每一天感受值的和。现在给出 kkk 在连续 $N$ 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？\n\n#### 输入格式\n\n第一行为 $N$，代表数据记录的天数。\n\n第二行 $N$ 个整数，代表每一天的感受值。\n\n#### 输出格式\n\n一行，表示在最舒适的一段时间中的感受值。\n\n#### 输入输出样例\n\n**输入 #1**\n\n```\n6\n3 1 6 4 5 2\n```\n**输出 #1**\n\n```\n60\n```\n\n#### 说明/提示\n\nkkk 最开心的一段时间是第 $3$ 天到第 $5$ 天，开心值：$(6+4+5) \\times 4=60$。\n\n对于 $30\\%$ 的数据，$1 \\leq N \\leq 100$。\n\n对于 $70\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000$，$1 \\leq 感受值 \\leq 1000000$。\n\n#### 解析\n\n这是一道单调栈+前缀和题目。\n\n容易想到一个 $O(N^3)$ 的做法，枚举左端点和右端点，再遍历求和和区间最小值，显然会$T$。\n\n容易想到用前缀和优化，但是在这种做法中作用不大。\n\n转换思路，我不枚举左右端点，我枚举最小值，然后求左右端点，最后求和，这个做法可以到达 $O(N^2)$ 的复杂度，还是不行。\n\n我们可以利用单调栈先预处理出每一个点的左右区间端点，然后在枚举最小值，这样就可以达到 $O(N)$ 的复杂度了，完全够用。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline ll read() {\n  ll s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline ll max(ll a, ll b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nll n, a[MaxN], ans, sum[MaxN], L[MaxN], R[MaxN];\nstd :: stack <ll> sL, sR;\nint main() {\n  n = read(); sL.push(0); sR.push(n+1);\n  for(int i = 1; i <= n; ++ i) a[i] = read(), sum[i] = sum[i-1] + a[i];\n  for(int i = 1; i <= n; ++ i) {\n    while(sL.size() && a[sL.top()] >= a[i]) sL.pop();\n    L[i] = sL.top(); \n    sL.push(i);\n  }\n  for(int i = n; i >= 1; -- i) {\n    while(sR.size() && a[sR.top()] >= a[i]) sR.pop();\n    R[i] = sR.top() - 1;\n    sR.push(i);\n  }\n  for(int i = 1; i <= n; ++ i) ans = max(ans, (sum[R[i]] - sum[L[i]]) * a[i]);\n  printf(\"%lld\", ans);\n  return 0;\n}\n```","tags":["solutions","前缀和","单调栈"],"categories":["题解","Luogu"]},{"title":"洛谷 P2629 好消息，坏消息题解","url":"/post/3957807158.html","content":"\n<center> 洛谷 P2629 好消息，坏消息题解 </center>\n<!--more-->\n\n#### 题目描述\n\nUim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,…,n,1,2,…,k−1$（事件编号）这种顺序通报。\n\n他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k−1$ 号事件可以让老板不发怒。\n\n#### 输入格式\n\n第一行一个整数 $n$（$1 \\leq n \\leq 10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$​（$−10^3≤Ai​≤10^3$）。\n\n#### 输出格式\n\n一行一个整数，表示可行的方案个数。\n\n#### 输入输出样例\n\n**输入 #1**\n```\n4\n-3 5 1 2\n```\n**输出 #1**\n```\n2\n```\n#### 说明/提示\n\n**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1$ 或 $3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5 \\rightarrow 1 \\rightarrow 2 \\rightarrow(−3)$ 或 $1 \\rightarrow 2 \\rightarrow (−3) \\rightarrow 5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n \\leq 103$；  \n对于 $75\\%$ 的数据，$n \\leq 104$；  \n对于 $100\\%$ 的数据，$1 \\leq n \\leq 106$。\n\n#### 解析\n\n这是一道单调队列 + 前缀和题目。\n\n由题意可知，消息可以围成一个环形，可以从任意一点出发，累加完 $n$ 个消息，只要在累加过程中累加和不小于 $0$ 即可。\n\n可是用上方做法会 $T$ 掉，所以我们考虑用单调队列维护累加和的最小值。\n\n这道题目类似于滑动窗口，这里是维护 $n$ 个值的最小值，并且窗口不断向后移。\n\n首先开两倍数组存下消息，然后再用前缀和预处理。\n\n我们肯定要枚举 $n$ 个起点，所以不妨从 $1$ 开始枚举，我们可以先把前 $n$ 个前缀和加入单调队列，维护这 $n$ 个数的最小值，然后枚举点不断后移，继续维护从起始点开始的 $n$ 个数的最小值。\n\n只要这个最小值减去起点前一个点的前缀和，那么答案就加一。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN << 1], ans, sum[MaxN << 1];\nint main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = a[i+n] = read();\n  for(int i = 1; i <= n << 1; ++ i) sum[i] = sum[i-1] + a[i];\n  std :: deque <int> q;\n  for(int i = 1; i <= n; ++ i) {\n    while(q.size() && sum[q.back()] >= sum[i]) q.pop_back();\n    q.push_back(i);\n  }\n  for(int i = 1 + n; i <= (n << 1); ++ i) {\n    while(q.size() && sum[q.back()] >= sum[i]) q.pop_back();\n    q.push_back(i);\n    while(q.front() <= i - n) q.pop_front();\n    if(sum[q.front()] - sum[i-n] >= 0) ans ++;\n  } printf(\"%d\", ans);\n  return 0;\n}\n```","tags":["solutions","前缀和","单调队列"],"categories":["题解","Luogu"]},{"title":"AcWing 272. 最长公共上升子序列题解","url":"/post/4176092964.html","content":"\n<center> AcWing 272. 最长公共上升子序列题解 </center>\n<!--more-->\n\n#### 题目描述\n\n熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\n\n小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\n\n小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的\n就是最长公共上升子序列了。\n\n奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\n\n不过，只要告诉奶牛它的长度就可以了。\n\n数列 $A$ 和 $B$ 的长度均不超过 $3000$。\n\n#### 输入格式\n\n第一行包含一个整数 $N$，表示数列 $A$，$B$ 的长度。\n\n第二行包含 $N$ 个整数，表示数列 $A$。\n\n第三行包含 $N$ 个整数，表示数列 $B$。\n\n#### 输出格式\n\n输出一个整数，表示最长公共上升子序列的长度。\n\n#### 数据范围\n\n$1 \\leq N \\leq 3000$,序列中的数字均不超过 $2^{31}−1$。\n\n#### 输入样例：\n\n```\n4\n2 2 1 3\n2 1 2 3\n```\n\n#### 输出样例：\n\n```\n2\n```\n\n#### 解析：\n\n这是一道线性$dp$的题目。\n\n我们表示状态$f[i,j]$为$A_1$~$A_i$和$B_1$~$B_j$构成的以$B_j$为结尾的最长公共上升子序列的长度。\n\n考虑状态转移，因为是$B_j$结尾，所以先枚举数列$A$，再枚举数列$B$。\n\n枚举到$A_i$和$B_j$时，考虑$A_i$是否等于$B_j$。\n1. 当$A_i \\neq B_j$时，$f[i,j] = f[i-1,j]$\n2. 当$A_i = B_j$时，$f[i,j] = \\max_{0 \\leq k < j, B_k < B_j} \\{f[i-1,k]\\} + 1$\n\n主要代码如下\n\n```cpp\nfor(int i = 1; i <= n; ++ i)\n    for(int j = 1; j <= n; ++ j) {\n      f[i][j] = f[i-1][j];\n      if(a[i] == b[j]) {\n        int maxv = 1;\n        for(int k = 1; k < j; ++ k)\n          if(b[k] < b[j]) maxv = max(maxv, f[i-1][k] + 1);\n        f[i][j] = max(f[i][j], maxv);\n      }\n    }\n```\n\n显然，上述做法复杂度达到了$O(n^3)$，而$N \\leq 3000$，显然是不可以过掉的。\n\n当枚举到$B_j$时，我们都会把$k$从$1$到$j-1$给枚举一遍，当枚举到$B_{j+1}$的时候，再把$k$从$1$到$j$枚举一遍，会发现有很多重复运算。\n\n观察上式，因为当$A_i=B_j$，$f[i,j] = \\max_{0 \\leq k < j, B_k < B_j} \\{f[i-1,k]\\} + 1$可以转换为$f[i,j] = \\max_{0 \\leq k < j, B_k < A_i} \\{f[i-1,k]\\} + 1$。\n\n也就是说，当枚举到$i$时，数列$B$中小于$A_i$的数是固定的，当枚举$j$的时候，设$maxv=\\max_{1 \\leq k < j-1}{f[i-1,k]}$，但是这个$maxv$可以在枚举$j$的时候更新，不需要$k$。\n\n如果 $B_j<A_i$，我们就更新最大的$f[i-1,j]$保存到变量$maxv$中；如果$B_j=A_i$，我们就用保存的$maxv$去更新$f[i,j]$。\n\n这样复杂度就来到了$O(n^2)$级别。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 3050;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint a[MaxN], b[MaxN], n, f[MaxN][MaxN], ans = 0;\nint main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = read();\n  for(int i = 1; i <= n; ++ i) b[i] = read();\n  for(int i = 1; i <= n; ++ i) {\n    int maxv = 1;\n    for(int j = 1; j <= n; ++ j) {\n      f[i][j] = f[i-1][j];\n      if(a[i] == b[j]) f[i][j] = max(f[i][j], maxv);\n      if(b[j] < a[i]) maxv = max(maxv, f[i-1][j] + 1);\n    }\n  }\n  for(int i = 1; i <= n; ++ i) ans = max(ans, f[n][i]);\n  printf(\"%d\", ans);\n  return 0;\n}\n```","tags":["solutions","dp","线性dp"],"categories":["题解","AcWing"]},{"title":"AcWing杯 第91场周赛","url":"/post/3045974881.html","content":"\n<center> AcWing杯 第91场周赛 </center>\n<!--more-->\n\n### 本次周赛做题情况\n\n$AC \\quad 2T / 3T$\n\n### 题目分析\n\n#### A AcWing 4861. 构造数列\n\n[原题链接](https://www.acwing.com/problem/content/4864/)\n\n这题目挺简单的，把每一个数位的数除了$0$都取出来，然后乘以$10$的该数位的次方。\n\n比如说，$9876 = 9 \\times 10^3 + 8 \\times 10^2 + 7 \\times 10^1 + 6 \\times 10^0 = 9000 + 800 + 70 + 6$。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 0;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[6];\nint main() {\n  n = read(); a[0] = 1;\n  for(int i = 1; i <= 7; ++ i) a[i] = a[i-1] * 10;\n  while(n --) {\n    int x = read(), cnt = 0;\n    std :: vector < int > ans;\n    ans.clear();\n    while(x) {\n      ans.push_back(x % 10);\n      x /= 10; cnt ++;\n    }\n    for(int i = 0; i < ans.size(); ++ i) {\n      ans[i] *= a[i];\n      if(ans[i] == 0) cnt --;\n    }\n    printf(\"%d\\n\", cnt);\n    for(int i = 0; i < ans.size(); ++ i)\n      if(ans[i] != 0) printf(\"%d \", ans[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n```\n\n#### B AcWing 4862. 浇花\n\n[原题链接](https://www.acwing.com/problem/content/4865/)\n\n这个题目是非常明显的差分题目。\n\n输入的每一段就要加上一个定值$1$，所以可以用差分。\n\n差分完求出最终序列，如果有$0$或者大于$1$的则不合题意。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 10;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, ans[MaxN];\nint main() {\n  n = read(); m = read();\n  for(int i = 1; i <= m; ++ i) {\n    int l = read(), r = read();\n    ans[l] += 1; ans[r+1] -= 1;\n  }\n  for(int i = 1; i <= n; ++ i) ans[i] += ans[i-1];\n  for(int i = 1; i <= n; ++ i)\n    if(ans[i] == 0 || ans[i] > 1) {\n      printf(\"%d %d\", i, ans[i]);\n      return 0;\n    }\n  printf(\"OK\");\n  return 0;\n}\n```\n\n#### C AcWing 4863. 构造新矩阵\n\n[原题链接](https://www.acwing.com/problem/content/4866/)\n\n此题目显然用二分做的，但是我在$check$函数这一步卡住了，到头来也没处理好，还是要多动脑，多练啊。\n\n首先我们二分出一个$mid$，然后$check$它。如果是选$n$行的话，我们只需要保证每一列都至少有一个数大于等于我们的$mid$即可。\n\n而题目要求的是$n-1$，那我们只需要保证在最多$n-1$行下有$n$列中的数字大于等于$mid$即可，这就意味着有至少一行是由两个数字大于等于$mid$。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 10;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint T, n, m;\nstd :: vector <int> g[MaxN];\nbool vis[MaxN];\nbool check(int k) {\n  bool ans = false;\n  for(int i = 0; i < m; ++ i) vis[i] = false;\n  for(int i = 0; i < n; ++ i) {\n    bool flag = 1;\n    for(int j = 0; j < m; ++ j)\n      if(g[j][i] >= k) {\n        flag = 0;\n        if(vis[j]) ans = true;\n        vis[j] = true;\n      }\n    if(flag) return false;\n  } return ans;\n}\nint main() {\n  T = read();\n  while(T --) {\n    m = read(); n = read();\n    for(int i = 0; i < m; ++ i) {\n      g[i].resize(n);\n      for(int j = 0; j < n; ++ j)\n        g[i][j] = read();\n    }\n    int l = 1, r = 1e9, mid;\n    while(l < r) {  \n      mid = (l + r + 1) >> 1;\n      if(check(mid)) l = mid;\n      else r = mid - 1;\n    } printf(\"%d\\n\", r);\n  }\n  return 0;\n}\n```\n","tags":["summaries"],"categories":["比赛总结","AcWing周赛"]},{"title":"洛谷 P2704 [NOI2001]炮兵阵地题解","url":"/post/3333748711.html","content":"\n<center> 洛谷 P2704 [NOI2001]炮兵阵地题解 </center>\n<!--more-->\n\n#### 题目描述\n\n司令部的将军们打算在 $N$ * $M$ 的网格地图上部署他们的炮兵部队。一个$N$ * $M$的地图由N行M列组成，地图的每一格可能是山地（用$“H”$ 表示），也可能是平原（用$“P”$表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/Luogu_P2704.jpg?raw=true)\n\n如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。\n\n#### 输入格式\n\n第一行包含两个由空格分割开的正整数，分别表示$N$和$M$；\n\n接下来的$N$行，每一行含有连续的$M$个字符（$‘P’$或者$‘H’$），中间没有空格。按顺序表示地图中每一行的数据。$N≤100；M≤10$。\n\n#### 输出格式\n仅一行，包含一个整数$K$，表示最多能摆放的炮兵部队的数量。\n\n#### 输入样例\n\n```\n5 4\nPHPP\nPPHH\nPPPP\nPHPP\nPHHP\n```\n\n#### 输出样例\n\n```\n6\n```\n\n#### 解析：\n\n$状压DP$\n\n$dfs$求出状态和状态数\n\n设$N[i][j]$表示第i行第j个状态所用的炮兵数量 \n\n设一个转移状态$dp[i][j][k]$是当前的炮兵数\n\n$i$表示第$i$行，$j$表示第$i$行第$j$个状态，$k$表示第$i-1$行第$k$个状态\n\n方程也特别简单\n\n$dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + N[i][j]);$\n\n然后枚举出第$n$行的所有状态和第$n-1$行的所有状态，取一个$max$\n\n但是会遇到一个问题，就是数组会开的很大，这时通过$dfs$发现\n\n当全都是$P$时，也只有$60$种状态，所以可以减小数组.\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#define re register\ninline int read() {\n\tint s = 0, f = ' '; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if(ch == '-') f = '-'; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = (s << 3) + (s << 1) + ch - '0', ch = getchar();\n\treturn f == '-' ? -s : s;\n}\ninline int max(int a, int b) { return a > b ? a : b;}\nconst int Max = 12;\nconst int MAX = 102;\nconst int INF = 0x7fffffff;\nint n, m, dp[MAX][65][65];\nint st[MAX][65], sum[MAX], N[MAX][65];\nchar ch[MAX][Max];\nvoid dfs(int x, int Sum, int j, int p) {\n\tif(j > m) {\n\t\tst[x][++sum[x]] = Sum; N[x][sum[x]] = p;\n\t\treturn ;\n\t}\n\tdfs(x, Sum, j + 1, p);\n\tif(ch[x][j] == 'P') dfs(x, Sum + (1 << j), j + 3, p + 1);\n}\nint main() {\n\tn = read(); m = read();\n\tfor(re int i = 1; i <= n; ++ i)\n\t\tscanf(\"%s\", ch[i] + 1);\n\tfor(re int i = 1; i <= n; ++ i) dfs(i,0,0,0);\n\tfor(re int i = 1; i <= n; ++ i)\n\t\tfor(re int j = 1; j <= sum[i]; ++ j)\n\t\t\tdp[i][j][0] = N[i][j];\n\tfor(re int i = 1; i <= sum[2]; ++ i)\n\t\tfor(re int j = 1; j <= sum[1]; ++ j) {\n\t\t\tif(st[2][i] & st[1][j]) continue;\n\t\t\tdp[2][i][j] = max(dp[2][i][j], dp[1][j][0] + N[2][i]);\n\t\t}\n\tfor(re int i = 3; i <= n; ++ i) \n\t\tfor(re int j = 1; j <= sum[i]; ++ j)\n\t\t\tfor(re int k = 1; k <= sum[i-1]; ++ k) \n\t\t\t\tfor(re int l = 1; l <= sum[i-2]; ++ l) { \n\t\t\t\t\tif(st[i][j] & st[i-1][k]) continue; \n\t\t\t\t\tif(st[i][j] & st[i-2][l]) continue;\n\t\t\t\t\tif(st[i-1][k] & st[i-2][l]) continue;\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + N[i][j]); \n\t\t\t\t}\n\tint ans = -INF;\n\tfor(re int i = 1; i <= sum[n]; ++ i)\n\t\tfor(re int j = 1; j <= sum[n-1]; ++ j)\n\t\t\tans = max(ans, dp[n][i][j]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n```","tags":["solutions","DP"],"categories":["题解","Luogu"]},{"title":"洛谷 P3258 [JLOI2014]松鼠的新家题解","url":"/post/1581331821.html","content":"\n<center> 洛谷 P3258 [JLOI2014]松鼠的新家题解 </center>\n<!--more-->\n\n#### 题目描述\n\n松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在”树“上。\n\n松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，......，最后到$a_n$，去参观新家。可是这样会导致维尼重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。\n\n维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。\n\n因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。\n\n#### 输入格式\n\n第一行一个整数$n$，表示房间个数第二行$n$个整数，依次描述$a_1-a_n$\n\n接下来$n-1$行，每行两个整数$x$，$y$，表示标号$x$和$y$的两个房间之间有树枝相连。\n\n#### 输出格式\n\n一共$n$行，第$i$行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。\n\n#### 输入样例\n\n```\n5\n1 4 5 3 2\n1 2\n2 4\n2 3\n4 5\n```\n\n#### 输出样例\n\n```\n1\n2\n1\n2\n1\n```\n\n#### 说明/提示\n\n$2<= n <=300000$\n\n#### 解析：\n\n$LCA + 树上差分$\n\n对于访问序号我们将其变成边的形式。\n\n对于所有的的边，\n\n我们会发现第一条和最后一条是特殊的。\n\n1. 第一条是两个端点都是包含的， 即在两个端点上都放糖果：[u,v]\n\n2. 最后一条是两个端点都不包含， 即在两个端点上不放糖果：(u,v)\n\n3. 其余的路径都是一样的，前一个包含，后一个不包含：[u,v)\n\nf数组是倍增lca数组，u和v分别是一边的端点。\n\n1. 先看第一条边，直接进行树上差分，无特殊处理。\n\n2. 最后一条边，我们要进行讨论，一共有3种情况：\n\n    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-f[v][0].\n    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-f[v][0].\n    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-son[v].\n3. 其余的边，也是讨论3种情况：\n    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-v.\n    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-v.\n    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-v\n\n做完这些，就是树上差分的板子了，这里就不赘述了。\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#define re register\n#define gc getchar\ninline int read() {\n\tint s = 0, f = 1; char ch = gc();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = gc();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = gc();\n\treturn s * f;\n}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int INF = 0x7fffffff;\nconst int Max = 600012;\nconst int mod = 19260817;\nconst int N = 1000007;\nstruct Candy {\n\tint net, to;\n}t[Max];\nint n, head[Max], cnt, f[Max][21];\nint x[Max], y[Max], k[Max], deep[Max];\ninline void insert(int u, int v) {\n\tt[++cnt].to = v;\n\tt[cnt].net = head[u];\n\thead[u] = cnt;\n}\nvoid dfs(int x, int Fa) {\n\tf[x][0] = Fa; deep[x] = deep[Fa] + 1;\n\tfor(int i = 1; (1 << i) <= deep[x]; i++)\n\t\tf[x][i] = f[f[x][i-1]][i-1];\n\tint v;\n\tfor(re int i = head[x]; i; i = t[i].net) {\n\t\tv = t[i].to;\n\t\tif(v == Fa) continue;\n\t\tdfs(v,x);\n\t}\n}\nint lca(int x, int y) {\n\tif(deep[x] < deep[y]) std :: swap(x, y);\n\tfor(re int i = 21; i >= 0; -- i)\n\t\tif(deep[x] - (1 << i) >= deep[y])\n\t\t\tx = f[x][i];\n\tif(x == y) return x;\n\tfor(re int i = 20; i >= 0; -- i)\n\t\tif(f[x][i] == f[y][i]) continue;\n\t\telse x = f[x][i], y = f[y][i];\n\treturn f[x][0];\n}\nvoid SUM(int x, int Fa) {\n\tint v;\n\tfor(re int i = head[x]; i; i = t[i].net) {\n\t\tv = t[i].to; if(v == Fa) continue;\n\t\tSUM(v, x); k[x] += k[v];\n\t}\n}\nint find_son(int x, int LCA) {\n\tint depth = deep[LCA] + 1;\n\tfor(re int i = 21; i >= 0; -- i)\n\t\tif(deep[x] - (1 << i) >= depth)\n\t\t\tx = f[x][i];\n\treturn x;\n}\nint main() {\n\tn = read(); int u, v; x[1] = read();\n\tfor(re int i = 1; i < n; ++ i) y[i] = read(), x[i+1] = y[i];\n\tfor(re int i = 1; i < n; ++ i)\n\t\tu = read(), v = read(), insert(u,v), insert(v,u);\n\tdfs(1,0);\n\tint LCA = lca(x[n-1], y[n-1]); bool fg = 1;\n\tif(x[n-1] != LCA && y[n-1] != LCA)\n\t\tu = f[x[n-1]][0], v = f[y[n-1]][0];\n\telse if(x[n-1] == LCA && y[n-1] != LCA) {\n\t\tu = find_son(y[n-1], LCA), v = f[y[n-1]][0];\n\t\tif(f[y[n-1]][0] == x[n-1]) fg = 0;\n\t}\n\telse if(x[n-1] != LCA && y[n-1] == LCA) {\n\t\tu = f[x[n-1]][0], v = find_son(x[n-1], LCA);\n\t\tif(f[x[n-1]][0] == y[n-1]) fg = 0;\n\t}\n\tLCA = lca(u, v);\n\tif(fg) k[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\tu = x[1]; v = y[1]; LCA = lca(u, v);\n\tk[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\tfor(re int i = 2; i < n - 1; ++ i) {\n\t\tLCA = lca(x[i], y[i]);\n\t\tif(x[i] != LCA && y[i] != LCA)\n\t\t\tu = f[x[i]][0], v = y[i];\n\t\telse if(x[i] == LCA && y[i] != LCA)\n\t\t\tu = find_son(y[i], LCA), v = y[i];\n\t\telse if(x[i] != LCA && y[i] == LCA)\n\t\t\tu = f[x[i]][0], v = y[i];\n\t\tLCA = lca(u,v);\n\t\tk[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\t}\n\tSUM(1,0);\n\tfor(re int i = 1; i <= n; ++ i) printf(\"%d\\n\",k[i]);\n\treturn 0;\n}\n```","tags":["solutions","LCA"],"categories":["题解","Luogu"]}]