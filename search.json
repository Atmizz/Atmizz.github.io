[{"title":"洛谷 P3870 TJOI2009 开关题解","url":"/post/2756585155.html","content":"\n<center> 洛谷 P3870 TJOI2009 开关题解 </center>\n<center> solutions, 分块 </center>\n<!--more-->\n\n#### 题目描述\n\n现有$n$盏灯排成一排，从左到右依次编号为：$1,2,…,n$。然后依次执行$m$项操作。\n\n操作分为两种：\n\n1.  指定一个区间$[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）;\n2.  指定一个区间$[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n#### 输入格式\n\n第一行有两个整数$n$和$m$，分别表示灯的数目和操作的数目。\n\n接下来有$m$行，每行有三个整数，依次为：$c、a、b$。其中$c$表示操作的种类。\n\n- 当$c$的值为$0$时，表示是第一种操作。\n- 当$c$的值为$1$时，表示是第二种操作。\n\n$a$和$b$则分别表示了操作区间的左右边界。\n\n#### 输出格式\n\n每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。\n\n#### 输入输出样例\n\n**输入 #1**\n\n```\n4 5\n0 1 2\n0 2 4\n1 2 3\n0 2 4\n1 1 4\n```\n**输出 #1**\n\n```\n1\n2\n```\n\n#### 说明/提示\n\n对于全部的测试点，保证$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 10^5$，$1 \\leq a$,$b \\leq n$，$c \\in \\{0,1\\}$。\n\n#### 解析\n\n这是一道分块题目。\n\n分块复杂度在$O(m \\sqrt{n})$，完全是可以通过的。\n\n每次修改时，除了边缘的灯泡暴力修改，中间块内元素完全可以打标记修改，有一处细节是，`b[i] ^= 1(b[i]：第i个块的修改次数)`即可表示整个块修改的次数。\n\n再设置一个计数数组，累计当前块内打开的灯泡个数。\n\n查询的时候，边缘的仍然暴力，中间块的累计时可以对比`b[i]`来累加`num[i]`，`sum += (b[i] ? block - num[i] : num[i])`。\n\n需要注意的是，每次查询和修改边缘元素时都需要看一下当前块有无标记，若有则下放。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, block, blk[MaxN], a[MaxN], b[MaxN], num[MaxN];\nvoid pushdown(int x) {\n  if(b[blk[x]])\n    for(int i = (blk[x] - 1) * block + 1; i <= blk[x] * block; ++ i)\n      a[i] ^= 1, num[blk[x]] += (a[i] == 1 ? 1 : -1);\n  b[blk[x]] = 0;\n}\nvoid Modify(int l, int r) {\n  pushdown(l);\n  for(int i = l; i <= min(r, blk[l] * block); ++ i)\n    a[i] ^= 1, num[blk[l]] += (a[i] == 1 ? 1 : -1);\n  if(blk[l] != blk[r]) {\n    pushdown(r);\n    for(int i = (blk[r] - 1) * block + 1; i <= r; ++ i)\n      a[i] ^= 1, num[blk[r]] += (a[i] == 1 ? 1 : -1);\n  }\n  for(int i = blk[l] + 1; i <= blk[r] - 1; ++ i)\n    b[i] ^= 1;\n}\nint query(int l, int r) {\n  int sum = 0; pushdown(l);\n  for(int i = l; i <= min(r, blk[l] * block); ++ i)\n    sum += (a[i] == 1);\n  if(blk[l] != blk[r]) {\n    pushdown(r);\n    for(int i = (blk[r] - 1) * block + 1; i <= r; ++ i)\n      sum += (a[i] == 1);\n  }\n  for(int i = blk[l] + 1; i <= blk[r] - 1; ++ i)\n    sum += (b[i] == 0 ? num[i] : (block - num[i]));\n  return sum;\n}\nint main() {\n  n = read(); m = read();\n  block = sqrt(n);\n  for(int i = 1; i <= n; ++ i)\n    blk[i] = (i - 1) / block + 1;\n  for(int i = 1; i <= m; ++ i) {\n    int opt = read(), l = read(), r = read();\n    if(opt == 0) Modify(l, r);\n    else printf(\"%d\\n\", query(l, r));\n  }\n  return 0;\n}\n```","tags":["solutions","分块"]},{"title":"HDU-1257 最少拦截系统题解","url":"/post/544537809.html","content":"<center> HDU-1257 最少拦截系统题解 </center>\n<center> solutions, DP, 最长上升子序列问题 </center>\n<!--more-->\n\n#### Problem Description\n\n某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹. \n\n怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.  \n\n#### Input\n\n输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)  \n\n#### Output\n\n对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.  \n\n#### Sample Input\n\n```\n8 389 207 155 300 299 170 158 65\n```\n\n#### Sample Output\n\n```\n2\n```\n\n#### 解析：\n\n这是一道最长上升子序列的变种题目。\n\n由题意知，只有导弹高度单调递减的时候，才可以使用同一个拦截装置。\n\n那我们就会想什么时候不会使用同一个拦截装置，就是在我们保证前面某一段一直单调递减，然后突然增大，这时候必须再开设一个拦截装置，这显然是求最长上升子序列的问题。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n  s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1010;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN], dp[MaxN], ans;\nint main() {\n  while(scanf(\"%d\", &n) != EOF) {\n    ans = 0;\n    for(int i = 1; i <= n; ++ i) a[i] = read();\n    for(int i = 1; i <= n; ++ i) {\n      dp[i] = 1;\n      for(int j = 1; j < i; ++ j)\n        if(a[i] > a[j]) dp[i] = max(dp[i], dp[j] + 1);\n      ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n```","tags":["solutions","DP","最长上升子序列问题"]},{"title":"洛谷 P2422 良好的感觉题解","url":"/post/2962024493.html","content":"\n#### 题目描述\n\nkkk 做了一个人体感觉分析器。每一天，人都有一个感受值 $A_i$​，$A_i$​ 越大，表示人感觉越舒适。在一段时间 $[i,j]$ 内，人的舒适程度定义为 $[i,j]$ 中最不舒服的那一天的感受值 $[i,j]$中每一天感受值的和。现在给出 kkk 在连续 $N$ 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？\n\n<!--more-->\n\n#### 输入格式\n\n第一行为 $N$，代表数据记录的天数。\n\n第二行 $N$ 个整数，代表每一天的感受值。\n\n#### 输出格式\n\n一行，表示在最舒适的一段时间中的感受值。\n\n#### 输入输出样例\n\n**输入 #1**\n\n```\n6\n3 1 6 4 5 2\n```\n**输出 #1**\n\n```\n60\n```\n\n#### 说明/提示\n\nkkk 最开心的一段时间是第 $3$ 天到第 $5$ 天，开心值：$(6+4+5) \\times 4=60$。\n\n对于 $30\\%$ 的数据，$1 \\leq N \\leq 100$。\n\n对于 $70\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000$，$1 \\leq 感受值 \\leq 1000000$。\n\n#### 解析\n\n这是一道单调栈+前缀和题目。\n\n容易想到一个 $O(N^3)$ 的做法，枚举左端点和右端点，再遍历求和和区间最小值，显然会$T$。\n\n容易想到用前缀和优化，但是在这种做法中作用不大。\n\n转换思路，我不枚举左右端点，我枚举最小值，然后求左右端点，最后求和，这个做法可以到达 $O(N^2)$ 的复杂度，还是不行。\n\n我们可以利用单调栈先预处理出每一个点的左右区间端点，然后在枚举最小值，这样就可以达到 $O(N)$ 的复杂度了，完全够用。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline ll read() {\n  ll s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline ll max(ll a, ll b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nll n, a[MaxN], ans, sum[MaxN], L[MaxN], R[MaxN];\nstd :: stack <ll> sL, sR;\nint main() {\n  n = read(); sL.push(0); sR.push(n+1);\n  for(int i = 1; i <= n; ++ i) a[i] = read(), sum[i] = sum[i-1] + a[i];\n  for(int i = 1; i <= n; ++ i) {\n    while(sL.size() && a[sL.top()] >= a[i]) sL.pop();\n    L[i] = sL.top(); \n    sL.push(i);\n  }\n  for(int i = n; i >= 1; -- i) {\n    while(sR.size() && a[sR.top()] >= a[i]) sR.pop();\n    R[i] = sR.top() - 1;\n    sR.push(i);\n  }\n  for(int i = 1; i <= n; ++ i) ans = max(ans, (sum[R[i]] - sum[L[i]]) * a[i]);\n  printf(\"%lld\", ans);\n  return 0;\n}\n```","tags":["solutions","单调栈","前缀和"]},{"title":"洛谷 P2629 好消息，坏消息题解","url":"/post/3957807158.html","content":"\n<center> 洛谷 P2629 好消息，坏消息题解 </center>\n<center> solutions, 单调队列, 前缀和 </center>\n<!--more-->\n\n#### 题目描述\n\nUim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,…,n,1,2,…,k−1$（事件编号）这种顺序通报。\n\n他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k−1$ 号事件可以让老板不发怒。\n\n#### 输入格式\n\n第一行一个整数 $n$（$1 \\leq n \\leq 10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$​（$−10^3≤Ai​≤10^3$）。\n\n#### 输出格式\n\n一行一个整数，表示可行的方案个数。\n\n#### 输入输出样例\n\n**输入 #1**\n```\n4\n-3 5 1 2\n```\n**输出 #1**\n```\n2\n```\n#### 说明/提示\n\n**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1$ 或 $3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5 \\rightarrow 1 \\rightarrow 2 \\rightarrow(−3)$ 或 $1 \\rightarrow 2 \\rightarrow (−3) \\rightarrow 5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n \\leq 103$；  \n对于 $75\\%$ 的数据，$n \\leq 104$；  \n对于 $100\\%$ 的数据，$1 \\leq n \\leq 106$。\n\n#### 解析\n\n这是一道单调队列 + 前缀和题目。\n\n由题意可知，消息可以围成一个环形，可以从任意一点出发，累加完 $n$ 个消息，只要在累加过程中累加和不小于 $0$ 即可。\n\n可是用上方做法会 $T$ 掉，所以我们考虑用单调队列维护累加和的最小值。\n\n这道题目类似于滑动窗口，这里是维护 $n$ 个值的最小值，并且窗口不断向后移。\n\n首先开两倍数组存下消息，然后再用前缀和预处理。\n\n我们肯定要枚举 $n$ 个起点，所以不妨从 $1$ 开始枚举，我们可以先把前 $n$ 个前缀和加入单调队列，维护这 $n$ 个数的最小值，然后枚举点不断后移，继续维护从起始点开始的 $n$ 个数的最小值。\n\n只要这个最小值减去起点前一个点的前缀和，那么答案就加一。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e6 + 200;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[MaxN << 1], ans, sum[MaxN << 1];\nint main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = a[i+n] = read();\n  for(int i = 1; i <= n << 1; ++ i) sum[i] = sum[i-1] + a[i];\n  std :: deque <int> q;\n  for(int i = 1; i <= n; ++ i) {\n    while(q.size() && sum[q.back()] >= sum[i]) q.pop_back();\n    q.push_back(i);\n  }\n  for(int i = 1 + n; i <= (n << 1); ++ i) {\n    while(q.size() && sum[q.back()] >= sum[i]) q.pop_back();\n    q.push_back(i);\n    while(q.front() <= i - n) q.pop_front();\n    if(sum[q.front()] - sum[i-n] >= 0) ans ++;\n  } printf(\"%d\", ans);\n  return 0;\n}\n```","tags":["solutions","前缀和","单调队列"]},{"title":"AcWing 272. 最长公共上升子序列题解","url":"/post/4176092964.html","content":"\n<center> AcWing 272. 最长公共上升子序列题解 </center>\n<center> solutions, dp, 线性dp </center>\n<!--more-->\n\n#### 题目描述\n\n熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\n\n小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\n\n小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的\n就是最长公共上升子序列了。\n\n奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\n\n不过，只要告诉奶牛它的长度就可以了。\n\n数列 $A$ 和 $B$ 的长度均不超过 $3000$。\n\n#### 输入格式\n\n第一行包含一个整数 $N$，表示数列 $A$，$B$ 的长度。\n\n第二行包含 $N$ 个整数，表示数列 $A$。\n\n第三行包含 $N$ 个整数，表示数列 $B$。\n\n#### 输出格式\n\n输出一个整数，表示最长公共上升子序列的长度。\n\n#### 数据范围\n\n$1 \\leq N \\leq 3000$,序列中的数字均不超过 $2^{31}−1$。\n\n#### 输入样例：\n\n```\n4\n2 2 1 3\n2 1 2 3\n```\n\n#### 输出样例：\n\n```\n2\n```\n\n#### 解析：\n\n这是一道线性$dp$的题目。\n\n我们表示状态$f[i,j]$为$A_1$~$A_i$和$B_1$~$B_j$构成的以$B_j$为结尾的最长公共上升子序列的长度。\n\n考虑状态转移，因为是$B_j$结尾，所以先枚举数列$A$，再枚举数列$B$。\n\n枚举到$A_i$和$B_j$时，考虑$A_i$是否等于$B_j$。\n1. 当$A_i \\neq B_j$时，$f[i,j] = f[i-1,j]$\n2. 当$A_i = B_j$时，$f[i,j] = \\max_{0 \\leq k < j, B_k < B_j} \\{f[i-1,k]\\} + 1$\n\n主要代码如下\n\n```cpp\nfor(int i = 1; i <= n; ++ i)\n    for(int j = 1; j <= n; ++ j) {\n      f[i][j] = f[i-1][j];\n      if(a[i] == b[j]) {\n        int maxv = 1;\n        for(int k = 1; k < j; ++ k)\n          if(b[k] < b[j]) maxv = max(maxv, f[i-1][k] + 1);\n        f[i][j] = max(f[i][j], maxv);\n      }\n    }\n```\n\n显然，上述做法复杂度达到了$O(n^3)$，而$N \\leq 3000$，显然是不可以过掉的。\n\n当枚举到$B_j$时，我们都会把$k$从$1$到$j-1$给枚举一遍，当枚举到$B_{j+1}$的时候，再把$k$从$1$到$j$枚举一遍，会发现有很多重复运算。\n\n观察上式，因为当$A_i=B_j$，$f[i,j] = \\max_{0 \\leq k < j, B_k < B_j} \\{f[i-1,k]\\} + 1$可以转换为$f[i,j] = \\max_{0 \\leq k < j, B_k < A_i} \\{f[i-1,k]\\} + 1$。\n\n也就是说，当枚举到$i$时，数列$B$中小于$A_i$的数是固定的，当枚举$j$的时候，设$maxv=\\max_{1 \\leq k < j-1}{f[i-1,k]}$，但是这个$maxv$可以在枚举$j$的时候更新，不需要$k$。\n\n如果 $B_j<A_i$，我们就更新最大的$f[i-1,j]$保存到变量$maxv$中；如果$B_j=A_i$，我们就用保存的$maxv$去更新$f[i,j]$。\n\n这样复杂度就来到了$O(n^2)$级别。\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 3050;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint a[MaxN], b[MaxN], n, f[MaxN][MaxN], ans = 0;\nint main() {\n  n = read();\n  for(int i = 1; i <= n; ++ i) a[i] = read();\n  for(int i = 1; i <= n; ++ i) b[i] = read();\n  for(int i = 1; i <= n; ++ i) {\n    int maxv = 1;\n    for(int j = 1; j <= n; ++ j) {\n      f[i][j] = f[i-1][j];\n      if(a[i] == b[j]) f[i][j] = max(f[i][j], maxv);\n      if(b[j] < a[i]) maxv = max(maxv, f[i-1][j] + 1);\n    }\n  }\n  for(int i = 1; i <= n; ++ i) ans = max(ans, f[n][i]);\n  printf(\"%d\", ans);\n  return 0;\n}\n```","tags":["solutions","dp","线性dp"]},{"title":"AcWing杯 第91场周赛","url":"/post/3045974881.html","content":"\n<center> AcWing杯 第91场周赛 </center>\n<center> summaries AcWing杯 </center>\n<!--more-->\n\n### 本次周赛做题情况\n\n$AC \\quad 2T / 3T$\n\n### 题目分析\n\n#### A AcWing 4861. 构造数列\n\n[原题链接](https://www.acwing.com/problem/content/4864/)\n\n这题目挺简单的，把每一个数位的数除了$0$都取出来，然后乘以$10$的该数位的次方。\n\n比如说，$9876 = 9 \\times 10^3 + 8 \\times 10^2 + 7 \\times 10^1 + 6 \\times 10^0 = 9000 + 800 + 70 + 6$。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 0;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, a[6];\nint main() {\n  n = read(); a[0] = 1;\n  for(int i = 1; i <= 7; ++ i) a[i] = a[i-1] * 10;\n  while(n --) {\n    int x = read(), cnt = 0;\n    std :: vector < int > ans;\n    ans.clear();\n    while(x) {\n      ans.push_back(x % 10);\n      x /= 10; cnt ++;\n    }\n    for(int i = 0; i < ans.size(); ++ i) {\n      ans[i] *= a[i];\n      if(ans[i] == 0) cnt --;\n    }\n    printf(\"%d\\n\", cnt);\n    for(int i = 0; i < ans.size(); ++ i)\n      if(ans[i] != 0) printf(\"%d \", ans[i]);\n    puts(\"\");\n  }\n  return 0;\n}\n```\n\n#### B AcWing 4862. 浇花\n\n[原题链接](https://www.acwing.com/problem/content/4865/)\n\n这个题目是非常明显的差分题目。\n\n输入的每一段就要加上一个定值$1$，所以可以用差分。\n\n差分完求出最终序列，如果有$0$或者大于$1$的则不合题意。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 10;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint n, m, ans[MaxN];\nint main() {\n  n = read(); m = read();\n  for(int i = 1; i <= m; ++ i) {\n    int l = read(), r = read();\n    ans[l] += 1; ans[r+1] -= 1;\n  }\n  for(int i = 1; i <= n; ++ i) ans[i] += ans[i-1];\n  for(int i = 1; i <= n; ++ i)\n    if(ans[i] == 0 || ans[i] > 1) {\n      printf(\"%d %d\", i, ans[i]);\n      return 0;\n    }\n  printf(\"OK\");\n  return 0;\n}\n```\n\n#### C AcWing 4863. 构造新矩阵\n\n[原题链接](https://www.acwing.com/problem/content/4866/)\n\n此题目显然用二分做的，但是我在$check$函数这一步卡住了，到头来也没处理好，还是要多动脑，多练啊。\n\n首先我们二分出一个$mid$，然后$check$它。如果是选$n$行的话，我们只需要保证每一列都至少有一个数大于等于我们的$mid$即可。\n\n而题目要求的是$n-1$，那我们只需要保证在最多$n-1$行下有$n$列中的数字大于等于$mid$即可，这就意味着有至少一行是由两个数字大于等于$mid$。\n\n##### 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define ls k << 1\n#define rs k << 1 | 1\n#define gc getchar()\ntypedef long long ll;\ninline int read() {\n  int s = 0, f = 1; char ch = gc;\n  for(; ch < '0' || ch > '9'; ch = gc) if(ch == '-') f = -1;\n  for(; ch >= '0' && ch <= '9'; ch = gc)\n    s = (s << 1) + (s << 3) + (ch ^ 48);\n  return s * f;\n}\ninline int abs(int a) {return a < 0 ? -a : a;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int MaxN = 1e5 + 10;\nconst int Mod = 1e9 + 7;\nconst int INF = 2147483647;\nint T, n, m;\nstd :: vector <int> g[MaxN];\nbool vis[MaxN];\nbool check(int k) {\n  bool ans = false;\n  for(int i = 0; i < m; ++ i) vis[i] = false;\n  for(int i = 0; i < n; ++ i) {\n    bool flag = 1;\n    for(int j = 0; j < m; ++ j)\n      if(g[j][i] >= k) {\n        flag = 0;\n        if(vis[j]) ans = true;\n        vis[j] = true;\n      }\n    if(flag) return false;\n  } return ans;\n}\nint main() {\n  T = read();\n  while(T --) {\n    m = read(); n = read();\n    for(int i = 0; i < m; ++ i) {\n      g[i].resize(n);\n      for(int j = 0; j < n; ++ j)\n        g[i][j] = read();\n    }\n    int l = 1, r = 1e9, mid;\n    while(l < r) {  \n      mid = (l + r + 1) >> 1;\n      if(check(mid)) l = mid;\n      else r = mid - 1;\n    } printf(\"%d\\n\", r);\n  }\n  return 0;\n}\n```","tags":["summaries"]},{"title":"洛谷 P2704 [NOI2001]炮兵阵地题解","url":"/post/3333748711.html","content":"\n<center> 洛谷 P2704 [NOI2001]炮兵阵地题解 </center>\n<center> solutions, DP </center>\n<!--more-->\n\n#### 题目描述\n\n司令部的将军们打算在 $N$ * $M$ 的网格地图上部署他们的炮兵部队。一个$N$ * $M$的地图由N行M列组成，地图的每一格可能是山地（用$“H”$ 表示），也可能是平原（用$“P”$表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：\n\n![](https://github.com/Atmizz/picturebox/blob/main/Github_blog/pictures/Luogu_P2704.jpg?raw=true)\n\n如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。\n\n#### 输入格式\n\n第一行包含两个由空格分割开的正整数，分别表示$N$和$M$；\n\n接下来的$N$行，每一行含有连续的$M$个字符（$‘P’$或者$‘H’$），中间没有空格。按顺序表示地图中每一行的数据。$N≤100；M≤10$。\n\n#### 输出格式\n仅一行，包含一个整数$K$，表示最多能摆放的炮兵部队的数量。\n\n#### 输入样例\n\n```\n5 4\nPHPP\nPPHH\nPPPP\nPHPP\nPHHP\n```\n\n#### 输出样例\n\n```\n6\n```\n\n#### 解析：\n\n$状压DP$\n\n$dfs$求出状态和状态数\n\n设$N[i][j]$表示第i行第j个状态所用的炮兵数量 \n\n设一个转移状态$dp[i][j][k]$是当前的炮兵数\n\n$i$表示第$i$行，$j$表示第$i$行第$j$个状态，$k$表示第$i-1$行第$k$个状态\n\n方程也特别简单\n\n$dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + N[i][j]);$\n\n然后枚举出第$n$行的所有状态和第$n-1$行的所有状态，取一个$max$\n\n但是会遇到一个问题，就是数组会开的很大，这时通过$dfs$发现\n\n当全都是$P$时，也只有$60$种状态，所以可以减小数组.\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#define re register\ninline int read() {\n\tint s = 0, f = ' '; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if(ch == '-') f = '-'; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = (s << 3) + (s << 1) + ch - '0', ch = getchar();\n\treturn f == '-' ? -s : s;\n}\ninline int max(int a, int b) { return a > b ? a : b;}\nconst int Max = 12;\nconst int MAX = 102;\nconst int INF = 0x7fffffff;\nint n, m, dp[MAX][65][65];\nint st[MAX][65], sum[MAX], N[MAX][65];\nchar ch[MAX][Max];\nvoid dfs(int x, int Sum, int j, int p) {\n\tif(j > m) {\n\t\tst[x][++sum[x]] = Sum; N[x][sum[x]] = p;\n\t\treturn ;\n\t}\n\tdfs(x, Sum, j + 1, p);\n\tif(ch[x][j] == 'P') dfs(x, Sum + (1 << j), j + 3, p + 1);\n}\nint main() {\n\tn = read(); m = read();\n\tfor(re int i = 1; i <= n; ++ i)\n\t\tscanf(\"%s\", ch[i] + 1);\n\tfor(re int i = 1; i <= n; ++ i) dfs(i,0,0,0);\n\tfor(re int i = 1; i <= n; ++ i)\n\t\tfor(re int j = 1; j <= sum[i]; ++ j)\n\t\t\tdp[i][j][0] = N[i][j];\n\tfor(re int i = 1; i <= sum[2]; ++ i)\n\t\tfor(re int j = 1; j <= sum[1]; ++ j) {\n\t\t\tif(st[2][i] & st[1][j]) continue;\n\t\t\tdp[2][i][j] = max(dp[2][i][j], dp[1][j][0] + N[2][i]);\n\t\t}\n\tfor(re int i = 3; i <= n; ++ i) \n\t\tfor(re int j = 1; j <= sum[i]; ++ j)\n\t\t\tfor(re int k = 1; k <= sum[i-1]; ++ k) \n\t\t\t\tfor(re int l = 1; l <= sum[i-2]; ++ l) { \n\t\t\t\t\tif(st[i][j] & st[i-1][k]) continue; \n\t\t\t\t\tif(st[i][j] & st[i-2][l]) continue;\n\t\t\t\t\tif(st[i-1][k] & st[i-2][l]) continue;\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + N[i][j]); \n\t\t\t\t}\n\tint ans = -INF;\n\tfor(re int i = 1; i <= sum[n]; ++ i)\n\t\tfor(re int j = 1; j <= sum[n-1]; ++ j)\n\t\t\tans = max(ans, dp[n][i][j]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n```","tags":["solutions","DP"]},{"title":"洛谷 P3258 [JLOI2014]松鼠的新家题解","url":"/post/1581331821.html","content":"\n<center> 洛谷 P3258 [JLOI2014]松鼠的新家题解 </center>\n<center> solutions, LCA </center>\n<!--more-->\n\n#### 题目描述\n\n松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在”树“上。\n\n松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，......，最后到$a_n$，去参观新家。可是这样会导致维尼重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。\n\n维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。\n\n因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。\n\n#### 输入格式\n\n第一行一个整数$n$，表示房间个数第二行$n$个整数，依次描述$a_1-a_n$\n\n接下来$n-1$行，每行两个整数$x$，$y$，表示标号$x$和$y$的两个房间之间有树枝相连。\n\n#### 输出格式\n\n一共$n$行，第$i$行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。\n\n#### 输入样例\n\n```\n5\n1 4 5 3 2\n1 2\n2 4\n2 3\n4 5\n```\n\n#### 输出样例\n\n```\n1\n2\n1\n2\n1\n```\n\n#### 说明/提示\n\n$2<= n <=300000$\n\n#### 解析：\n\n$LCA + 树上差分$\n\n对于访问序号我们将其变成边的形式。\n\n对于所有的的边，\n\n我们会发现第一条和最后一条是特殊的。\n\n1. 第一条是两个端点都是包含的， 即在两个端点上都放糖果：[u,v]\n\n2. 最后一条是两个端点都不包含， 即在两个端点上不放糖果：(u,v)\n\n3. 其余的路径都是一样的，前一个包含，后一个不包含：[u,v)\n\nf数组是倍增lca数组，u和v分别是一边的端点。\n\n1. 先看第一条边，直接进行树上差分，无特殊处理。\n\n2. 最后一条边，我们要进行讨论，一共有3种情况：\n\n    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-f[v][0].\n    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-f[v][0].\n    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-son[v].\n3. 其余的边，也是讨论3种情况：\n    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-v.\n    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-v.\n    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-v\n\n做完这些，就是树上差分的板子了，这里就不赘述了。\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#define re register\n#define gc getchar\ninline int read() {\n\tint s = 0, f = 1; char ch = gc();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = gc();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = gc();\n\treturn s * f;\n}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline int max(int a, int b) {return a > b ? a : b;}\nconst int INF = 0x7fffffff;\nconst int Max = 600012;\nconst int mod = 19260817;\nconst int N = 1000007;\nstruct Candy {\n\tint net, to;\n}t[Max];\nint n, head[Max], cnt, f[Max][21];\nint x[Max], y[Max], k[Max], deep[Max];\ninline void insert(int u, int v) {\n\tt[++cnt].to = v;\n\tt[cnt].net = head[u];\n\thead[u] = cnt;\n}\nvoid dfs(int x, int Fa) {\n\tf[x][0] = Fa; deep[x] = deep[Fa] + 1;\n\tfor(int i = 1; (1 << i) <= deep[x]; i++)\n\t\tf[x][i] = f[f[x][i-1]][i-1];\n\tint v;\n\tfor(re int i = head[x]; i; i = t[i].net) {\n\t\tv = t[i].to;\n\t\tif(v == Fa) continue;\n\t\tdfs(v,x);\n\t}\n}\nint lca(int x, int y) {\n\tif(deep[x] < deep[y]) std :: swap(x, y);\n\tfor(re int i = 21; i >= 0; -- i)\n\t\tif(deep[x] - (1 << i) >= deep[y])\n\t\t\tx = f[x][i];\n\tif(x == y) return x;\n\tfor(re int i = 20; i >= 0; -- i)\n\t\tif(f[x][i] == f[y][i]) continue;\n\t\telse x = f[x][i], y = f[y][i];\n\treturn f[x][0];\n}\nvoid SUM(int x, int Fa) {\n\tint v;\n\tfor(re int i = head[x]; i; i = t[i].net) {\n\t\tv = t[i].to; if(v == Fa) continue;\n\t\tSUM(v, x); k[x] += k[v];\n\t}\n}\nint find_son(int x, int LCA) {\n\tint depth = deep[LCA] + 1;\n\tfor(re int i = 21; i >= 0; -- i)\n\t\tif(deep[x] - (1 << i) >= depth)\n\t\t\tx = f[x][i];\n\treturn x;\n}\nint main() {\n\tn = read(); int u, v; x[1] = read();\n\tfor(re int i = 1; i < n; ++ i) y[i] = read(), x[i+1] = y[i];\n\tfor(re int i = 1; i < n; ++ i)\n\t\tu = read(), v = read(), insert(u,v), insert(v,u);\n\tdfs(1,0);\n\tint LCA = lca(x[n-1], y[n-1]); bool fg = 1;\n\tif(x[n-1] != LCA && y[n-1] != LCA)\n\t\tu = f[x[n-1]][0], v = f[y[n-1]][0];\n\telse if(x[n-1] == LCA && y[n-1] != LCA) {\n\t\tu = find_son(y[n-1], LCA), v = f[y[n-1]][0];\n\t\tif(f[y[n-1]][0] == x[n-1]) fg = 0;\n\t}\n\telse if(x[n-1] != LCA && y[n-1] == LCA) {\n\t\tu = f[x[n-1]][0], v = find_son(x[n-1], LCA);\n\t\tif(f[x[n-1]][0] == y[n-1]) fg = 0;\n\t}\n\tLCA = lca(u, v);\n\tif(fg) k[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\tu = x[1]; v = y[1]; LCA = lca(u, v);\n\tk[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\tfor(re int i = 2; i < n - 1; ++ i) {\n\t\tLCA = lca(x[i], y[i]);\n\t\tif(x[i] != LCA && y[i] != LCA)\n\t\t\tu = f[x[i]][0], v = y[i];\n\t\telse if(x[i] == LCA && y[i] != LCA)\n\t\t\tu = find_son(y[i], LCA), v = y[i];\n\t\telse if(x[i] != LCA && y[i] == LCA)\n\t\t\tu = f[x[i]][0], v = y[i];\n\t\tLCA = lca(u,v);\n\t\tk[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;\n\t}\n\tSUM(1,0);\n\tfor(re int i = 1; i <= n; ++ i) printf(\"%d\\n\",k[i]);\n\treturn 0;\n}\n```","tags":["solutions","LCA"]}]